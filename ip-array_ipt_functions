#!/bin/bash

# ------------------------------------------------------------------------- #

  #*#   ######             #
   #    #     #           # #    #####   #####     ##     #   #
   #    #     #          #   #   #    #  #    #   #  #     # #
   #    ######   #####  #     #  #    #  #    #  #    #     #
   #    #               #######  #####   #####   ######     #
   #    #               #     #  #   #   #   #   #    #     #
  ###   #               #     #  #    #  #    #  #    #     #

# ------------------------------------------------------------------------- #
#
#    Copyright (C) 2005-2013  AllKind
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#
# ------------------------------------------------------------------------- #
#
#                      IP-ARRAY IPTABLES FUNCTIONS
#
# ------------------------------------------------------------------------- #

# ------------------------------------------------------------------------- #
# IPSET
# ------------------------------------------------------------------------- #

val_setname() { # validate name of an ipset set
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
[[ ${1:0:1} != : ]] || {
	log -E "Invalid setname \`$1' - must not begin with a colon."
	return 1
}
[[ $1 != *+([[:space:]])* ]] || {
	log -E "Invalid setname \`$1' - must not contain spaces."
	return 1
}
} # -------------------------------------------------------------------------

val_ipset_port_spec() {
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local str_p="$1" str_r_end
case "$1" in
	@(tcp|sctp|udp|udplite):\[*+([[:alpha:]])*\]-\[*+([[:alpha:]])*\])
		val_port_range_word "${1#@(tcp|sctp|udp|udplite):}" || return
	;;
	@(tcp|sctp|udp|udplite):\[*+([[:alpha:]])*\]-+([[:word:]]))
		val_port_range_word "${1#@(tcp|sctp|udp|udplite):}" || return
	;;
	@(tcp|sctp|udp|udplite):+([[:word:]])-\[*+([[:alpha:]])*\])
		val_port_range_word "${1#@(tcp|sctp|udp|udplite):}" || return
	;;
	@(tcp|sctp|udp|udplite):@(+([[:word:]])-+([[:word:]])|+([[:digit:]])-+([[:digit:]])))
		val_port_range_word "${1#@(tcp|sctp|udp|udplite):}" || return
	;;
	@(tcp|sctp|udp|udplite):@(+([[:word:]])|+([[:digit:]])))
		val_port "${1#@(tcp|sctp|udp|udplite):}" || return
	;;
	@(tcp|sctp|udp|udplite):\[*+([[:alpha:]])*\])
		str_p="${1#@(tcp|sctp|udp|udplite):\[}"
		str_p="${str_p%\]}"
		val_port "$str_p" || return
	;;
	icmp:*)
		val_icmp_type "${1#icmp:}" || return
	;;
	+([[:word:]])-+([[:word:]])|+([[:digit:]])-+([[:digit:]]))
		val_port_range_word "$1" || return
	;;
	+([[:word:]])-+([[:word:]]))
		val_port_range_word "$1" || return
	;;
	\[*\]-\[*\]|\[*\]-+([[:word:]])|+([[:word:]])-\[*\])
		val_port_range_word "$1" || return
	;;
	+([[:digit:]]):0|*+([[:alpha:]])*:0)
		val_proto "${1%:0}" || return
	;;
	+([[:digit:]])|+([[:word:]]))
		val_port "$1" || return
	;;
	\[*+([[:alpha:]])*-*+([[:alpha:]])*\])
		str_p="${str_p#[}"
		str_p="${str_p%]}"
		val_port "$str_p" || return
	;;
	*) log -E "Invalid entry \`$1' expecting: [proto:]port."
		return 1
esac
} # -------------------------------------------------------------------------

ipset_create() { # create an ipset set (cache commands)
[[ $2 ]] || { reqparm $FUNCNAME 2; return 1; }
local str_set="$1" str_type="$2" str_create="-N" str_tmp
shift 2
local -a arr_opts
local option opt_arg
local strERR="Failed creating set \`$str_set'."
local str_failcmd='eval log -F "$strERR"; raise_cfg_err_count; return 0'
val_setname "$str_set" || { raise_cfg_err_count; return $ER_CONF; }
lsearch "$str_set" $(show_array_column CREATED_SETS_ARRAY) && {
	log -W "ipset set \`$str_set' has already been created."
	return 0
}
lsearch "$str_type" $UNSUPPORTED_SETLIST && {
	log -E "ipset set type \`$str_type' is not supported."
	$str_failcmd
}
if [[ $IPSET_SYNTAX = new ]]; then
	str_create=create
fi
case "$str_type" in
	bitmap:ip|bitmap:ip,mac|bitmap:port)
		local -a arr_opts=("$@")
		while (($#)); do
			option="$1" opt_arg="$2"
			if [[ -z $opt_arg ]]; then
				log -E "$strERR Missing value to option \`$option' for \`$str_type' set." 
				$str_failcmd
			fi
			case "$option" in
				range)
					if [[ $str_type = bitmap:port ]]; then
						val_port_range_word "$opt_arg" || $str_failcmd
					else
						val_ip4_addr "$opt_arg" || $str_failcmd
					fi
					shift 2
				;;
				netmask)
					if [[ $str_type = bitmap:ip ]]; then
						val_numeric "$opt_arg" || $str_failcmd
						((opt_arg >= 1 && <= 32)) || {
							log -E "$strERR Invalid value \`$opt_arg' with \`$option' for \`$str_type' set. Valid range: 1-32."
							$str_failcmd
						}
						shift 2
					else
						log -E "$strERR Invalid option \`$option' for \`$str_type' set."
						$str_failcmd

					fi
				;;
				timeout)
					val_numeric "$opt_arg" || $str_failcmd
					shift 2
				;;
				*) log -E "$strERR Invalid option \`$option' for \`$str_type' set."
					$str_failcmd
				;;
			esac
		done
	;;
	hash:ip|hash:net|hash:ip,port|hash:net,port|hash:ip,port,ip|hash:ip,port,net|hash:net,iface)
		local -a arr_opts=("$@")
		while (($#)); do
			option="$1" opt_arg="$2"
			if [[ -z $opt_arg ]]; then
				log -E "$strERR Missing value to option \`$option' for \`$str_type' set." 
				$str_failcmd
			fi
			case "$option" in
				family)
					if [[ $opt_arg = inet6 ]]; then
						log -E "Option argument \`$opt_arg' is not supported."
						$str_failcmd
					elif [[ $opt_arg = inet ]]; then :
					else
						log -E "$strERR Invalid value \`$opt_arg' with \`$option' for \`$str_type' set. Valid values: inet|inet6."
						$str_failcmd
					fi	
					shift 2
				;;
				hashsize)
					val_numeric "$opt_arg" || $str_failcmd
					shift 2
				;;
				maxelem)
					val_numeric "$opt_arg" || $str_failcmd
					shift 2
				;;
				netmask)
					case "$str_type" in
						hash:ip)
							((opt_arg >= 1 && <= 32)) || {
								log -E "$strERR Invalid value \`$opt_arg' with \`$option' for \`$str_type' set. Valid range: 1-32."
								$str_failcmd
							}
							shift 2
						;;
						*) log -E "$strERR Invalid option \`$option' for \`$str_type' set."
							$str_failcmd
					esac
				;;
				timeout)
					val_numeric "$opt_arg" || $str_failcmd
					shift 2
				;;
				*) log -E "$strERR Invalid option \`$option' for \`$str_type' set."
					$str_failcmd
			esac
		done
	;;
	list:set)
		local -a arr_opts=("$@")
		while (($#)); do
			option="$1" opt_arg="$2"
			if [[ -z $opt_arg ]]; then
				log -E "$strERR Missing value to option \`$option' for \`$str_type' set." 
				$str_failcmd
			fi
			case "$option" in
				size)
					val_numeric "$opt_arg" || $str_failcmd
					shift 2
				;;
				timeout)
					val_numeric "$opt_arg" || $str_failcmd
					shift 2
				;;
				*) log -E "$strERR Invalid option \`$option' for \`$str_type' set."
					$str_failcmd
			esac
		done
	;;
	ipmap)
		local str_from="" str_to="" str_netmask=""
		while (($#)); do
			option="$1" opt_arg="$2"
			if [[ -z $opt_arg ]]; then
				log -E "$strERR Missing value to option \`$option' for \`$str_type' set." 
				$str_failcmd
			fi
			case "$option" in
				from)
					val_ip4_ip "$opt_arg" || $str_failcmd
					str_from="--$option $opt_arg"
					shift 2
				;;
				to)
					val_ip4_ip "$opt_arg" || $str_failcmd
					str_to="--$option $opt_arg"
					shift 2
				;;
				network)
					val_ip4_cidr_net "$opt_arg" || $str_failcmd
					str_network="--$option $opt_arg"
					shift 2
				;;
				netmask)
					((opt_arg >= 1 && <= 31)) || {
						log -E "$strERR Invalid value \`$opt_arg' with \`$option' for \`$str_type' set. Valid range: 1-31."
						$str_failcmd
					}
					str_netmask="--$option $opt_arg"
					shift 2
				;;
				*) log -E "$strERR Invalid option \`$option' for \`$str_type' set."
					$str_failcmd
			esac
		done
		if [[ $str_network ]]; then 
			if [[ $str_netmask ]]; then arr_opts=($str_network $str_netmask)
			else arr_opts=($str_network)
			fi
		fi
		if [[ $str_from ]]; then
			if [[ $str_to ]]; then
				if [[ $str_netmask ]]; then arr_opts=($str_from $str_to $str_netmask)
				else arr_opts=($str_from $str_to)
				fi
			else
				log -E "$strErr \`$str_type' needs \`from value to value' options."
				$str_failcmd
			fi
		fi
		if [[ $str_netmask ]] && [[ -z $str_from || -z $str_to ]]; then
			log -E "$strErr \`$str_type' option \`netmask' needs \`from value to value' options."
			$str_failcmd
		fi
	;;
	macipmap)
		local str_from="" str_to=""
		while (($#)); do
			option="$1" opt_arg="$2"
			case "$option" in
				from|to|network)
					if [[ -z $opt_arg ]]; then
						log -E "$strERR Missing value to option \`$option' for \`$str_type' set." 
						$str_failcmd
					fi
				;;
			esac
			case "$option" in
				from)
					val_ip4_ip "$opt_arg" || $str_failcmd
					str_from="--$option $opt_arg"
					shift 2
				;;
				to)
					val_ip4_ip "$opt_arg" || $str_failcmd
					str_to="--$option $opt_arg"
					shift 2
				;;
				network)
					val_ip4_cidr_net "$opt_arg" || $str_failcmd
					arr_opts=(--$option $opt_arg)
					shift 2
				;;
				matchunset)
					arr_opts[${#arr_opts[@]}]="--$option"
					shift
				;;
				*) log -E "$strERR Invalid option \`$option' for \`$str_type' set."
					$str_failcmd
			esac
		done
		if [[ $str_from && $str_to ]]; then
			arr_opts=($str_from $str_to)
		elif [[ $str_from && -z $str_to ]]; then
			log -E "$strErr \`$str_type' needs \`from value to value' options."
			$str_failcmd
		fi
	;;
	portmap)
		if (($# == 4)); then
			if [[ $1 = from && $2 = +([[:digit:]]) && $3 = to && $4 = +([[:digit:]]) ]]; then
				for rvar in $2 $4; do
					val_port $rvar || $str_failcmd
				done
				arr_opts=(--from $2 --to $4)
			else
				log -E "$strErr \`$str_type' needs \`from value to value' options."
				$str_failcmd
			fi
		else
			log -E "$strErr \`$str_type' needs \`from value to value' options."
			$str_failcmd
		fi
	;;
	iphash)
		while (($#)); do
			option="$1" opt_arg="$2"
			case "$option" in
				hashsize|probes)
					val_numeric "$opt_arg" || $str_failcmd
					arr_opts[${#arr_opts[@]}]="--$option $opt_arg"
					shift 2
				;;
				resize)
					val_numeric "$opt_arg" || $str_failcmd
					arr_opts[${#arr_opts[@]}]="--$option $opt_arg"
					shift 2
				;;
				netmask)
					((opt_arg >= 1 && <= 31)) || {
						log -E "$strERR Invalid value \`$opt_arg' with \`$option' for \`$str_type' set. Valid range: 1-31."
						$str_failcmd
					}
					arr_opts[${#arr_opts[@]}]="--$option $opt_arg"
					shift 2
				;;
				*) log -E "$strERR Invalid option \`$option' for \`$str_type' set."
					$str_failcmd
			esac
		done
	;;
	nethash)
		while (($#)); do
			option="$1" opt_arg="$2"
			if [[ -z $opt_arg ]]; then
				log -E "$strERR Missing value to option \`$option' for \`$str_type' set." 
				$str_failcmd
			fi
			case "$option" in
				hashsize|probes)
					val_numeric "$opt_arg" || $str_failcmd
					arr_opts[${#arr_opts[@]}]="--$option $opt_arg"
					shift 2
				;;
				resize)
					val_numeric "$opt_arg" || $str_failcmd
					arr_opts[${#arr_opts[@]}]="--$option $opt_arg"
					shift 2
				;;
				*) log -E "$strERR Invalid option \`$option' for \`$str_type' set."
					$str_failcmd
			esac
		done
	;;
	ipporthash|ipportiphash|ipportnethash)
		local str_from="" str_to=""
		while (($#)); do
			option="$1" opt_arg="$2"
			if [[ -z $opt_arg ]]; then
				log -E "$strERR Missing value to option \`$option' for \`$str_type' set." 
				$str_failcmd
			fi
			case "$option" in
				from)
					val_ip4_ip "$opt_arg" || $str_failcmd
					str_from="--$option $opt_arg"
					shift 2
				;;
				to)
					val_ip4_ip "$opt_arg" || $str_failcmd
					str_to="--$option $opt_arg"
					shift 2
				;;
				network)
					val_ip4_cidr_net "$opt_arg" || $str_failcmd
					arr_opts[${#arr_opts[@]}]="--$option $opt_arg"
					shift 2
				;;
				hashsize|probes)
					val_numeric "$opt_arg" || $str_failcmd
					arr_opts[${#arr_opts[@]}]="--$option $opt_arg"
					shift 2
				;;
				resize)
					val_numeric "$opt_arg" || $str_failcmd
					arr_opts[${#arr_opts[@]}]="--$option $opt_arg"
					shift 2
				;;
				*) log -E "$strERR Invalid option \`$option' for \`$str_type' set."
					$str_failcmd
			esac
		done
		if [[ $str_from && $str_to ]]; then
			arr_opts[${#arr_opts[@]}]="$str_from $str_to"
		else
			if [[ $str_from && -z $str_to ]] || [[ -z $str_from && $str_to ]]; then
				log -E "$strErr \`$str_type' needs \`from value to value' options."
				$str_failcmd
			fi
		fi
	;;
	iptree|iptreemap|setlist)
		local i_tmp=0
		if [[ $1 ]]; then
			case "$str_type" in
				iptree) [[ $1 = timeout ]] && i_tmp=1 ;;
				iptreemap) [[ $1 = gc ]] && i_tmp=1 ;;
				setlist) [[ $1 = size ]] && i_tmp=1 ;;
			esac
			if ((i_tmp)); then
				if [[ $2 ]]; then
					if [[ $2 = +([[:digit:]]) ]]; then
						arr_opts=(--$1 $2)
					else
						log -E "$strERR Invalid value \`$2' with option \`$1' for \`$str_type' set."
						$str_failcmd
					fi
				else
					log -E "$strERR Missing value to option \`$1' for \`$str_type' set."
					$str_failcmd
				fi
			else
				log -E "$strERR Invalid option \`$1' for \`$str_type' set."
				$str_failcmd
			fi
		fi
	;;
	*) log -E "Unknown set type \`$str_type'."
		$str_failcmd
esac
log -e "creating set: \`$str_set' of type: \`$str_type'"
IPSET_SETS_ARRAY[${#IPSET_SETS_ARRAY[@]}]="$str_create $str_set $str_type ${arr_opts[@]}"
CREATED_SETS_ARRAY[${#CREATED_SETS_ARRAY[@]}]="$str_set $str_type"
} # -------------------------------------------------------------------------

ipset_add() { # add an entry (cache) to an ipset set
[[ $2 ]] || { reqparm $FUNCNAME 2; return 1; }
local str_set="$1" str_in="$2" str_entry="$2" str_cmd="-A" str_type str_in option opt_arg
local strERR="adding entry to set: \`$*'"
local str_failcmd='eval log -F "$strERR"; raise_cfg_err_count; return 0'
shift 2
local arr_opts=("$@")
if [[ $IPSET_SYNTAX = new ]]; then
	str_cmd=add
fi
val_setname "$str_set" || $str_failcmd
str_type=$(printf "%s\n" "${CREATED_SETS_ARRAY[@]}" | lsearch_echo "$str_set") || {
	log -E "ipset set \`$str_set' has not been created."
	$str_failcmd
}
str_type=${str_type#$str_set }
case $str_type in
	ipmap|bitmap:ip|iphash|hash:ip)
		val_ip4_addr "$str_in" || $str_failcmd
	;;
	nethash|hash:net)
		val_ip4_cidr_net "$str_in" || $str_failcmd
	;;
	macipmap|bitmap:ip,mac)
		val_ip4_ip "${str_in%,*}" || $str_failcmd
		val_mac "${str_in#*,}" || $str_failcmd
	;;
	portmap|bitmap:port)
		case "$str_in" in
			*-*|\[*\]-\[*\]) val_port_range_word "$str_in" || $str_failcmd ;;
			*) val_port "$str_in" || $str_failcmd
		esac
	;;
	hash:net,iface)
		val_ip4_cidr_net "${str_in%,*}" || $str_failcmd
		check_iface "${str_in#*,}" || $str_failcmd
	;;
	iptree)
		case "$str_in" in
			*,*)
				val_ip4_ip "${str_in%,*}" || $str_failcmd
				val_numeric "${str_in#*,}" || $str_failcmd # timeout
			;;
			*) val_ip4_ip "$str_in" || $str_failcmd
		esac
	;;
	iptreemap)
		case "$str_in" in
			*,*)
				val_ip4_addr "${str_in%,*}" || $str_failcmd
				val_numeric "${str_in#*,}" || $str_failcmd # timeout
			;;
			*) val_ip4_addr "$str_in" || $str_failcmd
		esac
	;;
	ipporthash)
		case "$str_in" in
			*,*)
				val_ip4_ip "${str_in%,*}" || $str_failcmd
				val_port "${str_in#*,}" || $str_failcmd
			;;
			*) log -E "Invalid entry \`$str_in' expecting: ip,port."
				$str_failcmd
		esac
	;;
	ipportiphash)
		case "$str_in" in
			*,*,*)
				val_ip4_ip "${str_in%%,*}" || $str_failcmd
				val_ip4_ip "${str_in##*,}" || $str_failcmd
				str_in="${str_in%,*}"
				val_port "${str_in#*,}" || $str_failcmd
			;;
			*) log -E "Invalid entry \`$str_in' expecting: ip,port."
				$str_failcmd
		esac
	;;
	ipportnethash)
		case "$str_in" in
			*,*,*)
				val_ip4_ip "${str_in%%,*}" || $str_failcmd
				val_ip4_cidr_net "${str_in##*,}" || $str_failcmd
				str_in="${str_in%,*}"
				val_port "${str_in#*,}" || $str_failcmd
			;;
			*) log -E "Invalid entry \`$str_in' expecting: ip,port."
				$str_failcmd
		esac
	;;
	hash:ip,port|hash:net,port)
		case "$str_in" in
			*,*)
				case "$str_type" in
					hash:ip,port)
						val_ip4_ip "${str_in%,*}" || $str_failcmd
					;;
					hash:net,port)
						val_ip4_cidr_net "${str_in%,*}" || $str_failcmd
					;;
				esac
				val_ipset_port_spec "${str_in#*,}" || $str_failcmd
			;;
			*) log -E "Invalid entry \`$str_in' expecting: ip,[proto:]port."
				$str_failcmd
		esac
	;;
	hash:ip,port,ip|hash:ip,port,net)
		case "$str_in" in
			*,*,*)
				case "$str_type" in
					hash:ip,port,ip)
						val_ip4_ip "${str_in%%,*}" || $str_failcmd
					;;
					hash:net,port,net)
						val_ip4_cidr_net "${str_in##*,}" || $str_failcmd
					;;
				esac
				str_in="${str_in%,*}"; str_in="${str_in#*,}"
				val_ipset_port_spec "$str_in" || $str_failcmd
			;;
			*) log -E "Invalid entry \`$str_in' expecting: ip,[proto:]port."
				$str_failcmd
		esac
	;;
	setlist|list:set)
		case "$str_in" in
			*,@(before|after),*)
				if [[ $IPSET_SYNTAX = old ]]; then
					str_in="${str_in/,@(before|after),/ }"
				else
					log -E "Expecting \`before|after' as seperate option."
					$str_failcmd
				fi
			;;
		esac
		for str_tmp in $str_in; do
			val_setname "$str_tmp" || $str_failcmd
			lsearch "$str_tmp" $(show_array_column CREATED_SETS_ARRAY) || {
				log -E "ipset set \`$str_tmp' has not been created."
				$str_failcmd
			}
		done
	;;
	"")
		log -U $FUNCNAME
		log -f "$strERR"
		raise_gen_err_count
		return 1
	;;
esac
while (($#)); do # remaining options
	option="$1" opt_arg="$2"
	shift
	if [[ $IPSET_SYNTAX = new ]]; then
		case "$option" in
			timeout)
				val_numeric "$opt_arg" || $str_failcmd
				shift
			;;
			nomatch)
				[[ $str_type = @(hash:net|hash:net,port|hash:ip,port,net|hash:net,iface) ]] || {
					log -E "Option \`$option' is not valid with set of type \`$str_type'."
					$str_failcmd
				}
			;;
			before|after)
				[[ $str_type = list:set ]] || {
					log -E "Option \`$option' is not valid with set of type \`$str_type'."
					$str_failcmd
				}
				val_setname "$opt_arg" || $str_failcmd
				lsearch "$opt_arg" $(show_array_column CREATED_SETS_ARRAY) || {
					log -E "ipset set \`$opt_arg' has not been created."
					$str_failcmd
				}
				shift
			;;
			-\!|-exist|-q|-quiet) : ;;
			*) log -E "Option \`$option' is unknown."
				$str_failcmd
		esac
	else
		case "$option" in
			-q|--quiet) : ;;
			quiet) 
				for opt_arg in ${!arr_opts[@]}; do
					if [[ ${arr_opts[opt_arg]} = quiet ]]; then
						arr_opts[opt_arg]=--quiet
						break
					fi
				done
			;;
			*) log -E "Option \`$option' is unknown."
				$str_failcmd
		esac
	fi
done
log -e "adding to set: $str_set $str_entry ${arr_opts[@]}"
IPSET_ENTRIES_ARRAY[${#IPSET_ENTRIES_ARRAY[@]}]="$str_cmd $str_set $str_entry ${arr_opts[@]}"
} # -------------------------------------------------------------------------

ipset_destroy() {
local str_set="$1" str_cmd="-X"
if [[ $IPSET_SYNTAX = new ]]; then
	str_cmd=destroy
fi
if [[ $str_set ]]; then
	val_setname "$str_set" || return
	run_ipset $str_cmd "$str_set"
else
	run_ipset $str_cmd
fi
} # -------------------------------------------------------------------------

ipset_list() {
local str_set="$1" str_cmd="-L"
if [[ $IPSET_SYNTAX = new ]]; then
	str_cmd=list
fi
if [[ $str_set ]]; then
	val_setname "$str_set" || return
	run_ipset $str_cmd "$str_set"
else
	run_ipset $str_cmd
fi
} # -------------------------------------------------------------------------

ipset_flush() {
local str_set="$1" str_cmd="-F"
if [[ $IPSET_SYNTAX = new ]]; then
	str_cmd=flush
fi
if [[ $str_set ]]; then
	val_setname "$str_set" || return
	run_ipset $str_cmd "$str_set"
else
	run_ipset $str_cmd
fi
} # -------------------------------------------------------------------------

ipset_save() {
local str_set="$1" str_cmd="-S"
if [[ $IPSET_SYNTAX = new ]]; then
	str_cmd=save
fi
if [[ $str_set ]]; then
	val_setname "$str_set" || return
	run_ipset $str_cmd "$str_set"
else
	run_ipset $str_cmd
fi
} # -------------------------------------------------------------------------

ipset_restore() {
local str_cmd="-R"
if [[ $IPSET_SYNTAX = new ]]; then
	str_cmd=restore
fi
run_ipset $str_cmd
} # -------------------------------------------------------------------------

ipset_test() {
[[ $2 ]] || { reqparm $FUNCNAME 2; return 1; }
local str_set="$1" str_entry="$2" str_cmd="-T"
if [[ $IPSET_SYNTAX = new ]]; then
	str_cmd=test
fi
val_setname "$str_set" || return
run_ipset $str_cmd "$str_set" "$str_entry"
} # -------------------------------------------------------------------------

test_ipset() {
((NO_IPT_COMPAT_CHECK == 0)) || return 0
[[ ${IPSET} && -x ${IPSET} ]] || return 0
local -i idx
local str_typename str_create="-N" str_destroy="-X" str_dn="dn"
[[ $DEBUG_INFO ]] && str_dn=""
if dn run_ipset list; then
	IPSET_SYNTAX=new
	str_create="create" str_destroy="destroy"
fi
case "$1" in
	create)
		if ((USE_IPSET)); then
			log -I "Checking for ipset set types"
			for idx in ${!IPARRAY_IPSET_SETTYPE_LIST[@]}; do
				set -- ${IPARRAY_IPSET_SETTYPE_LIST[idx]}
				str_typename=$1
				shift
				log -e "${PF}checking $str_typename set"
				if $str_dn run_ipset $str_create ${ME}_TEST_SET $str_typename $@; then
					$str_dn run_ipset $str_destroy ${ME}_TEST_SET
				else
					UNSUPPORTED_SETLIST+=" $str_typename"
					log -f "creating set: \`${ME}_TEST_SET $str_typename $@'"
				fi
			done
			readonly UNSUPPORTED_SETLIST
		fi
		log -w "creating ipset test set"
		$str_dn run_ipset $str_create ${ME}_TEST_SET ipmap --network 192.168.0.0/24 || {
			log -f "creating test set: ${ME}_TEST_SET ipmap --network 192.168.0.0/24"
		}
	;;
	delete)
		log -w "deleting ipset test set"
		$str_dn run_ipset $str_destroy ${ME}_TEST_SET || {
			log -f "deleting test set: \`${ME}_TEST_SET'"
		}
	;;
	*) log -o "$1" $FUNCNAME; return 1
esac
} # -------------------------------------------------------------------------

ipset_flush_destroy() {
if [[ $IPSET_SYNTAX = new ]]; then
	IPSET_CMD_ARRAY[${#IPSET_CMD_ARRAY[@]}]="flush"
	IPSET_CMD_ARRAY[${#IPSET_CMD_ARRAY[@]}]="destroy"
else
	IPSET_CMD_ARRAY[${#IPSET_CMD_ARRAY[@]}]="-F"
	IPSET_CMD_ARRAY[${#IPSET_CMD_ARRAY[@]}]="-X"
fi
} # -------------------------------------------------------------------------

ipset_merge_arrays() { # join entries to their according sets
local str_set
local -i idx eidx
ipset_flush_destroy
for idx in ${!IPSET_SETS_ARRAY[@]}; do
	IPSET_CMD_ARRAY[${#IPSET_CMD_ARRAY[@]}]=${IPSET_SETS_ARRAY[idx]}
	set -- ${IPSET_SETS_ARRAY[idx]}
	str_set=$2
	for eidx in ${!IPSET_ENTRIES_ARRAY[@]}; do
		set -- ${IPSET_ENTRIES_ARRAY[eidx]}
		if [[ $2 = $str_set ]]; then
			IPSET_CMD_ARRAY[${#IPSET_CMD_ARRAY[@]}]=$@
			unset IPSET_ENTRIES_ARRAY[eidx]
		fi
	done
done
} # -------------------------------------------------------------------------

# ------------------------------------------------------------------------- #
# IPTABLES VALIDATION FUNCTIONS
# ------------------------------------------------------------------------- #

val_ip4_addr() { # validate IPv4 addresses
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local range_ip str_ip_addr="$1"
IPSTRING=""
case "${str_ip_addr}" in
	# IP string is global shortcut
	(0/0 | 0.0.0.0/0)
		IPSTRING="IPNET"
		return 0
	;;
	# IP string is single IP
	(+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]]))
		val_oct_range ${str_ip_addr//./ } || {
			log -E "IP address \`${str_ip_addr}' is not valid."
			return 1
		}
		IPSTRING="IPADDR"
	;;
	# IP string is IP/CIDR Mask
	(+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]])/+([[:digit:]]))
		local ip_addr="${str_ip_addr%/*}"
		local mask="${str_ip_addr#*/}"
		val_oct_range ${ip_addr//./ } || {
			log -E "IP address \`${ip_addr}' is not valid."
			return 1
		}
		val_ipv4_cidr_mask "${mask}" || {
			log -E "Netmask \`${mask}' of IP address \`${ip_addr}' is not valid."
			return 1
		}
		IPSTRING="IPNET"
	;;
	# IP string is IP/Netmask
	(+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]])/+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]]))
		local ip_addr="${str_ip_addr%/*}"
		local mask="${str_ip_addr#*/}"
		val_oct_range ${ip_addr//./ } || {
			log -E "IP address \`${ip_addr}' is not valid."
			return 1
		}
		val_ipv4_netmask "${mask}" || {
			log -E "Netmask \`${mask}' of IP address \`${ip_addr}' is not valid."
			return 1
		}
		IPSTRING="IPNETMASK"
	;;
	# IP string is IP-range
	(+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]])-+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]]))
		for range_ip in ${str_ip_addr/-/ }; do
			val_oct_range ${range_ip//./ } || {
				log -E "IP range \`${range_ip}' is not valid."
				return 1
			}
		done
	    if (($(decodeaddr ${str_ip_addr%-*}) > $(decodeaddr ${str_ip_addr#*-}))); then
			log -E "IP range \`${range_ip}' is not valid."
			return 1
	    fi
		IPSTRING="IPRANGE"
	;;
	(*) log -E "IPv4 address specification \`${str_ip_addr}' is not valid."
		return 1
esac
} # -------------------------------------------------------------------------

classify_ip4_addr() { # classify IPv4 addresses
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
case "$1" in
	# IP string is global shortcut
	(0/0 | 0.0.0.0/0) printf "IPNET\n" ;;
	# IP string is single IP
	(+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]])) printf "IPADDR\n" ;;
	# IP string is IP/Mask
	(+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]])/+([[:digit:]])) printf "IPNET\n" ;;
	(+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]])/+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]])) printf "IPNET\n" ;;
	# IP string is IP-range
	(+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]])-+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]]))
		printf "IPRANGE\n"
	;;
	(*) log -E "Unknown error while processing \`$1'."; return 1 ;;
esac
} # -------------------------------------------------------------------------

val_ipv4_addr_no_range() {
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
val_ip4_addr "$1" || return 1
[[ ${IPSTRING} != IPRANGE ]] || {
	log -E "IP-range address not valid in context."
	return 1
}
} # -------------------------------------------------------------------------

val_state() { # validate state specifications
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local str
#check_str_unique "${1//,/ }" || return 1
#for str in $(string_toupper "$(IFS=, split_val ${1})"); do
for str in $(string_toupper "${1//,/ }"); do
	case "${str}" in
		(NEW|ESTABLISHED|RELATED|INVALID|UNTRACKED)
			continue
		;;
		*) log -E "Invalid state entry \`$1'."
			return 1
	esac
done
} # -------------------------------------------------------------------------

val_rej_type() { # validate reject target types
[[ $2 ]] || { reqparm $FUNCNAME 2; return 1; }
case "$(string_tolower "$1")" in
	tcp-reset)
		if [[ $2 != @(tcp|6) ]]; then
			log -E "tcp-reset is only valid with tcp."
			return 1
		fi
	;;
	icmp-net-unreachable|icmp-host-unreachable|icmp-port-unreachable|icmp-proto-unreachable|\
icmp-net-prohibited|icmp-host-prohibited|icmp-admin-prohibited)
		return 0
	;;
	*) log -E "Invalid reject target type: \`$1'."
		return 1
esac
} # -------------------------------------------------------------------------

validate_reject_type() { # validate reject target types
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
case "$(string_tolower "$1")" in
	tcp-reset|icmp-net-unreachable|icmp-host-unreachable|icmp-port-unreachable|icmp-proto-unreachable|\
icmp-net-prohibited|icmp-host-prohibited|icmp-admin-prohibited)
		return 0
	;;
	*) log -E "Invalid reject type: \`$1'."
		return 1
esac
} # -------------------------------------------------------------------------

val_limit() { # validate iptables limit match values
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local err_msg="Illegal limit specification \`${@}'."
set -- ${@//\// }
local limit_num=$1 limit_val=$2
val_numeric_quiet ${limit_num} || { log -E "${err_msg}"; return 1; }
if [[ ${limit_val} ]]; then
	case "$(string_tolower "${limit_val}")" in
		s|m|h|d|second|minute|hour|day)
			return 0
		;;
		*) log -E "${err_msg}"
			return 1
	esac
fi
} # -------------------------------------------------------------------------

val_icmp_type() { # validate an icmp type[/code]
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local icmptype="$1"
local itc
case "${icmptype}" in
	+([[:digit:]]))
		if ! val_8bit "${icmptype}"; then
			log -E "ICMP type \`${icmptype}' not legal."
			return 1
		fi
	;;
	+([[:digit:]])@(/)+([[:digit:]]))
		for itc in ${@//\// }; do
			if ! val_8bit "${itc}"; then
				log -E "ICMP type or code \`${itc}' not legal."
				return 1
			fi
		done
	;;
	*) if ! lsearch "$(string_tolower "${icmptype}")" ${VALID_ICMP_TYPES}; then
			log -E "ICMP type \`${icmptype}' not legal."
			return 1
		fi
esac
return 0
} # -------------------------------------------------------------------------

val_proto() { # validate protocol specifications
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local -i p_idx
local val_prot="$(string_tolower "$1")"
case "$val_prot" in
	all|tcp|udp|icmp)
		return 0
	;;
	+([[:digit:]]))
		val_8bit "$val_prot" && return
	;;
	*+([[:alpha:]])*)
		for p_idx in ${!PROTOCOLS_ARRAY[@]}; do
			[[ ${PROTOCOLS_ARRAY[p_idx]} = $val_prot ]] && return
		done
	;;
esac
log -E "Invalid protocol specification \`$val_prot'."
return 1
} # -------------------------------------------------------------------------

val_loglevel() { # validate syslog loglevel values
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
case "$(string_tolower "$1")" in
	[[:digit:]])
		if (($1 < 0 || ${1} > 7)); then
			log -E "Invalid loglevel value \`$1'. Must be between '0-7'."
			return 1
		fi
	;;
	alert|crit|debug|emerg|err|info|notice|warning)
		return 0
	;;
	error|panic|warn)
		log -W "Loglevel \`$1' is deprecated."
		return 0
	;;
	*) log -E "Invalid loglevel value \`$1'."
		return 1
esac
} # -------------------------------------------------------------------------

val_tos() { # validate TOS specifications allowed within iptables
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
case "$(string_tolower "$1")" in
	minimize-delay|maximize-throughput|maximize-reliability|minimize-cost|normal-service)
		return 0
	;;
	0|2|4|8|16|0x00|0x02|0x04|0x08|0x10)
		return 0
	;;
	*) log -E "Invalid TOS value \`$1'. See \`iptables -m tos -h' for help."
		return 1
esac
} # -------------------------------------------------------------------------

validate_target() { # target name validation
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
case "$1" in
	ACCEPT|DROP|RETURN) return 0 ;; # catch some known
	CHECKSUM|ECN|LOG|CLASSIFY|MARK|CONNMARK|CONNSECMARK|SECMARK|DSCP|MASQUERADE|NETMAP|\
	REDIRECT|REJECT|SET|DNAT|SNAT|RAWDNAT|RAWSNAT|QUEUE|NFQUEUE|TCPOPTSTRIP|TOS|TTL|TCPMSS|\
	ULOG|NFLOG|TPROXY) # these are registered
		if ((${1}_TGT_EXIST)); then return 0
		else
			log -t "$1"
			return 1
		fi
	;;
	*) val_userdef_chain_target "$1" || return 1
esac
} # -------------------------------------------------------------------------

val_table() { # validate iptables table names
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
case "$1" in
	filter|nat)
		(($(subst_var "ENABLE_$(string_toupper "$1")") == 1)) || {
			log -E "\`$1' table is disabled by configuration."
			return 1
		}
	 ;;
	mangle)
		if ((ENABLE_MANGLE == 0 && ENABLE_TC_SHAPING == 0)); then
			log -E "\`$1' table is disabled by configuration."
			return 1
		fi
	;;
	raw)
		if ((ENABLE_RAW == 0)); then
			log -E "\`$1' table is disabled by configuration."
			return 1
		fi
		if ((RAW_TABLE_PRESENT == 0)); then
			log -E "\`$1' table is not present on the local system."
			return 1
		fi
	;;
	rawpost)
		if ((ENABLE_RAWPOST == 0)); then
			log -E "\`$1' table is disabled by configuration."
			return 1
		fi
		if ((RAWPOST_TABLE_PRESENT == 0)); then
			log -E "\`$1' table is not present on the local system."
			return 1
		fi
	;;
	security)
		if ((ENABLE_SECURITY == 0)); then
			log -E "\`$1' table is disabled by configuration."
			return 1
		fi
		if ((SECURITY_TABLE_PRESENT == 0)); then
			log -E "\`$1' table is not present on the local system."
			return 1
		fi
	;;
	*) log -E "Illegal iptables table name: \`$1'."; return 1
esac
} # -------------------------------------------------------------------------

val_builtin_chain() { # validate iptables builtin chain names
[[ $2 ]] || { reqparm $FUNCNAME 2; return 1; }
case "$1" in
	filter|security) [[ $2 != @(INPUT|OUTPUT|FORWARD) ]] || return 0 ;;
	nat) [[ $2 != @(PREROUTING|OUTPUT|POSTROUTING) ]] || return 0 ;;
	mangle)
		# mangle table chains prior to kernel 2.4.18
		if ((ALL_MANGLE_CHAINS_PRESENT == 0)); then
			[[ $2 != @(OUTPUT|PREROUTING) ]] || return 0
		else
			# mangle table chains in kernel version greater than 2.4.17
			[[ $2 != @(INPUT|OUTPUT|FORWARD|PREROUTING|POSTROUTING) ]] || return 0
		fi
	;;
	raw) [[ $2 != @(OUTPUT|PREROUTING) ]] || return 0 ;;
	rawpost) [[ $2 != POSTROUTING ]] || return 0 ;;
esac
log -E "Illegal iptables chain name: \`$2'."
return 1
} # -------------------------------------------------------------------------

val_userdef_chain_target() { # validate a user defined iptables chain or target name
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local str_tgt="$1"
[[ ${str_tgt} = goto:* ]] && str_tgt="${str_tgt#goto:}"
((${#str_tgt} > 30)) && {
	log -E "Chain or target names must not exceed a maximum of 30 characters."
	return 1
}
case "${str_tgt}" in
	+([[:graph:]])*)
		[[ ${str_tgt:0:1} = @('!'|'-') ]] && {
			log -E "Chain or target names must not begin with \`${str_tgt:0:1}'."
			return 1
		}
		[[ ${str_tgt} = +(*[,]*) ]] && {
			log -E "${ME} does not allow commas in chain or target names."
			return 1
		}
		return 0
	;;
	*+([[:space:]])*)
		log -E "Iptables does support space class characters in chain or target names, but ${ME} forbids it."
		return 1
	;;
#	*) log -E "Invalid iptables chain or target name \`${str_tgt}'."
#		return 1
esac
return 0
} # -------------------------------------------------------------------------

val_policy_target() { # validate iptables policy targets
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
case "$1" in
	ACCEPT|DROP) return 0 ;;
	*) log -E "Illegal iptables policy target: \`$1'."
		return 1
esac
} # -------------------------------------------------------------------------

val_limit_burst() {
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
val_numeric_quiet "$1" || {
	log -E "Invalid burst value \`$1'."
	return 1
}
} # -------------------------------------------------------------------------

val_icmp_types() { # validate a multiple icmp types string
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
#local i_type str_i_types="$(IFS=, split_val ${@/ })"
local i_type str_i_types="${@//,/ }"
check_multi_negation ${str_i_types} || return 1
for i_type in ${str_i_types/!/}; do
	val_icmp_type "${i_type}" || return 1
done
} # -------------------------------------------------------------------------

validate_nat_ip() { # validate the ip address of a nat ip definition
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local str_ip str_natip="$1"
string_negated "${str_natip}" && {
	log -E "Negating NAT source or destination IP is not allowed."
	return 1
}
for str_ip in ${str_natip//-/ }; do val_ip4_addr ${str_ip} || return 1; done
} # -------------------------------------------------------------------------

val_nat_port() { # validate nat port specifications
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local nport
for nport in ${1//-/ }; do val_port ${nport} || return 1; done
} # -------------------------------------------------------------------------

val_port() { # validate port specifications
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
[[ $1 = ':' ]] && return 0
local pval val_port="$1"
case "$val_port" in
	@(+([[:digit:]]):)) val_port="${1%:}" ;;
	@(+([[:digit:]]):+([[:digit:]]))) val_port="${1/:/ }" ;;
esac
for pval in $val_port; do
	case "$pval" in
		+([[:digit:]]))
			if ! val_16bit "$pval"; then
				log -E "Invalid port specification \`$pval'."
				return 1
			fi
		;;
		*+([[:alpha:]])*)
			if ! lsearch "$val_port" "${SERVICES_ARRAY[@]}"; then
				log -E "Invalid port specification \`$pval'."
				return 1
			fi
		;;
		*) log -E "Invalid port specification \`$pval'."
			return 1
	esac
done
} # -------------------------------------------------------------------------

val_multi_ports() { # validate a multiport port definition string
#local m_port str_m_ports="$(IFS=, split_val ${@})"
local m_port str_m_ports="${@//,/ }"
if ((multiport_MOD_EXIST)); then
	check_multi_negation_first_allowed $str_m_ports || return 1
else
	check_multi_negation $str_m_ports || return 1
fi
for m_port in ${str_m_ports#!}; do
	val_port "$m_port" || return 1
done
} # -------------------------------------------------------------------------

val_port_range() {
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local str_prange="$1"
local str_failcmd='eval log -E "Invalid port-range specification: $str_prange"; return 1'
local IFS='-'
set -- $1
local str_rb="$1" str_re="$2"
unset IFS
(($# == 2)) || $str_failcmd
val_numeric "$str_rb" && val_numeric "$str_re" || $str_failcmd
val_16bit "$str_rb" && val_16bit "$str_re" || $str_failcmd
((str_rb >= str_re)) && $str_failcmd
} # -------------------------------------------------------------------------

val_port_range_word() {
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local str_prange="$1"
local str_failcmd='eval log -E "Invalid port-range specification: $str_prange"; return 1'
local IFS='-'
set -- $1
local str_rb="$1" str_re="$2"
unset IFS
case "$str_prange" in
	+([[:digit:]])-+([[:digit:]]))
		(($# == 2)) || $str_failcmd
		val_16bit "$str_rb" && val_16bit "$str_re" || $str_failcmd
		if ((str_rb >= str_re)); then $str_failcmd; fi
	;;
	\[*+([[:alpha:]])*\]-\[*+([[:alpha:]])*\])
		str_re="${str_prange##*\[}"; str_re="${str_re%\]}"
		str_rb="${str_prange%%\]*}"; str_rb="${str_rb#\[}"
		lsearch "$str_rb" "${SERVICES_ARRAY[@]}" && lsearch "$str_re" "${SERVICES_ARRAY[@]}" || $str_failcmd
	;;
	\[*+([[:alpha:]])*\]-+([[:word:]]))
		str_re="${str_prange##*-}"
		str_rb="${str_prange%%\]*}"; str_rb="${str_rb#\[}"
		lsearch "$str_rb" "${SERVICES_ARRAY[@]}" && lsearch "$str_re" "${SERVICES_ARRAY[@]}" || $str_failcmd
	;;
	+([[:word:]])-\[*+([[:alpha:]])*\])
		str_re="${str_prange##*\[}"; str_re="${str_re%\]}"
		str_rb="${str_prange%%-*}"
		lsearch "$str_rb" "${SERVICES_ARRAY[@]}" && lsearch "$str_re" "${SERVICES_ARRAY[@]}" || $str_failcmd
	;;
	+([[:word:]])-+([[:word:]]))
		(($# == 2)) || $str_failcmd
		lsearch "$str_rb" "${SERVICES_ARRAY[@]}" && lsearch "$str_re" "${SERVICES_ARRAY[@]}" || $str_failcmd
	;;
	*) $str_failcmd
esac
} # -------------------------------------------------------------------------

val_ttl() { # validate TTL manipulation values
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
#if (($1 < 0 || ${1} > 255)); then
if ! val_8bit "$1"; then
	log -E "TTL value must be between 0 and 255."
	return 1
fi
} # -------------------------------------------------------------------------

val_tcp_flags() {
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
set -- ${1/:/ }
#local str_mask="$(IFS=, split_val $1)" str_comp="$(IFS=, split_val $2)" str_flag
local str_mask="${1//,/ }" str_comp="${2//,/ }" str_flag
check_str_unique "${str_mask}" || return 1
check_str_unique "${str_comp}" || return 1
for str_flag in ${str_mask} ${str_comp}; do
	[[ ${str_flag} = @(SYN|ACK|FIN|RST|URG|PSH|ALL|NONE) ]] || return 1
done
} # -------------------------------------------------------------------------

val_dscp() {
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
case "$1" in
	+([[:digit:]])|0x+([[:xdigit:]]))
		val_6bit "$1" || {
			log -E "DSCP value \`$1' is out of bounds."
			return 1
		}
	;;
	BE|EF|AF[1-4][1-3]|CS[1-4]) : ;;
	*) log -i "$1" "DSCP descriptor"
		return 1
esac
} # -------------------------------------------------------------------------

val_nf_mark() { # validate netfilter mark and mark-mask values
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
val_32bit "$1" || {
	log -E "Mark value or mask \`$1' is out of bounds. Should be 32bit: 0-0xFFFFFFFF (4294967295)."
	return 1
}
} # -------------------------------------------------------------------------

val_sctp_chunk_types() { # validate sctp protocol chunk types
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
set -- $(split_val , ' ' "$1")
while (($#)); do
	case "$1" in
		DATA|ABORT|SHUT_DOWN_COMPLETE|INIT|INIT_ACK|SACK|HEARTBEAT|HEARTBEAT_ACK|SHUTDOWN|SHUTDOWN_ACK|ERROR|COOKIE_ECHO|COOKIE_ACK|ECN_ECNE|CN_CWR|ASCONF|ASCONF_ACK|FORWARD_TSN) : ;;
		DATA:+([IUBEiube])|@(SHUT_DOWN_COMPLETE|ABORT):[Tt]) : ;;
		*) log -E "Invalid sctp chunk type: \`$1'."
			return 1
	esac
	shift
done
return 0
} # -------------------------------------------------------------------------

val_spi() {
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local str_spi
set -- ${1/:/ }
for str_spi in "$@"; do
	val_numeric "$str_spi" || return 1
	val_32bit "$str_spi" || {
		log -E "SPI value \`$str_spi' is out of range."
		return 1
	}
done
if [[ $2 ]]; then
	val_range "$1" "$2" || return 1
fi
} # -------------------------------------------------------------------------

val_set_flags() {
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
oIFS="$IFS"
IFS=,
set -- $1
IFS="$oIFS"
if (($# > 6)); then
	log -E "A maximum of 6 set flags can be specified."
	return 1
fi
} # -------------------------------------------------------------------------

val_ipt_tgt() { # validate existence of iptables targets
[[ $4 ]] || { reqparm $FUNCNAME 4; return 1; }
declare -i mandatory=$1
local ttarget="$2" ttable="$3" str_dn="dn "
shift 3
[[ $DEBUG_INFO ]] && str_dn=""
log -e "${PF}checking for $ttarget target"
if $str_dn run_ipt -t "$ttable" -A $BIC_TEST_CHAIN "$@"; then
	set_var ${ttarget}_TGT_EXIST 1 # target exists, set according variable to 1
#	run_ipt -t "$ttable" -D $BIC_TEST_CHAIN "$@"
	run_ipt -t "$ttable" -F $BIC_TEST_CHAIN
else
	set_var ${ttarget}_TGT_EXIST 0 # target does not exist, set according variable to 0
	if ((mandatory == 1)); then
		log -E "iptables target \`$ttarget' does not exist."
		return $ER_FAIL
	else
		log -W "iptables target \`$ttarget' does not exist."
	fi
fi
readonly ${ttarget}_TGT_EXIST
} # -------------------------------------------------------------------------

val_ipt_mod() { # validate existence of iptables modules
[[ $4 ]] || { reqparm $FUNCNAME 4; return 1; }
declare -i mandatory=$1
local tmod=$2 ttable=$3 str_dn="dn"
shift 3
[[ $DEBUG_INFO ]] && str_dn=""
log -e "${PF}checking for $tmod extension"
if $str_dn run_ipt -t "$ttable" -A $BIC_TEST_CHAIN "$@"; then
	set_var "${tmod}_MOD_EXIST" 1 # module exists, set according variable to 1
#	run_ipt -t "$ttable" -D $BIC_TEST_CHAIN "$@"
	run_ipt -t "$ttable" -F $BIC_TEST_CHAIN
else
	set_var "${tmod}_MOD_EXIST" 0 # module does not exist, set according variable to 0
	if ((mandatory == 1)); then
		log -E "iptables module \`$tmod' does not exist."
		return $ER_FAIL
	else
		log -W "iptables module \`$tmod' does not exist."
	fi
fi
readonly ${tmod}_MOD_EXIST
} # -------------------------------------------------------------------------

check_ipt_targets() { # check for iptables targets, which are used by IP-Array
((${#IPARRAY_TARGETS[@]})) || { log -u 'IPARRAY_TARGETS'; return 1; }
local -i t_idx
if ((NO_IPT_COMPAT_CHECK)); then
	log -w "Not performing checks for iptables targets"
	for t_idx in ${!IPARRAY_TARGETS[@]}; do
		set -- ${IPARRAY_TARGETS[t_idx]}
		set_var "${2}_TGT_EXIST" 1
		readonly "${2}_TGT_EXIST"
	done
else
	log -I "Checking for iptables targets"
	for t_idx in ${!IPARRAY_TARGETS[@]}; do
		val_ipt_tgt ${IPARRAY_TARGETS[t_idx]} || return
	done
fi
} # -------------------------------------------------------------------------

check_ipt_modules() { # check for iptables match extension modules, which are used by IP-Array
((${#IPARRAY_MODULES[@]})) || { log -u 'IPARRAY_MODULES'; return 1; }
local -i m_idx
if ((NO_IPT_COMPAT_CHECK)); then
	log -w "Not performing checks for iptables match extensions"
	for m_idx in ${!IPARRAY_MODULES[@]}; do
		set -- ${IPARRAY_MODULES[m_idx]}
		set_var "${2}_MOD_EXIST" 1
		readonly "${2}_MOD_EXIST"
	done
else
	log -I "Checking for iptables match extension"
	for m_idx in ${!IPARRAY_MODULES[@]}; do
		val_ipt_mod ${IPARRAY_MODULES[m_idx]} || return
	done
fi
} # -------------------------------------------------------------------------

# ------------------------------------------------------------------------- #
# ACTION FUNCTIONS
# ------------------------------------------------------------------------- #
add_rule() { # add iptables commands to the command array
[[ $2 ]] || { reqparm $FUNCNAME 2; return 1; }
local str_tbl="$1" str_chn="$2"
shift 2
local str_arr="IPT_$(string_toupper "$str_tbl")_CMD_ARRAY"
if [[ $str_tbl = @(filter|nat|mangle|raw|rawpost|security) ]]; then
	eval ${str_arr}[$(arr_members_sum $str_arr)]='"-t $str_tbl -A $str_chn ${@//$'\t'/}"'
#eval ${str_arr}[$(arr_members_sum $str_arr)]='"-t $str_tbl -A $(escape_varname str_chn) $(printf "%q " "${@}";printf "\n")"'
else
	log -E "Illegal iptables table name: \`$str_tbl'."
	return $ER_CONF
fi
} # -------------------------------------------------------------------------

insert_ipt_rule() {
[[ $2 ]] || { reqparm $FUNCNAME 2; return 1; }
local str_tbl="$1" str_chn="$2"
shift 2
local str_arr="IPT_$(string_toupper "${str_tbl}")_CMD_ARRAY"
if [[ ${str_tbl} = @(filter|nat|mangle|raw|rawpost|security) ]]; then
	eval ${str_arr}[$(arr_members_sum ${str_arr})]='"-t ${str_tbl} -I ${str_chn} ${@//$'\t'/}"'
else
	log -E "Illegal iptables table name: \`${str_tbl}'."
	return $ER_CONF
fi
} # -------------------------------------------------------------------------

create_chain() { # create an iptables chain
[[ $2 ]] || { reqparm $FUNCNAME 2; return 1; }
local str_tbl="$1" str_chain="$2" str_silent="$3"
local -i c_idx
val_table "${str_tbl}" || {
	raise_cfg_err_count
	return 0
}
val_userdef_chain_target "${str_chain}" || {
	raise_cfg_err_count
	return 0
}
for c_idx in ${!CREATED_CHAINS_ARRAY[@]}; do
	set -- ${CREATED_CHAINS_ARRAY[c_idx]}
	if [[ $1 = ${str_tbl} && $2 = ${str_chain} ]]; then
		[[ ${str_silent} = --silent ]] || {
			log -W "\`${str_chain}' in ${str_tbl} table has already been created"
		}
		return 0
	fi
done
log -e "creating chain: ${str_chain} table=${str_tbl}"
IPT_CCHAIN_ARRAY[${#IPT_CCHAIN_ARRAY[@]}]="-t ${str_tbl} -N ${str_chain}"
CREATED_CHAINS_ARRAY[${#CREATED_CHAINS_ARRAY[@]}]="${str_tbl} ${str_chain}"
} # -------------------------------------------------------------------------

#delete_chain() { # delete an iptables chain
#[[ $2 ]] || { reqparm $FUNCNAME 2; return 1; }
#local str_tbl="$1" str_chain="$2"
#local -i c_idx
#val_table "${str_tbl}" || {
#	raise_cfg_err_count
#	return 0
#}
#val_userdef_chain_target "${str_chain}" || {
#	raise_cfg_err_count
#	return 0
#}
#for c_idx in ${!CREATED_CHAINS_ARRAY[@]}; do
#	set -- ${CREATED_CHAINS_ARRAY[c_idx]}
#	[[ $1 = ${str_tbl} && $2 = ${str_chain} ]] && {
#		IPT_CMD_ARRAY[${#IPT_CMD_ARRAY[@]}]="\"${IPT}\" -t ${str_tbl} -F ${str_chain}"
#		IPT_CMD_ARRAY[${#IPT_CMD_ARRAY[@]}]="\"${IPT}\" -t ${str_tbl} -X ${str_chain}"
#		return 0
#	}
#done
#log -W "\`${str_chain}' in ${str_tbl} table has not been created before"
#return 0
#}
# -------------------------------------------------------------------------

emerge_ips_restore() { # restore ipset data in error case in error case
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
((USE_IPSET)) || return 0
local str_file="${SAVE_DIR}/$1"
if [[ -r $str_file ]]; then
	run_ipset -F -q
	run_ipset -X -q
	if run_ipset -R <"$str_file"; then
		ERRORS_MSG_ARRAY[${#ERRORS_MSG_ARRAY[@]}]="log -N 'ipset rules successfully restored from: $str_file'"
	else
		ERRORS_MSG_ARRAY[${#ERRORS_MSG_ARRAY[@]}]="log -E 'Failed restoring ipset rules from: $str_file.'"
		return $ER_FAIL
	fi
else
	ERRORS_MSG_ARRAY[${#ERRORS_MSG_ARRAY[@]}]="log -x '$str_file'"
	return $ER_NOEX
fi
} # -------------------------------------------------------------------------

emerge_ipt_restore() { # restore the firewall with iptables-restore in error case
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
if ((IPTSAVE_FAILS)); then
	ERRORS_MSG_ARRAY[${#ERRORS_MSG_ARRAY[@]}]="log -E 'IPTSAVE_FAILS is set to $IPTSAVE_FAILS.'"
	return $ER_FAIL
fi
local str_c="" str_file="${SAVE_DIR}/$1"
if ((USE_COUNTERS)); then
	str_c="--counters "
fi
if [[ -r $str_file ]]; then
	if "$IPT_RESTORE" $str_c <"$str_file"; then
		ERRORS_MSG_ARRAY[${#ERRORS_MSG_ARRAY[@]}]="log -N 'iptables rules successfully restored from: $str_file'"
	else
		ERRORS_MSG_ARRAY[${#ERRORS_MSG_ARRAY[@]}]="log -E 'Failed restoring iptables rules from: $str_file.'"
		return $ER_FAIL
	fi
else
	ERRORS_MSG_ARRAY[${#ERRORS_MSG_ARRAY[@]}]="log -x '$str_file'"
	return $ER_NOEX
fi
} # -------------------------------------------------------------------------

ips_restore() { # restore ipset data
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
((USE_IPSET)) || return 0
local str_file="${SAVE_DIR}/$1"
if [[ -r $str_file ]]; then
	log -w "Destroying existing sets"
	run_ipset -F -q
	run_ipset -X -q
	if run_ipset -R <"$str_file"; then
		log -N "ipset rules successfully restored from: \`$str_file'"
	else
		log -E "Failed restoring ipset rules from: \`$str_file'."
		return $ER_FAIL
	fi
else
	log -x "$str_file"
	return $ER_NOEX
fi
} # -------------------------------------------------------------------------

ipt_restore() { # restore the firewall with iptables-restore
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
if ((IPTSAVE_FAILS)); then
	log -E "\`IPTSAVE_FAILS' is set to \`$IPTSAVE_FAILS'."
	return $ER_FAIL
fi
local str_c="" str_file="${SAVE_DIR}/$1"
if ((USE_COUNTERS)); then
	str_c="--counters "
fi
if [[ -r $str_file ]]; then
	if "$IPT_RESTORE" $str_c <"$str_file"; then
		log -N "iptables rules successfully restored from: \`$str_file'"
	else
		log -E "Failed restoring iptables rules from: \`$str_file'."
		return $ER_FAIL
	fi
else
	log -x "$str_file"
	return $ER_NOEX
fi
} # -------------------------------------------------------------------------

set_default_policies_immediate() { # set (IP-Array) default policies
local table c chain rest
log -I "Immediately applying default policies"
if ! [[ -r $IP_TABLES_NAMES ]]; then
	log -W "\`$IP_TABLES_NAMES' does not exist, module ip_tables is not loaded"
	dn run_ipt -nL
fi
while read -t $GLOBAL_READ_TIMEOUT table; do
	while read -t $GLOBAL_READ_TIMEOUT c chain rest; do
		if [[ $c = Chain ]]; then
			if [[ $table = filter ]]; then
				if [[ $chain = @(@(IN|OUT)PUT|FORWARD) ]]; then
					dn run_ipt -t $table -P $chain 'DROP' || continue
				fi
			else
				if [[ $chain = @(@(IN|OUT)PUT|FORWARD|@(PRE|POST)ROUTING) ]]; then
					dn run_ipt -t $table -P $chain 'ACCEPT' || continue
				fi
			fi
		fi
	done < <(run_ipt -t $table -nL)
done < "$IP_TABLES_NAMES"
} # -------------------------------------------------------------------------

flush_table() { # flush all chains in a specified table
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local tgt_tbl="$1"
val_table "$tgt_tbl" || return
local c chain rest
log -S "Flushing chains in "$tgt_tbl" table"
while read -t $GLOBAL_READ_TIMEOUT c chain rest; do
	if [[ $c = Chain ]]; then
		IPT_FLUSH_ARRAY[${#IPT_FLUSH_ARRAY[@]}]="-t $tgt_tbl -F $chain"
	fi
done < <(run_ipt -t "$tgt_tbl" -nL)
IPT_FLUSH_ARRAY[${#IPT_FLUSH_ARRAY[@]}]="-t "$tgt_tbl" -X"
} # -------------------------------------------------------------------------

flushdel_tables_immediate() { # immediately flush and delete existing tables
local table c chain rest
log -I "Immediately flushing and deleting existing chains"
if ! [[ -r $IP_TABLES_NAMES ]]; then
	log -W "\`$IP_TABLES_NAMES' does not exist, module ip_tables is not loaded. Trying to initialize."
	dn run_ipt -nL || {
		log -E "Failed to initialize iptables"
		return $ER_FAIL
	}
fi
if ! [[ -r $IP_TABLES_NAMES ]]; then
	log -E "\`$IP_TABLES_NAMES' does not exist, module ip_tables is not loaded."
	return $ER_FAIL
fi
while read -t $GLOBAL_READ_TIMEOUT table; do
	while read -t $GLOBAL_READ_TIMEOUT c chain rest; do
		if [[ $c = Chain ]]; then
			run_ipt -t $table -F $chain || log -f "flushing $chain chain"
		fi
	done < <(run_ipt -t $table -nL 2>/dev/null)
	run_ipt -t $table -X || log -f "deleting user defined chains in $table table"
done < "$IP_TABLES_NAMES"
} # -------------------------------------------------------------------------

flushdel_tables() { # flush and delete existing tables
local table c chain rest
log -S "Flushing and deleting existing chains"
if [[ $MODE = @(SAVE-?(IPT-)COMMANDS) ]]; then
	return 0
fi
if ! [[ -r $IP_TABLES_NAMES ]]; then
	log -W "\`$IP_TABLES_NAMES' does not exist, module ip_tables is not loaded?"
	return 0
fi
while read -t $GLOBAL_READ_TIMEOUT table; do
	while read -t $GLOBAL_READ_TIMEOUT c chain rest; do
		if [[ $c = Chain ]]; then
			IPT_FLUSH_ARRAY[${#IPT_FLUSH_ARRAY[@]}]="-t $table -F $chain"
		fi
	done < <(run_ipt -t $table -nL 2>/dev/null)
	IPT_FLUSH_ARRAY[${#IPT_FLUSH_ARRAY[@]}]="-t $table -X"
done < "$IP_TABLES_NAMES"
} # -------------------------------------------------------------------------

flush_table_pub_save() { # flush all chains in a specified table
"$CAT" <<'END_OF_FUNC'

flush_table() {
local tgt_tbl="$1"
local c chain rest
while read c chain rest; do
	if [[ $c = Chain ]]; then
		"$IPT" -t "$tgt_tbl" -F "$chain"
	fi
done < <("$IPT" -t "$tgt_tbl" -nL)
"$IPT" -t "$tgt_tbl" -X
}

END_OF_FUNC
} # -------------------------------------------------------------------------

show_flush_del_pub_save() { # generate iptables chains flusing/deleting function
"$CAT" <<'END_OF_FUNC'

flush_del_ipt_chains() {
if ! [[ -f $IP_TABLES_NAMES ]]; then
	printf "%s\n" "$IP_TABLES_NAMES does not exist, module ip_tables is not loaded?"
	return 0
fi
while read; do
	"$IPT" -t $REPLY -nL | while read c chain rest; do
		if [[ $c = Chain ]]; then
			"$IPT" -t $REPLY -F "$chain"
		fi
	done
	"$IPT" -t $REPLY -X
done < "$IP_TABLES_NAMES"
}

END_OF_FUNC
} # -------------------------------------------------------------------------

test_chain() { # create / delete an iptables testing chain
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
((NO_IPT_COMPAT_CHECK == 0)) || return 0
case "$1" in
	create)
		log -w "creating test chain"
		for rvar in filter mangle nat raw rawpost; do
			if [[ $rvar = raw ]]; then
				((RAW_TABLE_PRESENT == 1)) || continue
			fi
			if [[ $rvar = rawpost ]]; then
				((RAWPOST_TABLE_PRESENT == 1)) || continue
			fi
			if dn run_ipt -t $rvar -nL $BIC_TEST_CHAIN; then
				log -W "chain $BIC_TEST_CHAIN in $rvar table already exists"
				continue
			else
				run_ipt -t $rvar -N $BIC_TEST_CHAIN || {
					log -E "Failed creating chain $BIC_TEST_CHAIN in $rvar table"
					return $ER_FAIL
				}
			fi
		done
	;;
	delete)
		log -w "deleting test chain"
		for rvar in filter mangle nat raw rawpost; do
			if [[ $rvar = raw ]]; then
				((RAW_TABLE_PRESENT == 1)) || continue
			fi
			if [[ $rvar = rawpost ]]; then
				((RAWPOST_TABLE_PRESENT == 1)) || continue
			fi
			run_ipt -t $rvar -F $BIC_TEST_CHAIN || log -f "flushing chain $BIC_TEST_CHAIN in $rvar table"
			run_ipt -t $rvar -X $BIC_TEST_CHAIN || log -f "deleting chain $BIC_TEST_CHAIN in $rvar table"
		done
	;;
	*) log -o "$1" $FUNCNAME
		return 1
	;;
esac
} # -------------------------------------------------------------------------

#set_ipt_table_names() {
#IP_TABLES_NAMES_CHECKSTRING=$("${CAT}" "$IP_TABLES_NAMES")
#IP_TABLES_NAMES_CHECKSTRING=${IP_TABLES_NAMES_CHECKSTRING//[[:space:]]/|}
#}
# -------------------------------------------------------------------------

set_global_log_params() { # set default log parameters, if they are not set by the user
if [[ ${GLOBAL_LOGLIMIT} ]]; then
	val_limit "${GLOBAL_LOGLIMIT}" || return $ER_CONF
else
	GLOBAL_LOGLIMIT="1/s"
	log -N "\`GLOBAL_LOGLIMIT' is not configured, setting it to the default value: \`1/s'"
fi
if [[ ${GLOBAL_BURSTLIMIT} ]]; then
	val_limit_burst "${GLOBAL_BURSTLIMIT}" || return $ER_CONF
else
	GLOBAL_BURSTLIMIT="3"
	log -N "\`GLOBAL_BURSTLIMIT' is not configured, setting it to the default value: \`3'"
fi
if [[ ${GLOBAL_LOGLEVL} ]]; then
	val_loglevel "${GLOBAL_LOGLEVL}" || return $ER_CONF
else
	GLOBAL_LOGLEVL="info"
	log -N "\`GLOBAL_BURSTLIMIT' is not configured, setting it to the default value: \`info'"
fi
readonly GLOBAL_LOGLIMIT GLOBAL_BURSTLIMIT GLOBAL_LOGLEVL
} # -------------------------------------------------------------------------

check_mangle_chains() {
((ENABLE_MANGLE || ENABLE_TC_SHAPING)) || return 0
if ((MANGLE_CHAINS_PRESENT == 0)); then
	dn run_ipt -t mangle -nL INPUT && MANGLE_CHAINS_PRESENT=1
fi
} # -------------------------------------------------------------------------

check_raw_table() {
((ENABLE_RAW == 0)) && {
	RAW_TABLE_PRESENT=0
	return 0
}
((NO_IPT_COMPAT_CHECK)) && {
	RAW_TABLE_PRESENT=1
	return 0
}
log -w "Checking for raw table"
dn run_ipt -t raw -nL || RAW_TABLE_PRESENT=0
} # -------------------------------------------------------------------------

check_rawpost_table() {
((ENABLE_RAWPOST == 0)) && {
	RAWPOST_TABLE_PRESENT=0
	return 0
}
((NO_IPT_COMPAT_CHECK)) && {
	RAWPOST_TABLE_PRESENT=1
	return 0
}
log -w "Checking for rawpost table"
dn run_ipt -t rawpost -nL || RAWPOST_TABLE_PRESENT=0
} # -------------------------------------------------------------------------

check_security_table() {
((ENABLE_SECURITY == 0)) && {
	SECURITY_TABLE_PRESENT=0
	return 0
}
((NO_IPT_COMPAT_CHECK)) && {
	SECURITY_TABLE_PRESENT=1
	return 0
}
log -w "Checking for security table"
dn run_ipt -t security -nL || SECURITY_TABLE_PRESENT=0
} # -------------------------------------------------------------------------

load_known_traffic_map() {
((ENABLE_FILTER)) || return 0
[[ ${KNOWN_TRAFFIC_MAP} ]] || return 0
log -w "Loading KNOWN_TRAFFIC_MAP"
fill_array 'KNOWN_TRAFFIC_MAP'
((${#KNOWN_TRAFFIC_MAP[@]})) || {
	log -u 'KNOWN_TRAFFIC_MAP'
	return 0
}
[[ $DEBUG_INFO ]] && dbg_arr 'KNOWN_TRAFFIC_MAP' || :
check_array_unique 'KNOWN_TRAFFIC_MAP' || {
	raise_cfg_err_count
	return 0
}
readonly KNOWN_TRAFFIC_MAP
} # -------------------------------------------------------------------------

fill_final_rule_map() { # fill FINAL_RULE_MAP array
((ENABLE_FILTER)) || return 0
[[ ${FINAL_RULE_MAP} ]] || return 0
log -w "Loading FINAL_RULE_MAP"
fill_array 'FINAL_RULE_MAP'
((${#FINAL_RULE_MAP[@]})) || {
log -u 'FINAL_RULE_MAP'
return 0
}
[[ $DEBUG_INFO ]] && dbg_arr 'FINAL_RULE_MAP' || :
check_str_unique $(show_array_column 'FINAL_RULE_MAP') || {
	log -E "Duplicate chain name in \`FINAL_RULE_MAP'."
	raise_cfg_err_count
	return 0
}
readonly FINAL_RULE_MAP
} # -------------------------------------------------------------------------

set_chain_classification() {
local str_mode str_tables str_tbl
JUMP_TREE=$(string_tolower "${JUMP_TREE:-none}")
set -- $JUMP_TREE
str_mode="$1"
shift
str_tables="$@"
if [[ $str_tables ]]; then
	check_str_unique "$str_tables" || {
		log -i "$JUMP_TREE" 'JUMP_TREE'
		raise_cfg_err_count
		return $ER_CONF
	}
fi
#JUMP_TREE=(
#[0]=enable/disable
#[1]=jump tree mode
#[2]=tables
#[3]=netname only?
#)
JUMP_TREE=()
case "$str_mode" in
	none)
		log -w "Not applying chain classification"
		JUMP_TREE[0]=0
		JUMP_TREE[3]=1
	;;
	interface|netname)
		JUMP_TREE[0]=1
		JUMP_TREE[3]=1
	;;
	netname+interface)
		JUMP_TREE[0]=1
		JUMP_TREE[3]=0
	;;
	*) log -i "$str_mode" 'JUMP_TREE'
		raise_cfg_err_count
		return $ER_CONF
esac
JUMP_TREE[1]="$str_mode"
case "$str_tables" in
	none)
		log -N "Jump tree tables are set to \`none', disabling jump tree creation."
		JUMP_TREE[0]=0
		JUMP_TREE[1]="none"
		JUMP_TREE[2]=""
	;;
	""|all)
		JUMP_TREE[2]="mangle nat filter"
		((ENABLE_RAW)) && JUMP_TREE[2]+=" raw"
		((ENABLE_RAWPOST)) && JUMP_TREE[2]+=" rawpost"
		((ENABLE_SECURITY)) && JUMP_TREE[2]+=" security"
	;;
	*)
		for str_tbl in $str_tables; do
			val_table "$str_tbl" || {
				log -i "$str_tables" 'JUMP_TREE'
				raise_cfg_err_count
				return $ER_CONF
			}
			JUMP_TREE[2]+="$str_tbl "
		done
esac
if [[ $DEBUG_INFO ]]; then dbg_arr JUMP_TREE; fi
} # -------------------------------------------------------------------------

jump_tree_on() {
JUMP_TREE[0]=1
} # -------------------------------------------------------------------------

jump_tree_off() {
JUMP_TREE[0]=0
} # -------------------------------------------------------------------------

set_policy() { # set iptables policies
[[ $3 ]] || { reqparm $FUNCNAME 3; return 1; }
local pol_table="$1" pol_chain="$2" pol_policy="$3"
IPT_POL_ARRAY[${#IPT_POL_ARRAY[@]}]="-t ${pol_table} -P ${pol_chain} ${pol_policy}"
} # -------------------------------------------------------------------------

load_policy_map() { # load the global policies from user defined array
if [[ ${POLICY_MAP} ]]; then
	log -w "Loading POLICY_MAP"
	fill_array 'POLICY_MAP'
	((${#POLICY_MAP[@]})) || {
		log -u 'POLICY_MAP'
		raise_cfg_err_count
		return $ER_NODEF
	}
	[[ $DEBUG_INFO ]] && dbg_arr 'POLICY_MAP'
	check_array_unique 'POLICY_MAP' || {
		raise_cfg_err_count
		return $ER_FAIL
	}
	readonly POLICY_MAP
else
	log -u 'POLICY_MAP'
	return $ER_NODEF
fi
} # -------------------------------------------------------------------------

get_policy() {
[[ $2 ]] || { reqparm $FUNCNAME 2; return 1; }
local -i pm_idx
local str_tbl="$1" str_chn="$2"
for pm_idx in ${!POLICY_MAP[@]}; do
	set -- ${POLICY_MAP[pm_idx]}
	if [[ ${str_tbl} = $1 && ${str_chn} = $2 ]]; then
		pr_str "$3"
		return 0
	fi
done
log -E "Policy of ${str_chn} in ${str_tbl} table is not defined."
raise_cfg_err_count
return 1
} # -------------------------------------------------------------------------

get_output_policy() { # query OUTPUT chains policy
log -w "querying OUTPUT policy"
OUTPUT_POLICY=$(get_policy filter OUTPUT) || return $ER_NODEF
readonly OUTPUT_POLICY
} # -------------------------------------------------------------------------

policy_all_en_disable() { # set all policies to accept or drop
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local pol=$1
local ipt_table ipt_chain
log -T "Setting policies to ${pol}"
if ! [[ -r $IP_TABLES_NAMES ]]; then
	log -W "\`$IP_TABLES_NAMES' does not exist, module ip_tables is not loaded?"
	return 0
fi
while read -t $GLOBAL_READ_TIMEOUT ipt_table; do
	while read -t $GLOBAL_READ_TIMEOUT ipt_chain; do
		if [[ ${ipt_chain} = Chain@([[:space:]])+([[:upper:]])@([[:space:]])\(policy@([[:space:]])+([[:upper:]])\) ]]
		then
			set -- ${ipt_chain}
			set_policy ${ipt_table} $2 ${pol} || return
		fi
	done < <(run_ipt -t ${ipt_table} -nL)
done < "$IP_TABLES_NAMES"
} # -------------------------------------------------------------------------

set_global_policies() { # set global policies
local -i idx
log -S "Setting global policies"
if ! ((${#POLICY_MAP[@]})); then
	log -r 'POLICY_MAP'
	raise_cfg_err_count
	return $ER_NODEF
fi
for idx in ${!POLICY_MAP[@]}; do
	set -- ${POLICY_MAP[idx]}
	local strERR="POLICY_MAP ${idx} ${POLICY_MAP[idx]}" str_tbl=$1 str_chn=$2 str_policy=$3
	[[ $3 ]] || { cfg_err ${strERR}; continue; }
	val_table ${str_tbl} || { cfg_err ${strERR}; continue; }
	val_builtin_chain ${str_tbl} ${str_chn} || { cfg_err ${strERR}; continue; }
	val_policy_target ${str_policy} || { cfg_err ${strERR}; continue; }
	if [[ ${str_tbl} != @(filter|security) && ${str_policy} = DROP ]]; then
		log -W "It's not advisable to use a DROP policy for a non filter/security table chain."
	fi
	log -e "${PF}setting policy: table=${str_tbl} chain=${str_chn} policy=${str_policy}"
	set_policy ${str_tbl} ${str_chn} ${str_policy} || return
done
} # -------------------------------------------------------------------------

set_output_rule_mode() {
# disable additional output rules, if either output policy is ACCEPT, 
# or RESTRICT_OUTPUT is 0, IFBOUND or IPBOUND
case "${RESTRICT_OUTPUT:=0}" in
	(IFBOUND|IPBOUND)
		if [[ ${OUTPUT_POLICY} = ACCEPT ]]; then
			log -E "\`RESTRICT_OUTPUT' is set to \`${RESTRICT_OUTPUT}', but OUTPUT policy is set to ACCEPT."
			raise_cfg_err_count
			return $ER_CONF
		fi
		OUTPUT_RULES_REQUIRED=0
		NO_OUTPUT_MSG="RESTRICT_OUTPUT is set to \`${RESTRICT_OUTPUT}', not applying additional OUTPUT allow rules."
	;;
	(0)
		OUTPUT_RULES_REQUIRED=0
		if [[ ${OUTPUT_POLICY} = DROP ]]; then
			log -w "\`RESTRICT_OUTPUT' is disabled, but OUTPUT policy is set to DROP. Automatic OUTPUT allow settings are not used."
		fi
	;;
	(1)
		if [[ ${OUTPUT_POLICY} = ACCEPT ]]; then
			log -E "\`RESTRICT_OUTPUT' is set to \`1', but OUTPUT policy is set to ACCEPT."
			raise_cfg_err_count
			return $ER_CONF
		fi
	;;
	*) log -i "${RESTRICT_OUTPUT}" 'RESTRICT_OUTPUT'
		raise_cfg_err_count
		return $ER_CONF
esac
if [[ ${NO_OUTPUT_MSG} ]]; then log -N "${NO_OUTPUT_MSG}"; fi
} # -------------------------------------------------------------------------

output_rules_required_msg() # display a notice message, if additional output rules are not required
{
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local msg_mode="$1" config_var="$2"
case "${msg_mode}" in
	auto)
		if ((OUTPUT_RULES_REQUIRED == 0)) && [[ ${NO_OUTPUT_MSG} ]]; then
			log -N "${NO_OUTPUT_MSG}"
		fi
	;;
	manual)
		((OUTPUT_RULES_REQUIRED == 0)) && return 0
		[[ ${config_var} ]] || {
			log -u 'config_var'
			return 0
		}
		case "${RESTRICT_OUTPUT:=0}" in
			(IFBOUND | IPBOUND)
				log -N "RESTRICT_OUTPUT is set to \`${RESTRICT_OUTPUT}', \
					consider to disable processing of ${config_var}."
			;;
			(0|"")
				if [[ ${OUTPUT_POLICY} = ACCEPT ]]; then
					log -N "OUTPUT policy is set to ACCEPT and RESTRICT_OUTPUT is set to \
						\`${RESTRICT_OUTPUT}', consider to disable processing of ${config_var}."
				fi
			;;
			(1) : ;;
			*) log -i "${RESTRICT_OUTPUT}" 'RESTRICT_OUTPUT'
				return 0
		esac
	;;
	*) log -i ${msg_mode} 'msg_mode'
		raise_cfg_err_count
		return 0
esac
} # -------------------------------------------------------------------------

iface_chains() {
# create chains per interface and the tables builtin chains
# and create cross interface chains (each IF -> each other IF)
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local iface oif str_chn
local -a ARR_CLIST
log -I "Creating ${JUMP_TREE[1]} jump tree chains in $1 table"
for iface in ${NET_IFLIST}; do
	case "$1" in
		filter|security)
			ARR_CLIST[${#ARR_CLIST[@]}]="INPUT_${iface}"
			ARR_CLIST[${#ARR_CLIST[@]}]="OUTPUT_${iface}"
			if ((PROC_IP_FORWARD == 1)); then
				for oif in ${NET_IFLIST/${iface}/}; do
					ARR_CLIST[${#ARR_CLIST[@]}]="${iface}${IF_CON}${oif}"
				done
			fi
		;;
		mangle)
			if ((ALL_MANGLE_CHAINS_PRESENT == 0)); then # mangle table chains prior to kernel 2.4.18
				ARR_CLIST[${#ARR_CLIST[@]}]="PREROUTING_${iface}"
				ARR_CLIST[${#ARR_CLIST[@]}]="OUTPUT_${iface}"
			else # mangle table chains in kernel version greater than 2.4.17
				ARR_CLIST[${#ARR_CLIST[@]}]="PREROUTING_${iface}"
				ARR_CLIST[${#ARR_CLIST[@]}]="OUTPUT_${iface}"
				ARR_CLIST[${#ARR_CLIST[@]}]="INPUT_${iface}"
				ARR_CLIST[${#ARR_CLIST[@]}]="POSTROUTING_${iface}"
				if ((PROC_IP_FORWARD == 1)); then
					for oif in ${NET_IFLIST/${iface}/}; do
						ARR_CLIST[${#ARR_CLIST[@]}]="${iface}${IF_CON}${oif}"
					done
				fi
			fi
		;;
		nat)
			ARR_CLIST[${#ARR_CLIST[@]}]="OUTPUT_${iface}"
			ARR_CLIST[${#ARR_CLIST[@]}]="PREROUTING_${iface}"
			ARR_CLIST[${#ARR_CLIST[@]}]="POSTROUTING_${iface}"
		;;
		raw)
			ARR_CLIST[${#ARR_CLIST[@]}]="OUTPUT_${iface}"
			ARR_CLIST[${#ARR_CLIST[@]}]="PREROUTING_${iface}"
		;;
		rawpost)
			ARR_CLIST[${#ARR_CLIST[@]}]="POSTROUTING_${iface}"
		;;
		*) log -o "$1" $FUNCNAME
			return 1
	esac
done
for str_chn in "${ARR_CLIST[@]}"; do
	create_chain $1 "${str_chn}"
done
} # -------------------------------------------------------------------------

iface_jumps() { # create iptables cross interface jump entries
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local str_tbl="$1" iface oif str_jmsg str_chn str_tgt
local -i i idx
local -a arr_jcmd
log -I "Creating ${JUMP_TREE[1]} jump tree chains in ${str_tbl} table"
for iface in ${NET_IFLIST}; do
	case "${str_tbl}" in
		filter|security)
			arr_jcmd[${#arr_jcmd[@]}]="INPUT -i ${iface} -j INPUT_${iface}"
			arr_jcmd[${#arr_jcmd[@]}]="OUTPUT -o ${iface} -j OUTPUT_${iface}"
			if ((PROC_IP_FORWARD == 1)); then
				for oif in ${NET_IFLIST/${iface}/}; do
					arr_jcmd[${#arr_jcmd[@]}]="FORWARD -i ${iface} -o ${oif} -j ${iface}${IF_CON}${oif}"
				done
				arr_jcmd[${#arr_jcmd[@]}]="FORWARD -i ${iface} -j FWD_IN_${iface}"
				arr_jcmd[${#arr_jcmd[@]}]="FORWARD -o ${iface} -j FWD_OUT_${iface}"
			fi
		;;
		mangle)
			if ((ALL_MANGLE_CHAINS_PRESENT == 0)); then # mangle table chains prior to kernel 2.4.18
				arr_jcmd[${#arr_jcmd[@]}]="OUTPUT -o ${iface} -j OUTPUT_${iface}"
				arr_jcmd[${#arr_jcmd[@]}]="PREROUTING -i ${iface} -j PREROUTING_${iface}"
			else # mangle table chains in kernel version greater than 2.4.17
				arr_jcmd[${#arr_jcmd[@]}]="OUTPUT -o ${iface} -j OUTPUT_${iface}"
				arr_jcmd[${#arr_jcmd[@]}]="PREROUTING -i ${iface} -j PREROUTING_${iface}"
				arr_jcmd[${#arr_jcmd[@]}]="INPUT -i ${iface} -j INPUT_${iface}"
				arr_jcmd[${#arr_jcmd[@]}]="POSTROUTING -o ${iface} -j POSTROUTING_${iface}"
				if ((PROC_IP_FORWARD == 1)); then
					for oif in ${NET_IFLIST/${iface}/}; do
						arr_jcmd[${#arr_jcmd[@]}]="FORWARD -i ${iface} -o ${oif} -j ${iface}${IF_CON}${oif}"
					done
					arr_jcmd[${#arr_jcmd[@]}]="FORWARD -i ${iface} -j FWD_IN_${iface}"
					arr_jcmd[${#arr_jcmd[@]}]="FORWARD -o ${iface} -j FWD_OUT_${iface}"
				fi
			fi
		;;
		nat)
			arr_jcmd[${#arr_jcmd[@]}]="OUTPUT -o ${iface} -j OUTPUT_${iface}"
			arr_jcmd[${#arr_jcmd[@]}]="PREROUTING -i ${iface} -j PREROUTING_${iface}"
			arr_jcmd[${#arr_jcmd[@]}]="POSTROUTING -o ${iface} -j POSTROUTING_${iface}"
		;;
		raw)
			arr_jcmd[${#arr_jcmd[@]}]="OUTPUT -o ${iface} -j OUTPUT_${iface}"
			arr_jcmd[${#arr_jcmd[@]}]="PREROUTING -i ${iface} -j PREROUTING_${iface}"
		;;
		rawpost)
			arr_jcmd[${#arr_jcmd[@]}]="POSTROUTING -o ${iface} -j POSTROUTING_${iface}"
		;;
		*) log -o "$1" $FUNCNAME
			return 1
	esac
done
for idx in ${!arr_jcmd[@]}; do # create log messages and add_rule commands
	str_jmsg="${arr_jcmd[idx]}"
	[[ ${str_jmsg} ]] || continue # should not be
	str_jmsg="${str_jmsg/-i /idev=}"
	str_jmsg="${str_jmsg/-o /odev=}"
	str_jmsg="${str_jmsg/-j /target=}"
	str_tgt="${str_jmsg#*target=}"
	set -- ${str_jmsg}
	str_chn=$1
	shift
	str_jmsg=${*}
	for i in ${!CREATED_CHAINS_ARRAY[@]}; do
		set -- ${CREATED_CHAINS_ARRAY[i]}
		if [[ $1 = ${str_tbl} && $2 = ${str_tgt} ]]; then
			log -e "${PF}jump table=${str_tbl} chain=${str_chn} ${str_jmsg}"
			add_rule "${str_tbl}" ${arr_jcmd[idx]}
			break
		fi
	done
done
} # -------------------------------------------------------------------------

create_netname_chains() { # create traffic classification chains by netname or netname+interface
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local str_tbl="$1" str_net str_onet str_clist str_cilist str_chn str_net_iface str_onet_iface
local -i multi_bound
log -I "Creating ${JUMP_TREE[1]} jump tree chains in ${str_tbl} table"
for str_net in ${EXT_NETNAME_LIST}; do # first handle external networks first - logic differs from local networks
	multi_bound=0
	str_net_iface=$(get_net_iface ${str_net})
	# network with alias, if JUMP_TREE[3] = 0, also create interface depandant chains
	(($(members_in_string $(show_array_column IFDATA_ARRAY_${str_net_iface})) > 1)) && multi_bound=1
	case "${str_tbl}" in # each table has a different logic depending on the builtin chains
		raw)
			for str_chn in "${str_net}_PRE" "${str_net}_OUTPUT"; do
				lsearch "${str_chn}" ${str_clist} || str_clist+=" ${str_chn}"
			done
			if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
				lsearch "OUTPUT_${str_net_iface}" ${str_cilist} || str_cilist+=" OUTPUT_${str_net_iface}"
			fi
		;;
		rawpost)
			lsearch "${str_net}_POST" ${str_clist} || str_clist+=" ${str_net}_POST"
			if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
				lsearch "POSTROUTING_${str_net_iface}" ${str_cilist} || str_cilist+=" POSTROUTING_${str_net_iface}"
			fi
		;;
		mangle)
			if ((ALL_MANGLE_CHAINS_PRESENT == 0)); then # kernel version lower than 2.4.18
				for str_chn in "${str_net}_PRE" "${str_net}_OUTPUT"; do
					lsearch "${str_chn}" ${str_clist} || str_clist+=" ${str_chn}"
				done
				if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
					for str_chn in "OUTPUT_${str_net_iface}"; do
						lsearch "${str_chn}" ${str_cilist} || str_cilist+=" ${str_chn}"
					done
				fi
			else
				for str_chn in "${str_net}_PRE" "${str_net}_POST" "${str_net}_INPUT" "${str_net}_OUTPUT"; do
					lsearch "${str_chn}" ${str_clist} || str_clist+=" ${str_chn}"
				done
				if ((PROC_IP_FORWARD == 1)); then
					for str_chn in "${str_net}_FWD_IN" "${str_net}_FWD_OUT"; do
						lsearch "${str_chn}" ${str_clist} || str_clist+=" ${str_chn}"
					done
				fi
				if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
					for str_chn in "INPUT_${str_net_iface}" "OUTPUT_${str_net_iface}"; do
						lsearch "${str_chn}" ${str_cilist} || str_cilist+=" ${str_chn}"
					done
				fi
			fi
		;;
		nat)
			for str_chn in "${str_net}_PRE" "${str_net}_POST" "${str_net}_OUTPUT"; do
				lsearch "${str_chn}" ${str_clist} || str_clist+=" ${str_chn}"
			done
			if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
				lsearch "OUTPUT_${str_net_iface}" ${str_cilist} || str_cilist+=" OUTPUT_${str_net_iface}"
			fi
		;;
		filter|security)
			for str_chn in "${str_net}_INPUT" "${str_net}_OUTPUT"; do
				lsearch "${str_chn}" ${str_clist} || str_clist+=" ${str_chn}"
			done
			if ((PROC_IP_FORWARD == 1)); then
				for str_chn in "${str_net}_FWD_IN" "${str_net}_FWD_OUT"; do
					lsearch "${str_chn}" ${str_clist} || str_clist+=" ${str_chn}"
				done
			fi
			if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
				for str_chn in "INPUT_${str_net_iface}" "OUTPUT_${str_net_iface}"; do
					lsearch "${str_chn}" ${str_cilist} || str_cilist+=" ${str_chn}"
				done
			fi
		;;
		*) log -o "$1" $FUNCNAME
			return 1
	esac
done
for str_net in ${LOC_NETNAME_LIST}; do # handle local networks
	multi_bound=0
	str_net_iface=$(get_net_iface ${str_net})
	(($(members_in_string $(show_array_column IFDATA_ARRAY_${str_net_iface})) > 1)) && multi_bound=1
	case "${str_tbl}" in
		raw)
			for str_chn in "${str_net}_PRE" "${str_net}_OUTPUT"; do
				lsearch "${str_chn}" ${str_clist} || str_clist+=" ${str_chn}"
			done
			if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
				lsearch "OUTPUT_${str_net_iface}" ${str_cilist} || str_cilist+=" OUTPUT_${str_net_iface}"
			fi
		;;
		rawpost)
			lsearch "${str_net}_POST" ${str_clist} || str_clist+=" ${str_net}_POST"
		;;
		mangle)
			if ((ALL_MANGLE_CHAINS_PRESENT == 0)); then
				for str_chn in "${str_net}_PRE" "${str_net}_OUTPUT"; do
					lsearch "${str_chn}" ${str_clist} || str_clist+=" ${str_chn}"
				done
				if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
					for str_chn in "OUTPUT_${str_net_iface}"; do
						lsearch "${str_chn}" ${str_cilist} || str_cilist+=" ${str_chn}"
					done
				fi
			else
				for str_chn in "${str_net}_PRE" "${str_net}_POST" "${str_net}_INPUT" "${str_net}_OUTPUT"; do
					lsearch "${str_chn}" ${str_clist} || str_clist+=" ${str_chn}"
				done
				if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
					for str_chn in "INPUT_${str_net_iface}" "OUTPUT_${str_net_iface}" "FWD_IN_${str_net_iface}" "FWD_OUT_${str_net_iface}"; do
						lsearch "${str_chn}" ${str_cilist} || str_cilist+=" ${str_chn}"
					done
				fi
				if ((PROC_IP_FORWARD == 1)); then
					for str_chn in "${str_net}_FWD_IN" "${str_net}_FWD_OUT"; do
						lsearch "${str_chn}" ${str_clist} || str_clist+=" ${str_chn}"
					done
					for str_onet in ${LOC_NETNAME_LIST/${str_net}/}; do
						[[ ${str_net_iface} = $(get_net_iface "${str_onet}") ]] && continue
						for str_chn in "${str_net}_${str_onet}" "${str_net}_${str_onet}_PRE" "${str_net}_${str_onet}_POST"; do
							lsearch "${str_chn}" ${str_clist} || str_clist+=" ${str_chn}"
						done
					done
					if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
						for str_onet_iface in ${NET_IFLIST/${str_net_iface}/}; do
							lsearch "${str_net_iface}${IF_CON}${str_onet_iface}" ${str_cilist} || str_cilist+=" ${str_net_iface}${IF_CON}${str_onet_iface}"
						done
					fi
				fi
			fi
		;;
		nat)
			for str_chn in "${str_net}_PRE" "${str_net}_POST" "${str_net}_OUTPUT"; do
				lsearch "${str_chn}" ${str_clist} || str_clist+=" ${str_chn}"
			done
			if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
				lsearch "OUTPUT_${str_net_iface}" ${str_cilist} || str_cilist+=" OUTPUT_${str_net_iface}"
			fi
		;;
		filter|security)
			for str_chn in "${str_net}_INPUT" "${str_net}_OUTPUT"; do
				lsearch "${str_chn}" ${str_clist} || str_clist+=" ${str_chn}"
			done
			if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
				for str_chn in "INPUT_${str_net_iface}" "OUTPUT_${str_net_iface}" "FWD_IN_${str_net_iface}" "FWD_OUT_${str_net_iface}"; do
					lsearch "${str_chn}" ${str_cilist} || str_cilist+=" ${str_chn}"
				done
			fi
			if ((PROC_IP_FORWARD == 1)); then
				for str_chn in "${str_net}_FWD_IN" "${str_net}_FWD_OUT"; do
					lsearch "${str_chn}" ${str_clist} || str_clist+=" ${str_chn}"
				done
				for str_onet in ${LOC_NETNAME_LIST/${str_net}/}; do
					[[ ${str_net_iface} = $(get_net_iface "${str_onet}") ]] && continue
					lsearch "${str_net}_${str_onet}" ${str_clist} || str_clist+=" ${str_net}_${str_onet}"
				done
				if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
					for str_onet_iface in ${NET_IFLIST/${str_net_iface}/}; do
						lsearch "${str_net_iface}${IF_CON}${str_onet_iface}" ${str_cilist} || str_cilist+=" ${str_net_iface}${IF_CON}${str_onet_iface}"
					done
				fi
			fi
		;;
		*) log -o "$1" $FUNCNAME
			return 1
	esac
done
for str_chn in ${str_clist} ${str_cilist}; do
	create_chain ${str_tbl} "${str_chn}"
done
} # -------------------------------------------------------------------------

create_netname_jumps() { # create netname or netname+interface dependant traffic classification jumps
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local str_tbl="$1" str str_net str_net_iface str_netaddr str_clist str_chn str_onet str_onetaddr str_onetiface
local str_param str_chn str_tgt str_i str_p str_jmsg str_if_done_list
local -i i idx ridx multi_bound
local -a arr_stage1 arr_stage2 arr_stage3 arr_stage4 arr_stage5
log -I "Creating ${JUMP_TREE[1]} jump tree in ${str_tbl} table"
for str_net in ${EXT_NETNAME_LIST}; do # first handle external networks
	multi_bound=0
	str_net_iface=$(get_net_iface $str_net) str_netaddr=$(get_net_addr $str_net)
#	(($(members_in_string $(show_array_column IFDATA_ARRAY_${str_net_iface})) > 1)) && multi_bound=1
	(($(members_in_string $(show_array_column IFDATA_ARRAY_${str_net_iface})) > 1)) && {
		log -E "Jump tree creation in \`${JUMP_TREE[1]}' does not support virtual interfaces on external networks."
		raise_cfg_err_count
		return $ER_CONF
}
	case "${str_tbl}" in
		raw)
#			if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
#				str_clist="dst:PREROUTING:PRE src:OUTPUT_${str_net_iface}:OUTPUT"
#				if ! lsearch "${str_net_iface}" ${str_if_done_list}; then
#					str_cilist="src:OUTPUT:OUTPUT_${str_net_iface}"
#					str_if_done_list+=" ${str_net_iface}"
#				fi
#			else
				str_clist="dst:PREROUTING:PRE src:OUTPUT:OUTPUT"
#			fi
		;;
		rawpost)
			str_clist="src:POSTROUTING:POST"
		;;
		mangle)
#			if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
#				if ((ALL_MANGLE_CHAINS_PRESENT == 0)); then
#					str_clist="dst:PREROUTING:PRE src:OUTPUT_${str_net_iface}:OUTPUT"
#					if ! lsearch "${str_net_iface}" ${str_if_done_list}; then
#						str_cilist="src:OUTPUT:OUTPUT_${str_net_iface}"
#						str_if_done_list+=" ${str_net_iface}"
#					fi
#				else
#					str_clist="dst:PREROUTING:PRE src:POSTROUTING:POST dst:INPUT_${str_net_iface}:INPUT src:OUTPUT_${str_net_iface}:OUTPUT"
#					if ! lsearch "${str_net_iface}" ${str_if_done_list}; then
#						str_cilist="dst:INPUT:INPUT_${str_net_iface} src:OUTPUT:OUTPUT_${str_net_iface}"
#						str_if_done_list+=" ${str_net_iface}"
#					fi
#				fi
#			else
				if ((ALL_MANGLE_CHAINS_PRESENT == 0)); then
					str_clist="dst:PREROUTING:PRE src:OUTPUT:OUTPUT"
				else
					str_clist="dst:PREROUTING:PRE src:POSTROUTING:POST dst:INPUT:INPUT src:OUTPUT:OUTPUT"
				fi
#			fi
			if ((ALL_MANGLE_CHAINS_PRESENT == 1)); then
				if ((PROC_IP_FORWARD == 1)); then # to be placed at the end
					arr_stage5[${#arr_stage5[@]}]="FORWARD -i ${str_net_iface} -j ${str_net}_FWD_IN"
					arr_stage5[${#arr_stage5[@]}]="FORWARD -o ${str_net_iface} -j ${str_net}_FWD_OUT"
				fi
			fi
		;;
		nat)
#			if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
#				str_clist="dst:PREROUTING:PRE src:POSTROUTING:POST src:OUTPUT${str_net_iface}:OUTPUT"
#				if ! lsearch "${str_net_iface}" ${str_if_done_list}; then
#					str_cilist="src:OUTPUT:OUTPUT_${str_net_iface}"
#					str_if_done_list+=" ${str_net_iface}"
#				fi
#			else
				str_clist="dst:PREROUTING:PRE src:POSTROUTING:POST src:OUTPUT:OUTPUT"
#			fi
		;;
		filter|security)
#			if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
#				if ! lsearch "${str_net_iface}" ${str_if_done_list}; then
#					str_cilist="dst:INPUT:INPUT_${str_net_iface} src:OUTPUT:OUTPUT_${str_net_iface}"
#					str_if_done_list+=" ${str_net_iface}"
#				fi
#			else
				str_clist="dst:INPUT:INPUT src:OUTPUT:OUTPUT"
#			fi
			if ((PROC_IP_FORWARD == 1)); then # end rules
				arr_stage5[${#arr_stage5[@]}]="FORWARD -i ${str_net_iface} -j ${str_net}_FWD_IN"
				arr_stage5[${#arr_stage5[@]}]="FORWARD -o ${str_net_iface} -j ${str_net}_FWD_OUT"
			fi
		;;
		*) log -o "${str_tbl}" $FUNCNAME
			return 1
	esac
	for str in ${str_clist}; do
		set -- ${str//:/ }
		local str_param="$1" str_chn="$2" str_tgt="$3" str_i str_p
		case "${str_param}" in
			src) str_p="-s" str_i="-o" ;;
			dst) str_p="-d" str_i="-i" ;;
		esac
		if ((JUMP_TREE[3] == 1)); then
			arr_stage2[${#arr_stage2[@]}]="${str_chn} ${str_p} ${str_netaddr} -j ${str_net}_${str_tgt}"
		else
			arr_stage2[${#arr_stage2[@]}]="${str_chn} ${str_i} ${str_net_iface} ${str_p} ${str_netaddr} -j ${str_net}_${str_tgt}"
		fi
	done
#	for str in ${str_cilist}; do
#		set -- ${str//:/ }
#		local str_param="$1" str_chn="$2" str_tgt="$3" str_i
#		case "${str_param}" in
#			src) str_i="-o" ;;
#			dst) str_i="-i"  ;;
#		esac
#		arr_stage1[${#arr_stage1[@]}]="${str_chn} ${str_i} ${str_net_iface} -j ${str_tgt}"
#	done
done

str_if_done_list=""
for str_net in ${LOC_NETNAME_LIST}; do # handle local networks
	str_clist="" str_cilist=""
	multi_bound=0
	str_net_iface=$(get_net_iface $str_net) str_netaddr=$(get_net_addr $str_net)
	(($(members_in_string $(show_array_column IFDATA_ARRAY_${str_net_iface})) > 1)) && multi_bound=1
	case "${str_tbl}" in
		raw)
			arr_stage1[${#arr_stage1[@]}]="PREROUTING -s ${str_netaddr} -j ${str_net}_PRE"
			arr_stage1[${#arr_stage1[@]}]="PREROUTING -d ${str_netaddr} -j ${str_net}_PRE"
			if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
				str_clist="src:OUTPUT_${str_net_iface}:OUTPUT"
				if ! lsearch "${str_net_iface}" ${str_if_done_list}; then
					str_cilist="src:OUTPUT:OUTPUT_${str_net_iface}"
					str_if_done_list+=" ${str_net_iface}"
				fi
			else
				arr_stage1[${#arr_stage1[@]}]="OUTPUT -o ${str_net_iface} -s ${str_netaddr} -j ${str_net}_OUTPUT"
			fi
		;;
		rawpost)
			arr_stage1[${#arr_stage1[@]}]="POSTROUTING -s ${str_netaddr} -j ${str_net}_POST"
			arr_stage1[${#arr_stage1[@]}]="POSTROUTING -d ${str_netaddr} -j ${str_net}_POST"
		;;
		mangle)
			if ((ALL_MANGLE_CHAINS_PRESENT == 0)); then
				if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
					arr_stage1[${#arr_stage1[@]}]="OUTPUT_${str_net_iface} -o ${str_net_iface} -s ${str_netaddr} -j ${str_net}_OUTPUT"
					if ! lsearch "${str_net_iface}" ${str_if_done_list}; then
						arr_stage2[${#arr_stage2[@]}]="OUTPUT -o ${str_net_iface} -j OUTPUT_${str_net_iface}"
					fi
					lsearch "${str_net_iface}" ${str_if_done_list} || str_if_done_list+=" ${str_net_iface}"
				else
					if ((JUMP_TREE[3] == 1)); then
						arr_stage2[${#arr_stage2[@]}]="OUTPUT -s ${str_netaddr} -j ${str_net}_OUTPUT"
					else
						arr_stage2[${#arr_stage2[@]}]="OUTPUT -o ${str_net_iface} -s ${str_netaddr} -j ${str_net}_OUTPUT"
					fi
					if ((PROC_IP_FORWARD == 1)); then
						for str_onet in ${LOC_NETNAME_LIST/${str_net}/}; do
							str_onetaddr=$(get_net_addr ${str_onet})
							if [[ -z ${str_onetaddr} ]]; then
								log -E "Unable to retrieve data of network \`${str_onet}'."
								raise_gen_err_count
								return $ER_FAIL
							fi
							str_onetiface=$(get_net_iface ${str_onet})
							[[ ${str_net_iface} = ${str_onetiface} ]] && continue
							arr_stage1[${#arr_stage1[@]}]="PREROUTING -s ${str_netaddr} -d ${str_onetaddr} -j ${str_net}_${str_onet}_PRE"
						done
					fi
				fi
				arr_stage2[${#arr_stage2[@]}]="PREROUTING -s ${str_netaddr} -j ${str_net}_PRE"
				arr_stage2[${#arr_stage2[@]}]="PREROUTING -d ${str_netaddr} -j ${str_net}_PRE"
			else
				if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
					arr_stage1[${#arr_stage1[@]}]="INPUT_${str_net_iface} -i ${str_net_iface} -d ${str_netaddr} -j ${str_net}_INPUT"
					arr_stage1[${#arr_stage1[@]}]="OUTPUT_${str_net_iface} -o ${str_net_iface} -s ${str_netaddr} -j ${str_net}_OUTPUT"
					if ! lsearch "${str_net_iface}" ${str_if_done_list}; then
						arr_stage2[${#arr_stage2[@]}]="INPUT -i ${str_net_iface} -j INPUT_${str_net_iface}"
						arr_stage2[${#arr_stage2[@]}]="OUTPUT -o ${str_net_iface} -j OUTPUT_${str_net_iface}"
					fi
					if ((PROC_IP_FORWARD == 1)); then
						for str_onet in ${LOC_NETNAME_LIST/${str_net}/}; do
							str_onetaddr=$(get_net_addr ${str_onet})
							if [[ -z ${str_onetaddr} ]]; then
								log -E "Unable to retrieve data of network \`${str_onet}'."
								raise_gen_err_count
								return $ER_FAIL
							fi
							str_onetiface=$(get_net_iface ${str_onet})
							[[ ${str_net_iface} = ${str_onetiface} ]] && continue
							arr_stage1[${#arr_stage1[@]}]="PREROUTING -s ${str_netaddr} -d ${str_onetaddr} -j ${str_net}_${str_onet}_PRE"
							arr_stage1[${#arr_stage1[@]}]="POSTROUTING -s ${str_netaddr} -d ${str_onetaddr} -j ${str_net}_${str_onet}_POST"
							arr_stage1[${#arr_stage1[@]}]="${str_net_iface}${IF_CON}${str_onetiface} -s ${str_netaddr} -d ${str_onetaddr} -j ${str_net}_${str_onet}"
						done
						if ! lsearch "${str_net_iface}" ${str_if_done_list}; then
							for str_onetiface in ${NET_IFLIST/${str_net_iface}/}; do
								arr_stage2[${#arr_stage2[@]}]="FORWARD -i ${str_net_iface} -o ${str_onetiface} -j ${str_net_iface}${IF_CON}${str_onetiface}"
							done
						fi
						arr_stage1[${#arr_stage1[@]}]="FWD_IN_${str_net_iface} -i ${str_net_iface} -s ${str_netaddr} -j ${str_net}_FWD_OUT"
						arr_stage1[${#arr_stage1[@]}]="FWD_OUT_${str_net_iface} -o ${str_net_iface} -d ${str_netaddr} -j ${str_net}_FWD_IN"
						if ! lsearch "${str_net_iface}" ${str_if_done_list}; then
							arr_stage3[${#arr_stage3[@]}]="FORWARD -i ${str_net_iface} -j FWD_IN_${str_net_iface}"
							arr_stage3[${#arr_stage3[@]}]="FORWARD -o ${str_net_iface} -j FWD_OUT_${str_net_iface}"
						fi
					fi
					lsearch "${str_net_iface}" ${str_if_done_list} || str_if_done_list+=" ${str_net_iface}"
				else
					if ((JUMP_TREE[3] == 1)); then
						arr_stage2[${#arr_stage2[@]}]="INPUT -d ${str_netaddr} -j ${str_net}_INPUT"
						arr_stage2[${#arr_stage2[@]}]="OUTPUT -s ${str_netaddr} -j ${str_net}_OUTPUT"
					else
						arr_stage2[${#arr_stage2[@]}]="INPUT -i ${str_net_iface} -d ${str_netaddr} -j ${str_net}_INPUT"
						arr_stage2[${#arr_stage2[@]}]="OUTPUT -o ${str_net_iface} -s ${str_netaddr} -j ${str_net}_OUTPUT"
					fi
					if ((PROC_IP_FORWARD == 1)); then
						for str_onet in ${LOC_NETNAME_LIST/${str_net}/}; do
							str_onetaddr=$(get_net_addr ${str_onet})
							if [[ -z ${str_onetaddr} ]]; then
								log -E "Unable to retrieve data of network \`${str_onet}'."
								raise_gen_err_count
								return $ER_FAIL
							fi
							str_onetiface=$(get_net_iface ${str_onet})
							[[ ${str_net_iface} = ${str_onetiface} ]] && continue
							arr_stage1[${#arr_stage1[@]}]="PREROUTING -s ${str_netaddr} -d ${str_onetaddr} -j ${str_net}_${str_onet}_PRE"
							arr_stage1[${#arr_stage1[@]}]="POSTROUTING -s ${str_netaddr} -d ${str_onetaddr} -j ${str_net}_${str_onet}_POST"
							if ((JUMP_TREE[3] == 1)); then
								arr_stage2[${#arr_stage2[@]}]="FORWARD -s ${str_netaddr} -d ${str_onetaddr} -j ${str_net}_${str_onet}"
							else
								arr_stage2[${#arr_stage2[@]}]="FORWARD -i ${str_net_iface} -o ${str_onetiface} -s ${str_netaddr} -d ${str_onetaddr} -j ${str_net}_${str_onet}"
							fi
						done
						if ((JUMP_TREE[3] == 1)); then
							arr_stage4[${#arr_stage4[@]}]="FORWARD -s ${str_netaddr} -j ${str_net}_FWD_OUT"
							arr_stage4[${#arr_stage4[@]}]="FORWARD -d ${str_netaddr} -j ${str_net}_FWD_IN"
						else
							arr_stage4[${#arr_stage4[@]}]="FORWARD -i ${str_net_iface} -s ${str_netaddr} -j ${str_net}_FWD_OUT"
							arr_stage4[${#arr_stage4[@]}]="FORWARD -o ${str_net_iface} -d ${str_netaddr} -j ${str_net}_FWD_IN"
						fi
					fi
				fi
				arr_stage2[${#arr_stage2[@]}]="PREROUTING -s ${str_netaddr} -j ${str_net}_PRE"
				arr_stage2[${#arr_stage2[@]}]="PREROUTING -d ${str_netaddr} -j ${str_net}_PRE"
				arr_stage2[${#arr_stage2[@]}]="POSTROUTING -s ${str_netaddr} -j ${str_net}_POST"
				arr_stage2[${#arr_stage2[@]}]="POSTROUTING -d ${str_netaddr} -j ${str_net}_POST"
			fi
		;;
		nat)
			arr_stage1[${#arr_stage1[@]}]="PREROUTING -s ${str_netaddr} -j ${str_net}_PRE"
			arr_stage1[${#arr_stage1[@]}]="PREROUTING -d ${str_netaddr} -j ${str_net}_PRE"
			arr_stage1[${#arr_stage1[@]}]="POSTROUTING -s ${str_netaddr} -j ${str_net}_POST"
			arr_stage1[${#arr_stage1[@]}]="POSTROUTING -d ${str_netaddr} -j ${str_net}_POST"
			if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
				str_clist="src:OUTPUT_${str_net_iface}:OUTPUT"
				if ! lsearch "${str_net_iface}" ${str_if_done_list}; then
					str_cilist="src:OUTPUT:OUTPUT_${str_net_iface}"
					str_if_done_list+=" ${str_net_iface}"
				fi
			else
				str_clist="src:OUTPUT:OUTPUT"
			fi
		;;
		filter|security)
			if ((multi_bound == 1 && JUMP_TREE[3] == 0)); then
				arr_stage1[${#arr_stage1[@]}]="INPUT_${str_net_iface} -i ${str_net_iface} -d ${str_netaddr} -j ${str_net}_INPUT"
				arr_stage1[${#arr_stage1[@]}]="OUTPUT_${str_net_iface} -o ${str_net_iface} -s ${str_netaddr} -j ${str_net}_OUTPUT"
				if ! lsearch "${str_net_iface}" ${str_if_done_list}; then
					arr_stage2[${#arr_stage2[@]}]="INPUT -i ${str_net_iface} -j INPUT_${str_net_iface}"
					arr_stage2[${#arr_stage2[@]}]="OUTPUT -o ${str_net_iface} -j OUTPUT_${str_net_iface}"
				fi
				if ((PROC_IP_FORWARD == 1)); then
					for str_onet in ${LOC_NETNAME_LIST/${str_net}/}; do
						str_onetaddr=$(get_net_addr ${str_onet})
						if [[ -z ${str_onetaddr} ]]; then
							log -E "Unable to retrieve data of network \`${str_onet}'."
							raise_gen_err_count
							return $ER_FAIL
						fi
						str_onetiface=$(get_net_iface ${str_onet})
						[[ ${str_net_iface} = ${str_onetiface} ]] && continue
						arr_stage1[${#arr_stage1[@]}]="${str_net_iface}${IF_CON}${str_onetiface} -s ${str_netaddr} -d ${str_onetaddr} -j ${str_net}_${str_onet}"
					done
					if ! lsearch "${str_net_iface}" ${str_if_done_list}; then
						for str_onetiface in ${NET_IFLIST/${str_net_iface}/}; do
							arr_stage2[${#arr_stage2[@]}]="FORWARD -i ${str_net_iface} -o ${str_onetiface} -j ${str_net_iface}${IF_CON}${str_onetiface}"
						done
					fi
					arr_stage1[${#arr_stage1[@]}]="FWD_IN_${str_net_iface} -i ${str_net_iface} -s ${str_netaddr} -j ${str_net}_FWD_OUT"
					arr_stage1[${#arr_stage1[@]}]="FWD_OUT_${str_net_iface} -o ${str_net_iface} -d ${str_netaddr} -j ${str_net}_FWD_IN"
					if ! lsearch "${str_net_iface}" ${str_if_done_list}; then
						arr_stage3[${#arr_stage3[@]}]="FORWARD -i ${str_net_iface} -j FWD_IN_${str_net_iface}"
						arr_stage3[${#arr_stage3[@]}]="FORWARD -o ${str_net_iface} -j FWD_OUT_${str_net_iface}"
					fi
				fi
				lsearch "${str_net_iface}" ${str_if_done_list} || str_if_done_list+=" ${str_net_iface}"
			else
				if ((JUMP_TREE[3] == 1)); then
					arr_stage2[${#arr_stage2[@]}]="INPUT -d ${str_netaddr} -j ${str_net}_INPUT"
					arr_stage2[${#arr_stage2[@]}]="OUTPUT -s ${str_netaddr} -j ${str_net}_OUTPUT"
				else
					arr_stage2[${#arr_stage2[@]}]="INPUT -i ${str_net_iface} -d ${str_netaddr} -j ${str_net}_INPUT"
					arr_stage2[${#arr_stage2[@]}]="OUTPUT -o ${str_net_iface} -s ${str_netaddr} -j ${str_net}_OUTPUT"
				fi
				if ((PROC_IP_FORWARD == 1)); then
					for str_onet in ${LOC_NETNAME_LIST/${str_net}/}; do
						str_onetaddr=$(get_net_addr ${str_onet})
						if [[ -z ${str_onetaddr} ]]; then
							log -E "Unable to retrieve data of network \`${str_onet}'."
							raise_gen_err_count
							return $ER_FAIL
						fi
						str_onetiface=$(get_net_iface ${str_onet})
						[[ ${str_net_iface} = ${str_onetiface} ]] && continue
						if ((JUMP_TREE[3] == 1)); then
							arr_stage2[${#arr_stage2[@]}]="FORWARD -s ${str_netaddr} -d ${str_onetaddr} -j ${str_net}_${str_onet}"
						else
							arr_stage2[${#arr_stage2[@]}]="FORWARD -i ${str_net_iface} -o ${str_onetiface} -s ${str_netaddr} -d ${str_onetaddr} -j ${str_net}_${str_onet}"
						fi
					done
					if ((JUMP_TREE[3] == 1)); then
						arr_stage4[${#arr_stage4[@]}]="FORWARD -s ${str_netaddr} -j ${str_net}_FWD_OUT"
						arr_stage4[${#arr_stage4[@]}]="FORWARD -d ${str_netaddr} -j ${str_net}_FWD_IN"
					else
						arr_stage4[${#arr_stage4[@]}]="FORWARD -i ${str_net_iface} -s ${str_netaddr} -j ${str_net}_FWD_OUT"
						arr_stage4[${#arr_stage4[@]}]="FORWARD -o ${str_net_iface} -d ${str_netaddr} -j ${str_net}_FWD_IN"
					fi
				fi
			fi
		;;
	esac
	for str in ${str_clist}; do
		set -- ${str//:/ }
		local str_param="$1" str_chn="$2" str_tgt="$3" str_i str_p
		case "${str_param}" in
			src) str_p="-s" str_i="-o" ;;
			dst) str_p="-d" str_i="-i" ;;
			*) log -o "${str_param}" $FUNCNAME; continue ;;
		esac
		if ((JUMP_TREE[3] == 1)); then
			arr_stage2[${#arr_stage2[@]}]="${str_chn} ${str_p} ${str_netaddr} -j ${str_net}_${str_tgt}"
		else
			arr_stage2[${#arr_stage2[@]}]="${str_chn} ${str_i} ${str_net_iface} ${str_p} ${str_netaddr} -j ${str_net}_${str_tgt}"
		fi
	done
	for str in ${str_cilist}; do
		set -- ${str//:/ }
		local str_param="$1" str_chn="$2" str_tgt="$3" str_i
		case "${str_param}" in
			src) str_i="-o" ;;
			dst) str_i="-i" ;;
			*) log -o "${str_param}" $FUNCNAME; continue ;;
		esac
		arr_stage1[${#arr_stage1[@]}]="${str_chn} ${str_i} ${str_net_iface} -j ${str_tgt}"
	done
done
for ((idx=1; idx<=5; ++idx)); do # five stages of classification
	arr_populated "arr_stage${idx}" || continue
	for ridx in $(arr_indicies "arr_stage${idx}"); do # create log messages and add_rule commands
		str_jmsg=$(eval 'printf "%s\n" "${arr_stage'${idx}'[ridx]}"')
		[[ ${str_jmsg} ]] || continue # should not be
		str_jmsg="${str_jmsg/'! -i '/idev=!}"
		str_jmsg="${str_jmsg/'! -o '/odev=!}"
		str_jmsg="${str_jmsg/-i /idev=}"
		str_jmsg="${str_jmsg/-o /odev=}"
		str_jmsg="${str_jmsg/-s /src=}"
		str_jmsg="${str_jmsg/-d /dst=}"
		str_jmsg="${str_jmsg/-j /target=}"
		str_tgt="${str_jmsg#*target=}"
		set -- ${str_jmsg}
		str_chn=$1
		shift
		str_jmsg=${*}
		for i in ${!CREATED_CHAINS_ARRAY[@]}; do
			set -- ${CREATED_CHAINS_ARRAY[i]}
			if [[ $1 = ${str_tbl} && $2 = ${str_tgt} ]]; then
				log -e "${PF}jump table=${str_tbl} chain=${str_chn} ${str_jmsg}"
				eval 'add_rule ${str_tbl} ${arr_stage'${idx}'[ridx]}'
				break
			fi
		done
	done
done
} # -------------------------------------------------------------------------

create_custom_chains() { # CREATE CUSTOM CHAINS
local -i idx
local str_tbl str_chn
[[ ${CHAIN_MAP} ]] || {
	log -v 'CHAIN_MAP'
	return 0
}
log -I "Creating custom chains"
fill_array 'CHAIN_MAP'
((${#CHAIN_MAP[@]})) || return 0
# check for unique rows in CHAIN_MAP
check_array_unique 'CHAIN_MAP' || {
	raise_cfg_err_count
	return $ER_FAIL
}
for idx in ${!CHAIN_MAP[@]}; do
	set -- ${CHAIN_MAP[idx]}
	str_tbl="$1"
	shift
	val_table "${str_tbl}" || {
		raise_cfg_err_count
		continue
	}
	for str_chn in "$@"; do
		val_userdef_chain_target "${str_chn}" || {
			raise_cfg_err_count
			continue
		}
	done
	(($(subst_var "ENABLE_$(string_toupper "${str_tbl}")") == 1)) || continue
	for str_chn in "$@"; do
		create_chain "${str_tbl}" "${str_chn}"
	done
done
} # -------------------------------------------------------------------------

create_mandatory_chains() { # create mandatory chains
((ENABLE_FILTER)) || return 0
log -I "Creating mandatory chains"
if ((BLOCK_ILLEGAL || LOG_ILLEGAL)); then # bad packets
	log -N "Creating bad TCP packets chain: ${BIC_BAD_TCP_PACKETS}"
	create_chain filter ${BIC_BAD_TCP_PACKETS}
fi
global_invalid_chain
global_broadcasts_chain
} # -------------------------------------------------------------------------

classification_chains() {
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
[[ ${JUMP_TREE[1]} = none || -z ${JUMP_TREE[2]} ]] && return 0
local str_act="$1" str_ctbl="$2"
local str_err="\`${str_ctbl}' table is not present on local system, unable to create classifying ${str_act} for this table."
lsearch "${str_ctbl}" ${JUMP_TREE[2]} || return 0
case "${str_ctbl}" in
	raw)
		((ENABLE_RAW)) || return 0
		if ! ((RAW_TABLE_PRESENT == 1)); then
			log -E "${str_err}"
			raise_cfg_err_count
			return 0
		fi
	;;
	rawpost)
		((ENABLE_RAWPOST)) || return 0
		if ! ((RAWPOST_TABLE_PRESENT == 1)); then
			log -W "${str_err}"
			return 0
		fi
	;;
	security)
		((ENABLE_SECURITY)) || return 0
		if ! ((SECURITY_TABLE_PRESENT == 1)); then
			log -W "${str_err}"
			return 0
		fi
	;;
	mangle)
		((ENABLE_TC_SHAPING == 0 && ENABLE_MANGLE == 0)) && return 0
	;;
	nat)
		((ENABLE_NAT)) || return 0
	;;
	filter)
		((ENABLE_FILTER)) || return 0
	;;
	*) log -o "${str_ctbl}" $FUNCNAME
		return 1
esac
[[ ${str_act} = @(chains|jumps) ]] || {
	log -o "${str_act}" $FUNCNAME
	raise_gen_err_count
	return 1
}
case "${JUMP_TREE[1]}" in
	interface)
		case "${str_act}" in
			chains)
				if ((JUMP_TREE_CHAINS_CREATE_ALL == 1)); then
					iface_chains ${str_ctbl} || return 1
				fi
			;;
			jumps) iface_jumps ${str_ctbl} || return 1 ;;
		esac
	;;
	netname|netname+interface)
		case "${str_act}" in
			chains)
				if ((JUMP_TREE_CHAINS_CREATE_ALL == 1)); then
					create_netname_chains ${str_ctbl} || return 1
				fi
			;;
			jumps) create_netname_jumps ${str_ctbl} || return 1 ;;
		esac
	;;
	*) log -o "${JUMP_TREE}" $FUNCNAME
		return 1
esac
} # -------------------------------------------------------------------------

create_jump_tree() { # create all jump tree chains or jumps
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
case "$1" in
	chains|jumps) : ;;
	*) log -o "$1" $FUNCNAME || return 1
esac
for rvar in raw rawpost mangle nat filter security ; do
	classification_chains $1 $rvar || return
done
} # -------------------------------------------------------------------------

all_chains_creation() {
create_jump_tree 'chains' || return
create_mandatory_chains || return
create_custom_chains || return
} # -------------------------------------------------------------------------

#list_count_chain() {
#local -i cidx=0
#while read; do
#	let cidx+=1
#done < <(run_ipt -nL "$1" 2>/dev/null)
#printf "%s\n" "${cidx}"
#} # -------------------------------------------------------------------------

delete_empty_chains() {
local -i max_count=15 run_count=0
log -N "Removing empty chains in ${1:-filter} table"
while ((${?} == 0 && run_count <= max_count)); do
	let run_count+=1
	_delete_empty_chains $1
done
} # -------------------------------------------------------------------------

_delete_empty_chains() {
local -i lim=1 idx=0
local -a empty_chains cmd_arr cmd_arr_ref
local c str_chain str_target rest str_Ochain rnum
local str_tbl="${1:-filter}"
dn run_ipt -nL -t ${str_tbl} || {
	log -f "listing \`${str_tbl}' table."
	return 0
}
while read c str_chain rest; do
	if [[ $c = Chain ]]; then
		idx=0
		str_Ochain=${str_chain}
	else
		if ((idx++ == lim)) && [[ -z $c && ${str_Ochain} != @(@(IN|OUT)PUT|FORWARD|@(PRE|POST)ROUTING) ]]; then
			log -w "${PF}found empty chain: \`${str_Ochain}'"
			empty_chains[${#empty_chains[@]}]="${str_Ochain}"
		fi
	fi
done < <(run_ipt -nL -t ${str_tbl} 2>/dev/null)
if ((idx == lim)) && [[ ${str_Ochain} != @(@(IN|OUT)PUT|FORWARD|@(PRE|POST)ROUTING) ]]; then # last chain to display could be empty
	log -w "${PF}found empty chain: \`${str_Ochain}'"
	empty_chains[${#empty_chains[@]}]="${str_Ochain}"
fi
str_Ochain=""
while read rnum str_target rest; do
	((${#empty_chains[@]} > 0 )) || break
	if [[ ${rnum} = Chain ]]; then
		str_Ochain=$str_target
		continue
	fi
	[[ ${rnum} != +([[:digit:]]) ]] && continue
	[[ ${str_Ochain} ]] || { log -U $FUNCNAME; return 1; }
	for idx in ${!empty_chains[@]}; do
		if [[ ${empty_chains[idx]} = $str_target ]]; then
			log -e "${PF}deleting table=${str_tbl} chain=${str_Ochain} rule-number=${rnum} target=$str_target"
			cmd_arr[${#cmd_arr[@]}]="'${IPT}' -t ${str_tbl} -D '${str_Ochain}' ${rnum}"
			break
		fi
	done
done < <(run_ipt -nL --line-numbers -t ${str_tbl} 2>/dev/null)
if ((${#empty_chains[@]})); then
	for idx in ${!empty_chains[@]}; do
		log -e "${PF}deleting table=${str_tbl} chain=${empty_chains[idx]}"
		cmd_arr_ref[${#cmd_arr_ref[@]}]="'${IPT}' -t ${str_tbl} -X '${empty_chains[idx]}'"
	done
else
	return 1
fi
for idx in $(seq $(last_arr_member cmd_arr) -1 0); do
	eval "${cmd_arr[idx]}" &>/dev/null || cmd_err_count ipt "${cmd_arr[idx]}"
done
for idx in ${!cmd_arr_ref[@]}; do
	eval "${cmd_arr_ref[idx]}" &>/dev/null || cmd_err_count ipt "${cmd_arr_ref[idx]}"
done
return 0
} # -------------------------------------------------------------------------

delete_unreferenced_chains() {
local str_tbl="${1:-filter}" c str_chain rest
log -N "Removing unreferenced chains in ${str_tbl} table"
dn run_ipt -nL -t ${str_tbl} || {
	log -f "listing \`${str_tbl}' table."
	return 0
}
while read c str_chain rest; do
	if [[ $c = Chain ]]; then
		if [[ ${rest} = "(0 references)" ]]; then
			log -e "removing table=${str_tbl} chain=${str_chain}"
			dn run_ipt -t ${str_tbl} -F "${str_chain}" || {
				cmd_err_count ipt "${IPT} -t ${str_tbl} -F ${str_chain}"
			}
			dn run_ipt -t ${str_tbl} -X "${str_chain}" || {
				cmd_err_count ipt "${IPT} -t ${str_tbl} -X ${str_chain}"
			}
		fi
	fi
done < <(run_ipt -t ${str_tbl} -nL 2>/dev/null)
return 0
} # -------------------------------------------------------------------------

check_ipt_rule_list_param() { # check if '-S' switch is available within iptables
dn run_ipt -S || IPT_RULE_LIST_PARAM="-nL"
} # -------------------------------------------------------------------------

save_for_diff() { # save output of iptables -nL, to be compared to the currently active ruleset
local str_tbl="${1:-filter}"
log -w "${PF}saving $str_tbl"
run_ipt -t $str_tbl "$IPT_RULE_LIST_PARAM" >"${SAVE_DIR}/${DIFF_FILE}_${str_tbl}" || {
	cmd_err_count ipt "$IPT -t $str_tbl $IPT_RULE_LIST_PARAM >${SAVE_DIR}/${DIFF_FILE}_${str_tbl}"
	return 0
}
} # -------------------------------------------------------------------------

diff_ruleset() {
local str_tbl="${1:-filter}"
local str_dfile="${SAVE_DIR}/${DIFF_FILE}_${str_tbl}" tmp_dfile="${SAVE_DIR}/tmp_diff_${RANDOM}${RANDOM}"
[[ -r $str_dfile ]] || {
	log -E "\`${str_dfile}' does not exist, or is not readable."
	return 0
}
run_ipt -t $str_tbl "$IPT_RULE_LIST_PARAM" >"$tmp_dfile" || {
	log -F "saving $str_tbl table ruleset to: \`${tmp_dfile}'"
	cmd_err_count ipt "$IPT -t $str_tbl $IPT_RULE_LIST_PARAM >$tmp_dfile"
	return 0
}
if dn "$DIFF" "$tmp_dfile" "$str_dfile"; then
	printf "%s\n %s\n" "Active iptables ruleset of $str_tbl table is the same as the one saved to:" "\`${str_dfile}'"
	log -l "Active iptables ruleset of $str_tbl table is the same as the one saved to: \`${str_dfile}'"
else
	printf "%s\n %s\n" "WARNING: Active iptables ruleset of $str_tbl table differs from the one saved to:" "\`${str_dfile}'"
	log -l "WARNING: Active iptables ruleset of $str_tbl table differs from the one saved to: \`${str_dfile}'"
fi
run_rm "$tmp_dfile" || {
	log -F "removing \`${tmp_dfile}'"
	cmd_err_count 'misc' "$RM" -f "$tmp_dfile"
	return 0
}
} # -------------------------------------------------------------------------

fail_lockdown() {
dn set_default_policies_immediate
dn flushdel_tables_immediate
allow_admin_connection
dn allow_loopback_immediate
} # -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# TEMPLATES
# -------------------------------------------------------------------------

_load_another_ipt_template() {
# use the data of an iptables template, referenced from another template
local -i tmp_arr_idx
local -a tmp_template_arr tmp_tgt_arr tmp_chn_arr tmp_state_arr tmp_opt0_arr tmp_opt1_arr tmp_aluse0_arr tmp_aluse1_arr tmp_loadtmpl_arr
local tmp_templ_ass tmp_templ_val tmp_man_var0 tmp_man_var1 template_to_load="$1" # The name of the template to load

# copy the template array to a temporary array
$($copy_array "${template_to_load}" 'tmp_template_arr')
# cycle through the template array data, look for known values.
# if found and option is a 'normal' variable, set it immediately,
# if option is an array variable, copy data to temp array,
# to insert it into the according target array, after collecting all the data
for tmp_arr_idx in ${!tmp_template_arr[@]}; do
	tmp_templ_ass="${tmp_template_arr[tmp_arr_idx]%%=*}"
	tmp_templ_val="${tmp_template_arr[tmp_arr_idx]#*=}"
	case "${tmp_templ_ass}" in
		template_msg)
			log -E "\`template_msg' is not allowed in \`load_template'."
			raise_cfg_err_count
			return $ER_CONF
		;;
		table|reverse_mode|reverse_condition)
			# check if referencing template has such a record, if yes, don't use the template data
			if var_defined_silent "${tmp_templ_ass}"; then
				log -W "${tmp_templ_ass} is defined in referencing template, \
					not using value from: ${load_template[opt_idx]}"
			else
				eval ${tmp_templ_ass}'="'"${tmp_templ_val}"'"'
			fi
		;;
		@(target\[+([[:digit:]])\]))
			tmp_tgt_arr[${#tmp_tgt_arr[@]}]="${tmp_templ_val}"
		;;
		@(chain\[[[:digit:]]\]))
			tmp_chn_arr[${#tmp_chn_arr[@]}]="${tmp_templ_val}"
		;;
		@(mandatory_vars\[0\]))
			mandatory_vars[0]+=",${tmp_templ_val}"
		;;
		@(mandatory_vars\[1\]))
			mandatory_vars[1]+=",${tmp_templ_val}"
		;;
		@(state_match_arg\[0\]))
			if [[ ${state_match_arg[0]} ]]; then
				state_match_arg[0]+=",${tmp_templ_val}"
			else
				state_match_arg[0]="${tmp_templ_val}"
			fi
		;;
		@(state_match_arg\[1\]))
			if [[ ${state_match_arg[1]} ]]; then
				state_match_arg[1]+=",${tmp_templ_val}"
			else
				state_match_arg[1]="${tmp_templ_val}"
			fi
		;;
		@(option_list_0\[+([[:digit:]])\]))
			tmp_opt0_arr[${#tmp_opt0_arr[@]}]="${tmp_templ_val}"
		;;
		@(option_list_1\[+([[:digit:]])\]))
			tmp_opt1_arr[${#tmp_opt1_arr[@]}]="${tmp_templ_val}"
		;;
		@(always_use_0\[+([[:digit:]])\]))
			tmp_aluse0_arr[${#tmp_aluse0_arr[@]}]="${tmp_templ_val}"
		;;
		@(always_use_1\[+([[:digit:]])\]))
			tmp_aluse1_arr[${#tmp_aluse1_arr[@]}]="${tmp_templ_val}"
		;;
		@(load_template\[+([[:digit:]])\]))
			tmp_loadtmpl_arr[${#tmp_loadtmpl_arr[@]}]="${tmp_templ_val}"
		;;
	esac
done
((${#tmp_tgt_arr[@]})) && insert_array 'tmp_tgt_arr' 'target'
((${#tmp_chn_arr[@]})) && insert_array 'tmp_chn_arr' 'chain'
((${#tmp_opt0_arr[@]})) && insert_array 'tmp_opt0_arr' 'option_list_0'
((${#tmp_opt1_arr[@]})) && insert_array 'tmp_opt1_arr' 'option_list_1'
((${#tmp_aluse0_arr[@]})) && insert_array 'tmp_aluse0_arr' 'always_use_0'
((${#tmp_aluse1_arr[@]})) && insert_array 'tmp_aluse1_arr' 'always_use_1'
if ((${#tmp_loadtmpl_arr[@]})); then
	for ((tmp_arr_idx=$(last_arr_member tmp_loadtmpl_arr); tmp_arr_idx>=0; --tmp_arr_idx)); do
		_load_another_ipt_template "${tmp_loadtmpl_arr[tmp_arr_idx]}" || return
	done
fi
return 0
} # -------------------------------------------------------------------------

blacklist_template() {
#[[ $1 = @(TEMPLATE_TEMP_QUICKRULE|TEMPLATE_TEMP_C_RULE) ]] && return 0
[[ $1 = @(TEMPLATE_TEMP_@(QUICKRULE|C_RULE)) ]] && return 0
BLACKLISTED_TEMPLATES[${#BLACKLISTED_TEMPLATES[@]}]="$1"
} # -------------------------------------------------------------------------

validate_generate_final_templates() {
# validate the data read from the xml templates
# resolve nested templates and compile final bash array templates
# writing the result to fd 7
local -i t_idx opt_idx m_count arr_last

for t_idx in ${!TEMP_TEMPLATE_NAMES_ARRAY[@]}; do
	# variables which will be set by referencing the template
	local table="" template_msg="" reverse_mode="" reverse_condition=""
	local -a target=() chain=() state_match_arg=() mandatory_vars=() option_list_0=() option_list_1=() always_use_0=() always_use_1=() load_template=()

	# check for valid template name
	[[ ${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]} = @(@(?(B|G)T|?(BASE|GLOBAL)_TEMPLATE_)+([[:word:]])) ]] || {
		log -E "Invalid template name \`${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]}'. \
			Template names must contain any of the following prefixes: \`T_ | BT_ | GT_ | TEMPLATE_ | BASE_TEMPLATE_ | GLOBAL_TEMPLATE_'"
		raise_cfg_err_count
		continue
	}
	# check if template array contains members
	arr_populated "${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]}" || {
		log -E "Template \`${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]}' is not defined."
		raise_cfg_err_count
		continue
	}
	# indirect reference to the ruleblock template
	log -e "${PF}processing template: ${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]}"
	local reference_catalog_data="${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]}[@]"
#	local "${!reference_catalog_data}" &>/dev/null || {
	eval local "${!reference_catalog_data}" &>/dev/null || {
		log -E "Failed referencing Template: \`${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]}'."
		raise_gen_err_count
		continue
	}
	# load other templates
	if ((${#load_template[@]})); then
		for ((opt_idx=$(last_arr_member load_template); opt_idx>=0; --opt_idx)); do
			_load_another_ipt_template "${load_template[opt_idx]}" || return 1
		done
	fi

	# check if there is at least one option list provided in the template
	if ((${#option_list_0[@]})); then
		check_array_unique_assignement 'option_list_0' || {
			raise_cfg_err_count
			continue
		}
	else
		[[ ${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]} != @(BT|BASE_TEMPLATE)_* ]] && {
			log -W "No option_list_0 specified in template \`${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]}'."
#			raise_cfg_err_count
#			return 1
		}

		((${#option_list_1[@]})) && {
			log -E "\`option_list_1' has members but \`option_list_0' is empty."
			raise_cfg_err_count
			continue
		}
	fi
	if ((${#option_list_0[@]} && ${#option_list_1[@]})) ; then
		((${#option_list_0[@]} == ${#option_list_1[@]})) || {
			log -W "Mismatch in amount of option list members in template \`${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]}'. \
				option_list_0: ${#option_list_0[@]} option_list_1: ${#option_list_1[@]}"
		}
	fi

	# check if we have an iptables table definition in template.
	if [[ $table ]]; then
		val_table "$table" || {
			log -E "Invalid table specification in template \`${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]}'."
			raise_cfg_err_count
			continue
		}
	fi

	# look for target definitions in the template. If found validate the provided data.
	if ((${#target[@]})); then
		check_array_unique 'target' || {
			raise_cfg_err_count
			continue
		}
		for opt_idx in ${!target[@]}; do
			validate_target "${target[opt_idx]}" || {
				log -E "Invalid target specification in template \`${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]}'."
				raise_cfg_err_count
				continue 2
			}
		done
	fi

	# look for chain defintions in the template. If found validate the provided data.
	if ((${#chain[@]})); then
		if [[ ${reverse_mode} = @(reverse|mirror) ]]; then
			# Only two chain specifications are allowed
			(($(last_arr_member 'chain') > 1)) && {
				log -E "With \`reverse_mode' enabled, only two chain specifications are allowed."
				raise_cfg_err_count
				continue
			}
		fi
		check_array_unique 'chain' || {
			raise_cfg_err_count
			continue
		}
		for opt_idx in ${!chain[@]}; do
			val_userdef_chain_target "${chain[opt_idx]}" || {
				log -E "Invalid chain specification in template \`${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]}'."
				raise_cfg_err_count
				continue 2
			}
		done
	fi

	# look for state match definitions in the template. If found, validate the provided data.
	# index [0] refers to chain[0] and index [1] to chain[1].
	if ((${#state_match_arg[@]})); then
		# Only two state match specifications are allowed
		(($(last_arr_member 'state_match_arg') > 1)) && {
			log -E "Not more than two state match specification strings allowed."
			raise_cfg_err_count
			continue
		}
		for opt_idx in ${!state_match_arg[@]}; do
			val_state "${state_match_arg[opt_idx]}" || {
				log -E "Invalid state match specification in template \`${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]}'."
				raise_cfg_err_count
				continue 2
			}
		done
	fi

	# look for mandatory options defintions in the template. If found validate the provided data.
	if ((${#mandatory_vars[@]})); then
		# Only two mandatory options specifications are allowed
		(($(last_arr_member 'mandatory_vars') > 1)) && {
			log -E "Not more than two mandatory option specification strings allowed."
			raise_cfg_err_count
			continue
		}
		# check for duplicate entries in 'mandatory_vars'
		for opt_idx in ${!mandatory_vars[@]}; do
#			check_str_unique "$(IFS=, split_val ${mandatory_vars[opt_idx]})" || {
			check_str_unique "${mandatory_vars[opt_idx]//,/ }" || {
				log -E "Duplicate option name in \`mandatory_vars'."
				raise_cfg_err_count
				continue 2
			}
		done
	fi

	# if template provides the reverse_mode option, see if reverse mode is 'reverse' or 'mirror'
	if [[ ${reverse_mode} ]]; then
		case "$(string_tolower "${reverse_mode}")" in
			reverse) # option is reverse, check for valid option_list_1 
				if ((${#option_list_1[@]})); then
					check_array_unique_assignement 'option_list_1' || {
						raise_cfg_err_count
						continue
					}
				else
					[[ ${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]} != @(BT|BASE_TEMPLATE)_* ]] && {
						log -E "\`reverse_mode' is \`reverse', but \`option_list_1' is emtpy."
						raise_cfg_err_count
						continue
					}
				fi
			;;
			mirror) : ;;
			*) log -i "${reverse_mode}" 'reverse_mode'
				raise_cfg_err_count
				continue
			;;
		esac
	fi
	if [[ ${reverse_condition} ]]; then
		if [[ -z ${reverse_mode} ]]; then
			[[ ${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]} != @(BT|BASE_TEMPLATE)_* ]] && {
				log -E "\`reverse_condition' is set, but \`reverse_mode' is not."
				raise_cfg_err_count
				continue
			}
		fi
		[[ ${reverse_condition} = +([[:word:]]):* ]] || {
			log -i "${reverse_condition}" "reverse_condition descriptor"
				raise_cfg_err_count
				continue
			}
	fi

	# always_use options
	((${#always_use_0[@]})) && {
		check_array_unique_assignement 'always_use_0' || {
			raise_cfg_err_count
			continue
		}
	}
	if ((${#always_use_1[@]})); then
		((${#always_use_0[@]})) || {
			log -E "\' always_use_1' has members, but \`always_use_0' is empty."
			raise_cfg_err_count
			continue
		}
		check_array_unique_assignement 'always_use_1' || {
			raise_cfg_err_count
			continue
		}
	fi
	if ((${#always_use_0[@]} && ${#always_use_1[@]})) ; then
		((${#always_use_0[@]} == ${#always_use_1[@]})) || {
			log -W "Mismatch in amount of always_use list members in template \`${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]}'. \
				always_use_0: ${#always_use_0[@]} always_use_1: ${#always_use_1[@]}"
		}
	fi

	# open array
	m_count=0
	pr_str "${TEMP_TEMPLATE_NAMES_ARRAY[t_idx]}=(" >&7
	# assign string type values
	for rvar in table reverse_mode reverse_condition template_msg; do
		if [[ ${!rvar} ]]; then
			if [[ ${!rvar} = *[[:space:]]* ]]; then
				printf "[%d]=\"%s=%s\"\n" $((m_count++)) "$rvar" "\\\"${!rvar}\\\"" >&7
			else
				printf "[%d]=\"%s=%s\"\n" $((m_count++)) "$rvar" "${!rvar}" >&7
			fi
		fi
	done
	# assign array type values
	for rvar in target chain option_list_0 option_list_1 always_use_0 always_use_1 state_match_arg mandatory_vars
	do
		if [[ ${!rvar} ]]; then
			arr_last=$(last_arr_member $rvar)
			for ((opt_idx=0; opt_idx<=arr_last; ++opt_idx)); do
				if eval '[[ ${'$rvar'[opt_idx]} = *[[:space:]]* ]]'
				then
					eval 'printf "%s\n" "['$((m_count++))']="\"'$rvar'['${opt_idx}']="\\\"${'$rvar'[opt_idx]}\\\""\"' >&7
				else
					eval 'printf "%s\n" "['$((m_count++))']="\"'$rvar'['${opt_idx}']="${'$rvar'[opt_idx]}"\"' >&7
				fi
			done
		fi
	done
	# close array
	pr_str ")" >&7
done
} # -------------------------------------------------------------------------

dump_arr() {
while read; do
	printf "%s=(\n" "$REPLY"
	for i in $(arr_indicies "$REPLY"); do
#		eval 'printf "['$i']=\"%s\"\n" "${'"$REPLY"'['$i']}"'
		eval 'printf "[$i]='\''%s'\''\n" "${'"$REPLY"'['$i']}"'
	done
	printf ")\n"
done
} # -------------------------------------------------------------------------

load_ipt_templates() {
# - parse iptables xml ruleblock templates (if needed)
# - transform the templates into bash arrays
# - do template sanity checks
# - load nested templates
# - compile final bash arrays templates
# - source compiled file
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local template_file="${TEMPLATE_DIR}/${1}" parsed_file="${TEMPLATE_DIR}/__parsed_${1%.xml}.bash"
local -i parse_files=${PARSE_TEMPLATES}
local -a TEMP_TEMPLATE_NAMES_ARRAY
[[ -r $template_file ]] || {
	log -x "$template_file"
	return $ER_NOEX
}
if [[ -r $parsed_file ]]; then
	if ((parse_files == 0)); then
		log -N "Parsed template file \`$parsed_file' already exists, using existing file."
	fi
else
    parse_files=1
fi
if ((parse_files == 1)); then
	log -N "Parsing XML template file: \`$template_file'"
	if ! ((EXEC_COMMANDS)); then
		mutex_on || return
	fi
	if [[ -e $parsed_file ]]; then
		run_rm "$parsed_file" || {
			log -F "removing old parsed file \`$parsed_file'."
			return $ER_FAIL
		}
	fi
	exec 7> "$parsed_file"
	xml_parser 'templates' < "$template_file" || {
		exec 7>&-
		[[ -e $parsed_file ]] && run_rm "$parsed_file"
		log -E "Failed parsing templates file: \`$template_file'"
		return $ER_LOAD
	}
	exec 7>&-
	source "$parsed_file"
	run_rm "$parsed_file"
	exec 7> "$parsed_file"
	printf '#!%s\n\n' "$SHELL" >&7
	validate_generate_final_templates || {
		exec 7>&-
		[[ -e $parsed_file ]] && run_rm "$parsed_file"
		log -E "Failed parsing templates file: \`$template_file'"
		return $ER_LOAD
	}
	exec 7>&-
	[[ $DEBUG_INFO ]] && dbg_arr "TEMP_TEMPLATE_NAMES_ARRAY"
	log -e "${PF}generated ${#TEMP_TEMPLATE_NAMES_ARRAY[@]} templates"
	log -w "Saved parsed template file to: \`$parsed_file'"
	if ! ((EXEC_COMMANDS)); then
		cleanup_lock
	fi
fi
load_file config "$parsed_file" || return $ER_LOAD
if ((${#TEMP_TEMPLATE_NAMES_ARRAY[@]})); then # dump generated templates to stdout
	if lsearch templates ${cmdline_show_conf}; then
		pr_banner "Starting dump of generated templates:"
		for idx in ${!TEMP_TEMPLATE_NAMES_ARRAY[@]}; do
			printf "%s=(\n" "${TEMP_TEMPLATE_NAMES_ARRAY[idx]}"
			for i in $(arr_indicies "${TEMP_TEMPLATE_NAMES_ARRAY[idx]}"); do
				eval 'printf "['${i}']=\"%s\"\n" "${'"${TEMP_TEMPLATE_NAMES_ARRAY[idx]}"'['${i}']}"'
			done
			printf ")\n"
		done
		pr_banner "End of template dump."
	fi
	# save template names for usage in show mode
	printf '%s\n' "${TEMP_TEMPLATE_NAMES_ARRAY[@]}" >> "${TEMPLATE_DIR}/__parsed_TEMPLATE_NAMES"
fi
} # -------------------------------------------------------------------------

load_base_templates() { # load ipt base templates
for rvar in ${BASE_TEMPLATES}; do
	load_ipt_templates "$rvar" || return
done
} # -------------------------------------------------------------------------

load_ipt_filter_templates() { # load ipt filter templates
if ((ENABLE_FILTER)); then
	for rvar in ${IPT_FILTER_TEMPLATES}; do
		load_ipt_templates "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_ipt_security_templates() { # load ipt security templates
if ((ENABLE_SECURITY)); then
	for rvar in ${IPT_SECURITY_TEMPLATES}; do
		load_ipt_templates "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_ipt_mangle_templates() { # load ipt mangle templates
if ((ENABLE_MANGLE || ENABLE_TC_SHAPING)); then
	for rvar in ${IPT_MANGLE_TEMPLATES}; do
		load_ipt_templates "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_ipt_nat_templates() { # load ipt nat templates
if ((ENABLE_NAT)); then
	for rvar in ${IPT_NAT_TEMPLATES}; do
		load_ipt_templates "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_ipt_raw_templates() { # load ipt raw templates
if ((ENABLE_RAW)); then
	for rvar in ${IPT_RAW_TEMPLATES}; do
		load_ipt_templates "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_ipt_rawpost_templates() { # load ipt rawpost templates
if ((ENABLE_RAWPOST)); then
	for rvar in ${IPT_RAWPOST_TEMPLATES}; do
		load_ipt_templates "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_all_templates() { # load all templates
load_base_templates || return
load_ipt_filter_templates || return
load_ipt_security_templates || return
load_ipt_mangle_templates || return
load_ipt_nat_templates || return
load_ipt_raw_templates || return
load_ipt_rawpost_templates || return
} # -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# RULEBLOCKS
# -------------------------------------------------------------------------

load_ruleblock_conf() {
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local ruleblock_file="${RULEBLOCK_DIR}/$1" parsed_file="${RULEBLOCK_DIR}/__parsed_${1%.xml}.bash"
local -i parse_files=${PARSE_RULEBLOCKS}
local -a TEMP_RULEBLOCK_NAMES_ARRAY
[[ -r $ruleblock_file ]] || {
	log -x "$ruleblock_file"
	return $ER_NOEX
}
if [[ -r $parsed_file ]]; then
	if ((parse_files == 0)); then
		log -N "Parsed ruleblock file \`$parsed_file' already exists, using existing file."
	fi
else
    parse_files=1
fi
if ((parse_files == 1)); then
	log -N "Parsing XML ruleblock file: \`$ruleblock_file'"
	if ! ((EXEC_COMMANDS)); then
		mutex_on || return
	fi
	if [[ -e $parsed_file ]]; then
		run_rm "$parsed_file" || {
			log -F "removing old parsed file \`$parsed_file'."
			return $ER_FAIL
		}
	fi
	exec 7> "$parsed_file"
	printf '#!%s\n\n' "$SHELL" >&7
	xml_parser 'ruleblocks' < "$ruleblock_file" || {
		exec 7>&-
		[[ -e $parsed_file ]] && run_rm "$parsed_file"
		log -E "Failed parsing ruleblock file: \`$ruleblock_file'"
		return $ER_LOAD
	}
	exec 7>&-
	[[ $DEBUG_INFO ]] && dbg_arr "TEMP_RULEBLOCK_NAMES_ARRAY"
	log -e "${PF}generated ${#TEMP_RULEBLOCK_NAMES_ARRAY[@]} ruleblocks"
	log -w "Saved parsed ruleblock file to: \`$parsed_file'"
	if ! ((EXEC_COMMANDS)); then
		cleanup_lock
	fi
fi

load_file config "$parsed_file" || return $ER_LOAD

if ((${#TEMP_RULEBLOCK_NAMES_ARRAY[@]})); then # dump generated ruleblocks to stdout
	if lsearch ruleblocks ${cmdline_show_conf}; then
		pr_banner "Starting dump of generated ruleblocks:"
		for idx in ${!TEMP_RULEBLOCK_NAMES_ARRAY[@]}; do
			printf "%s=(\n" "${TEMP_RULEBLOCK_NAMES_ARRAY[idx]}"
			for i in $(arr_indicies "${TEMP_RULEBLOCK_NAMES_ARRAY[idx]}"); do
				eval 'printf "['${i}']=\"%s\"\n" "${'"${TEMP_RULEBLOCK_NAMES_ARRAY[idx]}"'['${i}']}"'
			done
			printf ")\n"
		done
		pr_banner "End of ruleblock dump."
	fi
	# save ruleblock names for usage in show mode
	printf '%s\n' "${TEMP_RULEBLOCK_NAMES_ARRAY[@]}" >> "${RULEBLOCK_DIR}/__parsed_RULEBLOCK_NAMES"
fi
} # -------------------------------------------------------------------------

load_filter_ruleblocks() {
if ((ENABLE_FILTER)); then
	for rvar in ${FILTER_RULEBLOCKS}; do
		load_ruleblock_conf "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_security_ruleblocks() {
if ((ENABLE_SECURITY)); then
	for rvar in ${SECURITY_RULEBLOCKS}; do
		load_ruleblock_conf "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_mangle_ruleblocks() {
if ((ENABLE_MANGLE || ENABLE_TC_SHAPING)); then
	for rvar in ${MANGLE_RULEBLOCKS}; do
		load_ruleblock_conf "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_nat_ruleblocks() {
if ((ENABLE_NAT)); then
	for rvar in ${NAT_RULEBLOCKS}; do
		load_ruleblock_conf "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_raw_ruleblocks() {
if ((ENABLE_RAW)); then
	for rvar in ${RAW_RULEBLOCKS}; do
		load_ruleblock_conf "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_rawpost_ruleblocks() {
if ((ENABLE_RAWPOST)); then
	for rvar in ${RAWPOST_RULEBLOCKS}; do
		load_ruleblock_conf "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_all_ruleblocks() {
load_raw_ruleblocks || return
load_rawpost_ruleblocks || return
load_mangle_ruleblocks || return
load_tc_ruleblocks || return
load_tc_mangle_ruleblocks || return
load_nat_ruleblocks || return
load_filter_ruleblocks || return
} # -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# RULE FILES
# -------------------------------------------------------------------------

load_rule_file() {
# - parse iptables xml rule file (if needed)
# - transform the rules into a bash script
# - source compiled file
[[ $1 ]] || { reqparm $FUNCNAME 1; return 1; }
local rule_file="${RULE_DIR}/${1}" parsed_file="${RULE_DIR}/__parsed_${1%.xml}.bash"
local -i parse_files=${PARSE_RULEFILES}
[[ -r ${rule_file} ]] || {
	log -x "${rule_file}"
	return $ER_NOEX
}
if [[ -r $parsed_file ]]; then
	if ((parse_files == 0)); then
		log -N "Parsed rulefile \`$parsed_file' already exists, using existing file."
	fi
else
    parse_files=1
fi
if ((parse_files == 1)); then
	log -N "Parsing XML rule file: \`${rule_file}'"
	if ! ((EXEC_COMMANDS)); then
		mutex_on || return
	fi
	if [[ -e $parsed_file ]]; then
		run_rm "$parsed_file" || {
			log -F "removing old parsed file \`$parsed_file'."
			return $ER_FAIL
		}
	fi
	exec 7> "$parsed_file"
#	printf "%s\n\n" '#!/bin/bash' >&7
	printf '#!%s\n\n' "$SHELL" >&7
	xml_parser 'rules' < "${rule_file}" || {
		exec 7>&-
		[[ -e $parsed_file ]] && run_rm "$parsed_file"
		log -E "Failed parsing rule file: \`${rule_file}'"
		return $ER_LOAD
	}
	exec 7>&-
	log -w "Saved parsed rule file to: \`$parsed_file'"
	if ! ((EXEC_COMMANDS)); then
		cleanup_lock
	fi
fi
if [[ $MODE = SHOW ]]; then # dump rules in show mode
	if lsearch rules $cmdline_show_conf; then
		pr_banner "Starting rules dump from ${parsed_file##/*/}:"
		while read -r -t $GLOBAL_READ_TIMEOUT; do
			rvar="${REPLY%%#*}"
			[[ -z $rvar || $rvar = +([[:space:]]) ]] && continue
			printf '%s\n' "$REPLY"
		done < "$parsed_file"
		pr_banner "End of rules dump from ${parsed_file##/*/}"
	fi
elif [[ $MODE != PARSE-XML ]]; then # if we don't just parse, load rules
	load_file rule "$parsed_file" || return $ER_LOAD
fi
} # -------------------------------------------------------------------------

load_filter_rules() { # Load the filter table rule files
if ((ENABLE_FILTER)); then
	for rvar in ${FILTER_RULES}; do
		load_rule_file "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_security_rules() { # Load the security table rule files
if ((ENABLE_SECURITY)); then
	for rvar in ${SECURITY_RULES}; do
		load_rule_file "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_nat_rules() { # Load the nat table rule files
if ((ENABLE_NAT)); then
	for rvar in ${NAT_RULES}; do
		load_rule_file "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_mangle_rules() { # Load the mangle table rule files
if ((ENABLE_MANGLE)); then
	for rvar in ${MANGLE_RULES}; do
		load_rule_file "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_raw_rules() { # Load the raw table rule files
if ((ENABLE_RAW)); then
	for rvar in ${RAW_RULES}; do
		load_rule_file "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_rawpost_rules() { # Load the rawpost table rule files
if ((ENABLE_RAWPOST)); then
	for rvar in ${RAWPOST_RULES}; do
		load_rule_file "$rvar" || return
	done
fi
} # -------------------------------------------------------------------------

load_all_ipt_rulefiles() { # load all rule files
log -T "Loading rule files"
load_raw_rules || return
load_rawpost_rules || return
load_mangle_rules || return
load_nat_rules || return
load_filter_rules || return
load_security_rules || return
} # -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# SUB FUNCTIONS of process_ipt_ruleblock()
# -------------------------------------------------------------------------
_process_target() { # fill the target rulelist and msglist arrays
local str_target_msg
case "$str_target" in
	ACCEPT) str_target_msg="accept" ;;
	AUDIT) str_target_msg="audit" ;;
	CLASSIFY) str_target_msg="classify" ;;
	CONNMARK) str_target_msg="connmark" ;;
	CONNSECMARK) str_target_msg="connsecmark" ;;
	DROP) str_target_msg="drop" ;;
	ECN) str_target_msg="remove-ecn" ;;
	CHECKSUM) str_target_msg="fill-checksum" ;;
	LOG) str_target_msg="log" ;;
	NFLOG) str_target_msg="nflog" ;;
	ULOG) str_target_msg="ulog" ;;
	MARK) str_target_msg="mark" ;;
	SECMARK) str_target_msg="secmark" ;;
	MASQUERADE) str_target_msg="masq" ;;
	NETMAP) str_target_msg="netmap" ;;
	NFQUEUE) str_target_msg="nfqueue" ;;
	REJECT) str_target_msg="reject" ;;
	DNAT) str_target_msg="dnat" ;;
	SNAT) str_target_msg="snat" ;;
	RAWDNAT) str_target_msg="rawdnat" ;;
	RAWSNAT) str_target_msg="rawsnat" ;;
	REDIRECT) str_target_msg="redirect" ;;
	RETURN) str_target_msg="return" ;;
	SET) str_target_msg="set-set" ;;
	TCPOPTSTRIP) str_target_msg="strip-tcp-opts" ;;
	TCPMSS) str_target_msg="set-tcpmss" ;;
	DSCP) str_target_msg="set-dscp" ;;
	TEE) str_target_msg="tee" ;;
	TOS) str_target_msg="set-tos" ;;
	TPROXY) str_target_msg="tproxy" ;;
	TTL) str_target_msg="set-ttl" ;;
	*) str_target_msg="target: $str_target" ;;
esac
RULELIST_TARGET[RULE_LIST_IDX]="$str_target"
MSG_LIST_TARGET[RULE_LIST_IDX]="${str_target_msg}"
} # -------------------------------------------------------------------------

_process_table() { # fill the iptables table msglist array
MSG_LIST_TABLE[RULE_LIST_IDX]="table=$table "
} # -------------------------------------------------------------------------

_process_chain() { # fill the iptables chain rulelist and msglist arrays
RULELIST_CHAIN[RULE_LIST_IDX]="${str_target_chain}"
MSG_LIST_CHAIN[RULE_LIST_IDX]="chain=${str_target_chain} "
} # -------------------------------------------------------------------------

_process_fragment() {
local str_neg=""
string_negated "${arg_list_fragment[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_FRAGMENT[RULE_LIST_IDX]="${str_neg}-f "
MSG_LIST_FRAGMENT[RULE_LIST_IDX]="${str_neg% }fragments "
} # -------------------------------------------------------------------------

_process_idev() { # fill the input device rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_idev[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_IDEV[RULE_LIST_IDX]="${str_neg}-i $(remove_negation "${arg_list_idev[ARG_LIST_IDX]}") "
MSG_LIST_IDEV[RULE_LIST_IDX]="idev=${arg_list_idev[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_odev() { # fill the output device rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_odev[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_ODEV[RULE_LIST_IDX]="${str_neg}-o $(remove_negation "${arg_list_odev[ARG_LIST_IDX]}") "
MSG_LIST_ODEV[RULE_LIST_IDX]="odev=${arg_list_odev[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_src() { # fill the source address rulelist and msglist arrays
local str_src="${arg_list_src[ARG_LIST_IDX]}" str_neg=""
string_negated "${str_src}" && str_neg="! "
case "$(classify_ip4_addr $(remove_negation "${str_src}"))" in
	IPRANGE)
		RULELIST_SRC[RULE_LIST_IDX]="-m iprange ${str_neg}--src-range $(remove_negation "${str_src}") "
		MSG_LIST_SRC[RULE_LIST_IDX]="src-range=${str_src} "
	;;
	*)
		RULELIST_SRC[RULE_LIST_IDX]="${str_neg}-s $(remove_negation "${str_src}") "
		MSG_LIST_SRC[RULE_LIST_IDX]="src=${str_src} "
	;;
esac
} # -------------------------------------------------------------------------

_process_dst() { # fill the destination address rulelist and msglist arrays
local str_dst="${arg_list_dst[ARG_LIST_IDX]}" str_neg=""
string_negated "${str_dst}" && str_neg="! "
case "$(classify_ip4_addr $(remove_negation "${str_dst}"))" in
	IPRANGE)
		RULELIST_DST[RULE_LIST_IDX]="-m iprange ${str_neg}--dst-range $(remove_negation "${str_dst}") "
		MSG_LIST_DST[RULE_LIST_IDX]="dst-range=${str_dst} "
	;;
	*)
		RULELIST_DST[RULE_LIST_IDX]="${str_neg}-d $(remove_negation "${str_dst}") "
		MSG_LIST_DST[RULE_LIST_IDX]="dst=${str_dst} "
	;;
esac
} # -------------------------------------------------------------------------

_process_mac() { # fill the mac address rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_mac[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_MAC[RULE_LIST_IDX]="-m mac ${str_neg}--mac-source $(remove_negation "${arg_list_mac[ARG_LIST_IDX]}") "
MSG_LIST_MAC[RULE_LIST_IDX]="mac=${arg_list_mac[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_proto() { # fill the protocol rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_proto[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_PROTO[RULE_LIST_IDX]="${str_neg}-p $(remove_negation "${arg_list_proto[ARG_LIST_IDX]}") "
MSG_LIST_PROTO[RULE_LIST_IDX]="proto=${arg_list_proto[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_sport() { # fill the source port rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_sport[ARG_LIST_IDX]}" && str_neg="! "
if (($(IFS=, members_in_string ${arg_list_sport[ARG_LIST_IDX]}) > 1)); then
	if ((multi_source_ports == 0)); then
		if [[ ${arg_list_sport[ARG_LIST_IDX]} = ${arg_list_dport[ARG_LIST_IDX]} ]]; then
			RULELIST_SPORT[RULE_LIST_IDX]="-m multiport ${str_neg}--ports $(remove_negation "${arg_list_sport[ARG_LIST_IDX]}") "
			MSG_LIST_SPORT[RULE_LIST_IDX]="ports=${arg_list_sport[ARG_LIST_IDX]} "
			unset arg_list_dport[ARG_LIST_IDX] RULELIST_DPORT[RULE_LIST_IDX] MSG_LIST_DPORT[RULE_LIST_IDX]
		else
			RULELIST_SPORT[RULE_LIST_IDX]="-m multiport ${str_neg}--sports $(remove_negation "${arg_list_sport[ARG_LIST_IDX]}") "
			MSG_LIST_SPORT[RULE_LIST_IDX]="sports=${arg_list_sport[ARG_LIST_IDX]} "
		fi
	else
		log -E "Unknown error: arg_list_sport[${ARG_LIST_IDX}] should not contain commas."
		return 1
	fi
else
	RULELIST_SPORT[RULE_LIST_IDX]="-m ${arg_list_proto[ARG_LIST_IDX]} ${str_neg}--sport $(remove_negation "${arg_list_sport[ARG_LIST_IDX]}") "
	MSG_LIST_SPORT[RULE_LIST_IDX]="sport=${arg_list_sport[ARG_LIST_IDX]} "
fi
} # -------------------------------------------------------------------------

_process_dport() { # fill the destination port rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_dport[ARG_LIST_IDX]}" && str_neg="! "
if (($(IFS=, members_in_string ${arg_list_dport[ARG_LIST_IDX]}) > 1)); then
	if ((multi_destination_ports == 0)); then
		if [[ ${arg_list_sport[ARG_LIST_IDX]} = ${arg_list_dport[ARG_LIST_IDX]} ]]; then
			RULELIST_DPORT[RULE_LIST_IDX]="-m multiport ${str_neg}--ports $(remove_negation "${arg_list_dport[ARG_LIST_IDX]}") "
			MSG_LIST_DPORT[RULE_LIST_IDX]="ports=${arg_list_dport[ARG_LIST_IDX]} "
			unset arg_list_sport[ARG_LIST_IDX] RULELIST_SPORT[RULE_LIST_IDX] MSG_LIST_SPORT[RULE_LIST_IDX]
		else
			RULELIST_DPORT[RULE_LIST_IDX]="-m multiport ${str_neg}--dports $(remove_negation "${arg_list_dport[ARG_LIST_IDX]}") "
			MSG_LIST_DPORT[RULE_LIST_IDX]="dports=${arg_list_dport[ARG_LIST_IDX]} "
		fi
	else
		log -E "Unknown error: arg_list_dport[${ARG_LIST_IDX}] should not contain commas."
		return 1
	fi
else
	RULELIST_DPORT[RULE_LIST_IDX]="-m ${arg_list_proto[ARG_LIST_IDX]} ${str_neg}--dport $(remove_negation "${arg_list_dport[ARG_LIST_IDX]}") "
	MSG_LIST_DPORT[RULE_LIST_IDX]="dport=${arg_list_dport[ARG_LIST_IDX]} "
fi
} # -------------------------------------------------------------------------

_process_tcp_flags() {
local str_tflags="${arg_list_tcp_flags[ARG_LIST_IDX]/:/ }" str_neg=""
string_negated "${str_tflags}" && str_neg="! "
RULELIST_TCP_FLAGS[RULE_LIST_IDX]="-m tcp ${str_neg}--tcp-flags $(remove_negation "${str_tflags}") "
MSG_LIST_TCP_FLAGS[RULE_LIST_IDX]="tcp-flags=${str_tflags} "
} # -------------------------------------------------------------------------

_process_tcp_syn() {
local str_neg=""
string_negated "${arg_list_tcp_syn[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_TCP_SYN[RULE_LIST_IDX]="-m tcp ${str_neg}--syn "
MSG_LIST_TCP_SYN[RULE_LIST_IDX]="${str_neg/ /}syn "
} # -------------------------------------------------------------------------

_process_tcp_option() {
local str_neg=""
string_negated "${arg_list_tcp_option[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_TCP_OPTION[RULE_LIST_IDX]="-m tcp ${str_neg}--tcp-option $(remove_negation "${arg_list_tcp_option[ARG_LIST_IDX]}") "
MSG_LIST_TCP_OPTION[RULE_LIST_IDX]="tcp-option=${arg_list_tcp_option[ARG_LIST_IDX]}"
} # -------------------------------------------------------------------------

_process_icmp_type() { # fill the icmp types rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_icmp_type[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_ICMP_TYPE[RULE_LIST_IDX]="${str_neg}--icmp-type $(remove_negation "${arg_list_icmp_type[ARG_LIST_IDX]}") "
MSG_LIST_ICMP_TYPE[RULE_LIST_IDX]="type=${arg_list_icmp_type[ARG_LIST_IDX]} "
if [[ -z ${arg_list_proto[ARG_LIST_IDX]} ]]; then
	RULELIST_PROTO[RULE_LIST_IDX]="-p icmp "
	MSG_LIST_PROTO[RULE_LIST_IDX]="proto=icmp "
fi
} # -------------------------------------------------------------------------

_process_state() { # fill the state match rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_state[ARG_LIST_IDX]}" && str_neg="! "
if ((USE_M_CONNTRACK)); then
	RULELIST_STATE[RULE_LIST_IDX]="-m conntrack ${str_neg}--ctstate $(remove_negation "${arg_list_state[ARG_LIST_IDX]}") "
	MSG_LIST_STATE[RULE_LIST_IDX]="ctstate=${arg_list_state[ARG_LIST_IDX]} "
else
	RULELIST_STATE[RULE_LIST_IDX]="-m state ${str_neg}--state $(remove_negation "${arg_list_state[ARG_LIST_IDX]}") "
	MSG_LIST_STATE[RULE_LIST_IDX]="state=${arg_list_state[ARG_LIST_IDX]} "
fi
} # -------------------------------------------------------------------------

_process_ctstate() {
local str_neg=""
string_negated "${arg_list_ctstate[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_CTSTATE[RULE_LIST_IDX]="-m conntrack ${str_neg}--ctstate $(remove_negation "${arg_list_ctstate[ARG_LIST_IDX]}") "
MSG_LIST_CTSTATE[RULE_LIST_IDX]="ctstate=${arg_list_ctstate[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ctproto() {
local str_neg=""
string_negated "${arg_list_ctproto[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_CTPROTO[RULE_LIST_IDX]="-m conntrack ${str_neg}--ctproto $(remove_negation "${arg_list_ctproto[ARG_LIST_IDX]}") "
MSG_LIST_CTPROTO[RULE_LIST_IDX]="ctproto=${arg_list_ctproto[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ctorigsrc() {
local str_neg=""
string_negated "${arg_list_ctorigsrc[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_CTORIGSRC[RULE_LIST_IDX]="-m conntrack ${str_neg}--ctorigsrc $(remove_negation "${arg_list_ctorigsrc[ARG_LIST_IDX]}") "
MSG_LIST_CTORIGSRC[RULE_LIST_IDX]="ctorigsrc=${arg_list_ctorigsrc[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ctorigdst() {
local str_neg=""
string_negated "${arg_list_ctorigdst[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_CTORIGDST[RULE_LIST_IDX]="-m conntrack ${str_neg}--ctorigdst $(remove_negation "${arg_list_ctorigdst[ARG_LIST_IDX]}") "
MSG_LIST_CTORIGDST[RULE_LIST_IDX]="ctorigdst=${arg_list_ctorigdst[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ctreplsrc() {
local str_neg=""
string_negated "${arg_list_ctreplsrc[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_CTREPLSRC[RULE_LIST_IDX]="-m conntrack ${str_neg}--ctreplsrc $(remove_negation "${arg_list_ctreplsrc[ARG_LIST_IDX]}") "
MSG_LIST_CTREPLSRC[RULE_LIST_IDX]="ctreplsrc=${arg_list_ctreplsrc[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ctrepldst() {
local str_neg=""
string_negated "${arg_list_ctrepldst[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_CTREPLDST[RULE_LIST_IDX]="-m conntrack ${str_neg}--ctrepldst $(remove_negation "${arg_list_ctrepldst[ARG_LIST_IDX]}") "
MSG_LIST_CTREPLDST[RULE_LIST_IDX]="ctrepldst=${arg_list_ctrepldst[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ctorigsrcport() {
local str_neg=""
string_negated "${arg_list_ctorigsrcport[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_CTORIGSRCPORT[RULE_LIST_IDX]="-m conntrack ${str_neg}--ctorigsrcport $(remove_negation "${arg_list_ctorigsrcport[ARG_LIST_IDX]}") "
MSG_LIST_CTORIGSRCPORT[RULE_LIST_IDX]="ctorigsrcport=${arg_list_ctorigsrcport[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ctorigdstport() {
local str_neg=""
string_negated "${arg_list_ctorigdstport[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_CTORIGDSTPORT[RULE_LIST_IDX]="-m conntrack ${str_neg}--ctorigdstport $(remove_negation "${arg_list_ctorigdstport[ARG_LIST_IDX]}") "
MSG_LIST_CTORIGDSTPORT[RULE_LIST_IDX]="ctorigdstport=${arg_list_ctorigdstport[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ctreplsrcport() {
local str_neg=""
string_negated "${arg_list_ctreplsrcport[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_CTREPLSRCPORT[RULE_LIST_IDX]="-m conntrack ${str_neg}--ctreplsrcport $(remove_negation "${arg_list_ctreplsrcport[ARG_LIST_IDX]}") "
MSG_LIST_CTREPLSRCPORT[RULE_LIST_IDX]="ctreplsrcport=${arg_list_ctreplsrcport[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ctrepldstport() {
local str_neg=""
string_negated "${arg_list_ctrepldstport[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_CTREPLDSTPORT[RULE_LIST_IDX]="-m conntrack ${str_neg}--ctrepldstport $(remove_negation "${arg_list_ctrepldstport[ARG_LIST_IDX]}") "
MSG_LIST_CTREPLDSTPORT[RULE_LIST_IDX]="ctrepldstport=${arg_list_ctrepldstport[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ctstatus() {
local str_neg=""
string_negated "${arg_list_ctstatus[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_CTSTATUS[RULE_LIST_IDX]="-m conntrack ${str_neg}--ctstatus $(remove_negation "${arg_list_ctstatus[ARG_LIST_IDX]}") "
MSG_LIST_CTSTATUS[RULE_LIST_IDX]="ctstatus=${arg_list_ctstatus[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ctexpire() {
local str_neg=""
string_negated "${arg_list_ctexpire[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_CTEXPIRE[RULE_LIST_IDX]="-m conntrack ${str_neg}--ctexpire $(remove_negation "${arg_list_ctexpire[ARG_LIST_IDX]}") "
MSG_LIST_CTEXPIRE[RULE_LIST_IDX]="ctexpire=${arg_list_ctexpire[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ctdir() {
RULELIST_CTDIR[RULE_LIST_IDX]="-m conntrack --ctdir ${arg_list_ctdir[ARG_LIST_IDX]} "
MSG_LIST_CTDIR[RULE_LIST_IDX]="ctdir=${arg_list_ctdir[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_limit() { # fill the limit match rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_limit[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_LIMIT[RULE_LIST_IDX]="-m limit ${str_neg}--limit $(remove_negation "${arg_list_limit[ARG_LIST_IDX]}") "
MSG_LIST_LIMIT[RULE_LIST_IDX]="limit=${arg_list_limit[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_limit_burst() { # fill the limit match burst rulelist and msglist arrays
if [[ -z ${arg_list_limit[ARG_LIST_IDX]} ]]; then
	RULELIST_LIMIT[RULE_LIST_IDX]="-m limit "
	MSG_LIST_LIMIT[RULE_LIST_IDX]="limit=default "
fi
RULELIST_LIMIT_BURST[RULE_LIST_IDX]="--limit-burst ${arg_list_limit_burst[ARG_LIST_IDX]} "
MSG_LIST_LIMIT_BURST[RULE_LIST_IDX]="burst=${arg_list_limit_burst[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_connbytes() {
local str_neg=""
string_negated "${arg_list_connbytes[ARG_LIST_IDX]}" && str_neg="! "
set -- $(remove_negation "${arg_list_connbytes[ARG_LIST_IDX]//:/ }")
local str_dir="$1" str_mode="$2" str_crange="${3}:${4}"
#[[ ${4} ]] && str_crange+="$4"
RULELIST_CONNBYTES[RULE_LIST_IDX]="-m connbytes --connbytes-dir ${str_dir} --connbytes-mode ${str_mode} ${str_neg}--connbytes ${str_crange} "
MSG_LIST_CONNBYTES[RULE_LIST_IDX]="connbytes=${arg_list_connbytes[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_connlimit() {
local str_neg=""
string_negated "${arg_list_connlimit[ARG_LIST_IDX]}" && str_neg="! "
case "${arg_list_connlimit[ARG_LIST_IDX]/!/}" in
	+([[:digit:]]))
		RULELIST_CONNLIMIT[RULE_LIST_IDX]="-m connlimit ${str_neg}--connlimit-above $(remove_negation "${arg_list_connlimit[ARG_LIST_IDX]}") "
	;;
	+([[:digit:]])/+([[:digit:]]))
		local str_clim="${arg_list_connlimit[ARG_LIST_IDX]%/*}"
		RULELIST_CONNLIMIT[RULE_LIST_IDX]="-m connlimit ${str_neg}--connlimit-above $(remove_negation "${str_clim}") --connlimit-mask ${arg_list_connlimit[ARG_LIST_IDX]#*/} "
	;;
	*) log -U $FUNCNAME; return 1
esac
MSG_LIST_CONNLIMIT[RULE_LIST_IDX]="connlimit=${arg_list_connlimit[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_m_dscp() { # fill the dscp match rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_m_dscp[ARG_LIST_IDX]}" && str_neg="! "
local str_val=$(remove_negation "${arg_list_m_dscp[ARG_LIST_IDX]}")
case "${str_val}" in
	+([[:digit:]])|0x+([[:xdigit:]]))
		RULELIST_M_DSCP[RULE_LIST_IDX]="-m dscp ${str_neg}--dscp ${str_val} "
	;;
	BE|EF|AF+([[:digit:]])|CS@([[:digit:]]))
		RULELIST_M_DSCP[RULE_LIST_IDX]="-m dscp ${str_neg}--dscp-class ${str_val} "
	;;
	*) log -U $FUNCNAME; return 1
esac
MSG_LIST_M_DSCP[RULE_LIST_IDX]="dscp=${arg_list_m_dscp[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_m_tos() { # fill the type of service match rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_m_tos[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_TOS[RULE_LIST_IDX]="-m tos ${str_neg}--tos $(remove_negation "${arg_list_m_tos[ARG_LIST_IDX]}") "
MSG_LIST_TOS[RULE_LIST_IDX]="tos=${arg_list_m_tos[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_m_cpu() { # fill the cpu match rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_m_cpu[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_M_CPU[RULE_LIST_IDX]="-m cpu ${str_neg}--cpu $(remove_negation "${arg_list_m_cpu[ARG_LIST_IDX]}") "
MSG_LIST_M_CPU[RULE_LIST_IDX]="cpu=${arg_list_m_cpu[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_m_quota() { # fill the quota match rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_m_quota[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_M_QUOTA[RULE_LIST_IDX]="-m quota ${str_neg}--quota $(remove_negation "${arg_list_m_quota[ARG_LIST_IDX]}") "
MSG_LIST_M_QUOTA[RULE_LIST_IDX]="quota=${arg_list_m_quota[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_m_tcpmss() { # fill the tcpmss match rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_m_tcpmss[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_M_TCPMSS[RULE_LIST_IDX]="-m tcpmss ${str_neg}--mss $(remove_negation "${arg_list_m_tcpmss[ARG_LIST_IDX]}") "
MSG_LIST_M_TCPMSS[RULE_LIST_IDX]="tcpmss=${arg_list_m_tcpmss[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_m_set() { # fill the set match rulelist and msglist arrays
local str_entry 
# ugly hack to allow more than one ipset match (m_set)
unset RULELIST_M_SET[RULE_LIST_IDX] MSG_LIST_M_SET[RULE_LIST_IDX]
for str_entry in ${arg_list_m_set[ARG_LIST_IDX]}; do
	local str_neg=""
	string_negated "$str_entry" && str_neg="! "
	if [[ ${RULELIST_M_SET[RULE_LIST_IDX]} ]]; then
		RULELIST_M_SET[RULE_LIST_IDX]="${RULELIST_M_SET[RULE_LIST_IDX]}-m set ${str_neg}--match-set $(remove_negation "${str_entry/:/ }") "
		MSG_LIST_M_SET[RULE_LIST_IDX]="${MSG_LIST_M_SET[RULE_LIST_IDX]}set=${str_entry} "
	else
		RULELIST_M_SET[RULE_LIST_IDX]="-m set ${str_neg}--match-set $(remove_negation "${str_entry/:/ }") "
		MSG_LIST_M_SET[RULE_LIST_IDX]="set=${str_entry} "
	fi
done
} # -------------------------------------------------------------------------

_process_m_mark() { # fill the iptables mark match rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_m_mark[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_M_MARK[RULE_LIST_IDX]="-m mark ${str_neg}--mark $(remove_negation "${arg_list_m_mark[ARG_LIST_IDX]}") "
MSG_LIST_M_MARK[RULE_LIST_IDX]="mark=${arg_list_m_mark[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_m_connmark() { # fill the iptables connmark match rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_m_connmark[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_M_CONNMARK[RULE_LIST_IDX]="-m mark ${str_neg}--mark $(remove_negation "${arg_list_m_connmark[ARG_LIST_IDX]}") "
MSG_LIST_M_CONNMARK[RULE_LIST_IDX]="mark=${arg_list_m_connmark[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ahspi() { # fill the iptables ah match rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_ahspi[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_AHSPI[RULE_LIST_IDX]="-m ah ${str_neg}--ahspi $(remove_negation "${arg_list_ahspi[ARG_LIST_IDX]}") "
MSG_LIST_AHSPI[RULE_LIST_IDX]="ahspi=${arg_list_ahspi[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_espspi() { # fill the iptables esp match rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_espspi[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_ESPSPI[RULE_LIST_IDX]="-m esp ${str_neg}--espspi $(remove_negation "${arg_list_espspi[ARG_LIST_IDX]}") "
MSG_LIST_ESPSPI[RULE_LIST_IDX]="espspi=${arg_list_espspi[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_length() { # fill the length rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_length[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_LENGTH[RULE_LIST_IDX]="-m length ${str_neg}--length $(remove_negation "${arg_list_length[ARG_LIST_IDX]}") "
MSG_LIST_LENGTH[RULE_LIST_IDX]="length=${arg_list_length[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_helper() {
local str_neg=""
string_negated "${arg_list_helper[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_HELPER[RULE_LIST_IDX]="-m helper ${str_neg}--helper $(remove_negation "${arg_list_helper[ARG_LIST_IDX]}") "
MSG_LIST_HELPER[RULE_LIST_IDX]="helper=${arg_list_helper[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_osf() { # fill the osf match rulelist and msglist arrays
local str_neg="" str str_var str_genre str_cmd str_msg
string_negated "${arg_list_osf[ARG_LIST_IDX]}" && str_neg="! "
str_genre="${arg_list_osf[ARG_LIST_IDX]%%:*}"
str_var="${arg_list_osf[ARG_LIST_IDX]#$str_genre}"
str_var="${str_var#:}"
while [[ $str_var ]]; do
	str=${str_var%%:*}
	case "$str" in
		"") break ;;
		log|ttl)
			str_var=${str_var#${str}:}
			str_cmd+="--$str ${str_var%%:*} "
			str_msg+="osf_${str}=${str_var%%:*} "
			str_var=${str_var#[012]}
			str_var=${str_var#:}
		;;
		*) log -U $FUNCNAME; return 1
	esac
done
RULELIST_OSF[RULE_LIST_IDX]="-m osf ${str_neg}--genre $(remove_negation "$str_genre") $str_cmd"
MSG_LIST_OSF[RULE_LIST_IDX]="osf_genre=$str_genre $str_msg"
} # -------------------------------------------------------------------------

_process_m_ecn() { # fill the ecn match rulelist and msglist arrays
set -- ${arg_list_m_ecn[ARG_LIST_IDX]//:/ }
RULELIST_M_ECN[RULE_LIST_IDX]="-m ecn "
MSG_LIST_M_ECN[RULE_LIST_IDX]="ecn=${arg_list_m_ecn[ARG_LIST_IDX]} "
while (($#)); do
	local str_neg=""
	string_negated "$1" && str_neg="! "
	case "$1" in
		?(\!)ip-ect)
			RULELIST_M_ECN[RULE_LIST_IDX]+="${str_neg}--ecn-ip-ect $2 "
			shift 2
		;;
		?(\!)tcp-cwr|?(\!)tcp-ece)
			RULELIST_M_ECN[RULE_LIST_IDX]+="${str_neg}--ecn-$(remove_negation $1) "
			shift
		;;
		*) log -U $FUNCNAME; return 1
	esac
done
} # -------------------------------------------------------------------------

_process_devgroup() { # fill the devgroup match rulelist and msglist arrays
set -- ${arg_list_devgroup[ARG_LIST_IDX]//:/ }
RULELIST_DEVGROUP[RULE_LIST_IDX]="-m devgroup "
MSG_LIST_DEVGROUP[RULE_LIST_IDX]="devgroup=${arg_list_devgroup[ARG_LIST_IDX]} "
while (($#)); do
	local str_neg=""
	string_negated "$1" && str_neg="! "
	case "$1" in
		?(\!)@(src|dst))
			RULELIST_DEVGROUP[RULE_LIST_IDX]+="${str_neg}--$(remove_negation $1)-group $2 "
			shift 2
		;;
		*) log -U $FUNCNAME; return 1
	esac
done
} # -------------------------------------------------------------------------

_process_sctp() { # fill the sctp match rulelist and msglist arrays
local str_neg="" str_val="${arg_list_sctp[ARG_LIST_IDX]}" str_cmd="-m sctp --chunk-types "
string_negated "${arg_list_sctp[ARG_LIST_IDX]}" && str_neg="! " str_val="$(remove_negation "${arg_list_sctp[ARG_LIST_IDX]}")"
case "$str_val" in
	@(all|any|only)?(:*))
		str_cmd+="${str_val%%:*} "
		str_cmd+="${str_val#*:}"
	;;
	*) log -U $FUNCNAME; return 1
esac
RULELIST_SCTP[RULE_LIST_IDX]="${str_neg}$str_cmd "
MSG_LIST_SCTP[RULE_LIST_IDX]="sctp_chunk-type=${arg_list_sctp[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_owner() {
set -- ${arg_list_owner[ARG_LIST_IDX]//:/ }
RULELIST_OWNER[RULE_LIST_IDX]="-m owner "
MSG_LIST_OWNER[RULE_LIST_IDX]="owner=${arg_list_owner[ARG_LIST_IDX]} "
while (($#)); do
	local str_neg=""
	string_negated "$1" && str_neg="! "
	case "$1" in
		?(\!)uid)
			RULELIST_OWNER[RULE_LIST_IDX]+="${str_neg}--uid-owner $2 "
			shift 2
		;;
		?(\!)gid)
			RULELIST_OWNER[RULE_LIST_IDX]+="${str_neg}--gid-owner $2 "
			shift 2
		;;
		?(\!)socket)
			RULELIST_OWNER[RULE_LIST_IDX]+="${str_neg}--socket-exists "
			shift
		;;
		*) log -U $FUNCNAME; return 1
	esac
done
} # -------------------------------------------------------------------------

_process_socket() {
if [[ ${arg_list_socket[ARG_LIST_IDX]} = transparent ]]; then
	RULELIST_SOCKET[RULE_LIST_IDX]="-m socket --transparent "
	MSG_LIST_SOCKET[RULE_LIST_IDX]="socket=transparent "
else
	RULELIST_SOCKET[RULE_LIST_IDX]="-m socket "
	MSG_LIST_SOCKET[RULE_LIST_IDX]="socket "
fi
} # -------------------------------------------------------------------------

_process_m_ttl() {
local ttl_val="${arg_list_m_ttl[ARG_LIST_IDX]}" ttl_msg str_ttl
case "${ttl_val}" in
	(+([[:digit:]]))
		ttl_msg="ttl=${ttl_val}"
		str_ttl="--ttl-eq ${ttl_val}"
	;;
	("+"+([[:digit:]]))
		ttl_msg="ttl>${ttl_val/+/}"
		str_ttl="--ttl-gt ${ttl_val/+/}"
	;;
	("-"+([[:digit:]]))
		ttl_msg="ttl<${ttl_val/-/}"
		str_ttl="--ttl-lt ${ttl_val/-/}"
	;;
	*) log -U $FUNCNAME; return 1
esac
RULELIST_M_TTL[RULE_LIST_IDX]="-m ttl ${str_ttl} "
MSG_LIST_M_TTL[RULE_LIST_IDX]="${ttl_msg} "
} # -------------------------------------------------------------------------

_process_addrtype() { # fill the iptables addrtype match rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_addrtype[ARG_LIST_IDX]}" && str_neg="! "
set -- ${arg_list_addrtype[ARG_LIST_IDX]/:/ }
local str_addr=$(remove_negation "$1") str_atype="$2"
RULELIST_PKTTYPE[RULE_LIST_IDX]="-m addrtype ${str_neg}--${str_addr}-type ${str_atype} "
MSG_LIST_PKTTYPE[RULE_LIST_IDX]="${str_addr}-addrtype=${str_atype} "
} # -------------------------------------------------------------------------

_process_pkttype() { # fill the iptables pkttype  match rulelist and msglist arrays
local str_neg=""
string_negated "${arg_list_pkttype[ARG_LIST_IDX]}" && str_neg="! "
RULELIST_PKTTYPE[RULE_LIST_IDX]="-m pkttype ${str_neg}--pkt-type $(remove_negation "${arg_list_pkttype[ARG_LIST_IDX]}") "
MSG_LIST_PKTTYPE[RULE_LIST_IDX]="pkt-type=${arg_list_pkttype[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_comment() {
RULELIST_COMMENT[RULE_LIST_IDX]="-m comment --comment \"${arg_list_comment[ARG_LIST_IDX]}\" "
MSG_LIST_COMMENT[RULE_LIST_IDX]="comment='${arg_list_comment[ARG_LIST_IDX]}' "
} # -------------------------------------------------------------------------

_process_t_dscp() { # fill the dscp target rulelist and msglist arrays
case "${arg_list_t_dscp[ARG_LIST_IDX]}" in
	+([[:digit:]])|0x+([[:xdigit:]]))
		RULELIST_SET_DSCP[RULE_LIST_IDX]="--set-dscp ${arg_list_t_dscp[ARG_LIST_IDX]}"
	;;
	BE|EF|AF+([[:digit:]])|CS@([[:digit:]]))
		RULELIST_SET_DSCP[RULE_LIST_IDX]="--set-dscp-class ${arg_list_t_dscp[ARG_LIST_IDX]}"
	;;
	*) log -U $FUNCNAME; return 1
esac
MSG_LIST_SET_DSCP[RULE_LIST_IDX]="set-dscp=${arg_list_t_dscp[ARG_LIST_IDX]}"
} # -------------------------------------------------------------------------

_process_t_set() {
set -- ${arg_list_t_set[ARG_LIST_IDX]//:/ }
local str_act="$1" str_setname="$2" str_flags="$3"
RULELIST_SET_SET[RULE_LIST_IDX]="--${str_act}-set ${str_setname} ${str_flags}"
MSG_LIST_SET_SET[RULE_LIST_IDX]="${str_act}-set=${arg_list_t_set[ARG_LIST_IDX]#${str_act}:}"
} # -------------------------------------------------------------------------

_process_t_mark() { # fill the iptables mark target mark rulelist and msglist arrays
local str_msk=""
if [[ ${arg_list_t_mark[ARG_LIST_IDX]} = */* ]]; then
	local str_mrk="${arg_list_t_mark[ARG_LIST_IDX]%/*}" str_msk="${arg_list_t_mark[ARG_LIST_IDX]#*/}"
	local str_mrk=${str_mrk/@(@(and|or|set|xset|xor):)/}
else
	local str_mrk=${arg_list_t_mark[ARG_LIST_IDX]/@(@(and|or|set|xset|xor):)/}
fi
[[ ${str_msk} ]] && local str_msk="/${str_msk}"
case "${arg_list_t_mark[ARG_LIST_IDX]}" in
	?(set:)?(0x)+([[:xdigit:]])?(/?(0x)+([[:xdigit:]])))
		RULELIST_SET_MARK[RULE_LIST_IDX]="--set-mark ${str_mrk}${str_msk}"
		MSG_LIST_SET_MARK[RULE_LIST_IDX]="set-mark=${str_mrk}${str_msk}"
	;;
	xset:?(0x)+([[:xdigit:]])?(/?(0x)+([[:xdigit:]])))
		RULELIST_SET_MARK[RULE_LIST_IDX]="--set-xmark ${str_mrk}${str_msk}"
		MSG_LIST_SET_MARK[RULE_LIST_IDX]="set-xmark=${str_mrk}${str_msk}"
	;;
	and:?(0x)+([[:xdigit:]]))
		RULELIST_SET_MARK[RULE_LIST_IDX]="--and-mark ${str_mrk}"
		MSG_LIST_SET_MARK[RULE_LIST_IDX]="and-mark=${str_mrk}"
	;;
	or:?(0x)+([[:xdigit:]]))
		RULELIST_SET_MARK[RULE_LIST_IDX]="--or-mark ${str_mrk}"
		MSG_LIST_SET_MARK[RULE_LIST_IDX]="or-mark=${str_mrk}"
	;;
	xor:?(0x)+([[:xdigit:]]))
		RULELIST_SET_MARK[RULE_LIST_IDX]="--xor-mark ${str_mrk}"
		MSG_LIST_SET_MARK[RULE_LIST_IDX]="xor-mark=${str_mrk}"
	;;
	*) log -U $FUNCNAME; return 1
esac
} # -------------------------------------------------------------------------

_process_t_connmark() {
local str_msk=""
if [[ ${arg_list_t_connmark[ARG_LIST_IDX]} = */* ]]; then
	local str_mrk="${arg_list_t_connmark[ARG_LIST_IDX]%/*}" str_msk="${arg_list_set_connmark[ARG_LIST_IDX]#*/}"
	local str_mrk=${str_mrk/@(@(and|or|set|xset|xor|save|restore)?(:))/}
else
	local str_mrk=${arg_list_t_connmark[ARG_LIST_IDX]/@(@(and|or|set|xset|xor|save|restore)?(:))/}
fi
[[ ${str_msk} ]] && local str_msk="/${str_msk}"
local str_act="${arg_list_t_connmark[ARG_LIST_IDX]%:*}"
case "${arg_list_t_connmark[ARG_LIST_IDX]}" in
	@(save|restore)?(:?(0x)*([[:xdigit:]]))?(/?(0x)+([[:xdigit:]])))
		if [[ -z ${str_mrk} ]]; then
			if [[ -z ${str_msk} ]]; then
				RULELIST_SET_CONNMARK[RULE_LIST_IDX]="--${str_act}-mark"
				MSG_LIST_SET_CONNMARK[RULE_LIST_IDX]="${str_act}-mark"
			else
				RULELIST_SET_CONNMARK[RULE_LIST_IDX]="--${str_act}-mark --mask ${str_msk#/}"
				MSG_LIST_SET_CONNMARK[RULE_LIST_IDX]="${str_act}-mark${str_msk}"
			fi
		else
#			if [[ -z ${str_msk} ]]; then
#				log -E "If nfmask is specified, ctmask is mandatory."
#				return 1
#			fi
			RULELIST_SET_CONNMARK[RULE_LIST_IDX]="--${str_act}-mark --nfmask ${str_mrk} --ctmask ${str_msk#/}"
			MSG_LIST_SET_CONNMARK[RULE_LIST_IDX]="${str_act}-mark nfmask=${str_mrk} ctmask=${str_msk#/}"
		fi
	;;
	set:?(0x)+([[:xdigit:]])?(/?(0x)+([[:xdigit:]])))
		RULELIST_SET_CONNMARK[RULE_LIST_IDX]="--set-mark ${str_mrk}${str_msk}"
		MSG_LIST_SET_CONNMARK[RULE_LIST_IDX]="set-mark=${str_mrk}${str_msk}"
	;;
	xset:?(0x)+([[:xdigit:]])?(/?(0x)+([[:xdigit:]])))
		RULELIST_SET_CONNMARK[RULE_LIST_IDX]="--set-xmark ${str_mrk}${str_msk}"
		MSG_LIST_SET_CONNMARK[RULE_LIST_IDX]="set-xmark=${str_mrk}${str_msk}"
	;;
	and:?(0x)+([[:xdigit:]]))
		RULELIST_SET_CONNMARK[RULE_LIST_IDX]="--and-mark ${str_mrk}"
		MSG_LIST_SET_CONNMARK[RULE_LIST_IDX]="and-mark=${str_mrk}"
	;;
	or:?(0x)+([[:xdigit:]]))
		RULELIST_SET_CONNMARK[RULE_LIST_IDX]="--or-mark ${str_mrk}"
		MSG_LIST_SET_CONNMARK[RULE_LIST_IDX]="or-mark=${str_mrk}"
	;;
	xor:?(0x)+([[:xdigit:]]))
		RULELIST_SET_CONNMARK[RULE_LIST_IDX]="--xor-mark ${str_mrk}"
		MSG_LIST_SET_CONNMARK[RULE_LIST_IDX]="xor-mark=${str_mrk}"
	;;
	*) log -U $FUNCNAME; return 1
esac
} # -------------------------------------------------------------------------

_process_audit() { # fill the AUDIT target rulelist and msglist arrays
RULELIST_AUDIT[RULE_LIST_IDX]="--type ${arg_list_audit[ARG_LIST_IDX]} "
MSG_LIST_AUDIT[RULE_LIST_IDX]="audit-type=${arg_list_audit[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_tee_gw() { # fill the TEE target rulelist and msglist arrays
RULELIST_TEE_GW[RULE_LIST_IDX]="--gateway ${arg_list_tee_gw[ARG_LIST_IDX]} "
MSG_LIST_TEE_GW[RULE_LIST_IDX]="tee-gateway=${arg_list_tee_gw[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_t_secmark() {
RULELIST_SET_SECMARK[RULE_LIST_IDX]="--selctx ${arg_list_t_secmark[ARG_LIST_IDX]} "
MSG_LIST_SET_SECMARK[RULE_LIST_IDX]="SEcontext=${arg_list_t_secmark[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_t_connsecmark() {
case "${arg_list_t_connsecmark[ARG_LIST_IDX]}" in
	s|sa|sav|save)
		RULELIST_SET_CONNSECMARK[RULE_LIST_IDX]="--save"
		MSG_LIST_SET_CONNSECMARK[RULE_LIST_IDX]="save-connsecmark"
	;;
	r|re|res|rest|resto|restor|restore)
		RULELIST_SET_CONNSECMARK[RULE_LIST_IDX]="--restore"
		MSG_LIST_SET_CONNSECMARK[RULE_LIST_IDX]="restore-connsecmark"
	;;
	*) log -U $FUNCNAME; return 1
esac
} # -------------------------------------------------------------------------

_process_nat_ip() { # fill the nat ip address rulelist and msglist arrays
case "$str_target" in
	SNAT)
		RULELIST_NAT_IP[RULE_LIST_IDX]="--to-source ${arg_list_nat_ip[ARG_LIST_IDX]}"
		MSG_LIST_NAT_IP[RULE_LIST_IDX]="NATsrc=${arg_list_nat_ip[ARG_LIST_IDX]} "
	;;
	DNAT)
		RULELIST_NAT_IP[RULE_LIST_IDX]="--to-destination ${arg_list_nat_ip[ARG_LIST_IDX]}"
		MSG_LIST_NAT_IP[RULE_LIST_IDX]="NATdst=${arg_list_nat_ip[ARG_LIST_IDX]} "
	;;
	NETMAP)
		RULELIST_NAT_IP[RULE_LIST_IDX]="--to ${arg_list_nat_ip[ARG_LIST_IDX]}"
		MSG_LIST_NAT_IP[RULE_LIST_IDX]="NATdst=${arg_list_nat_ip[ARG_LIST_IDX]} "
	;;
	RAWSNAT)
		RULELIST_NAT_IP[RULE_LIST_IDX]="--to-source ${arg_list_nat_ip[ARG_LIST_IDX]}"
		MSG_LIST_NAT_IP[RULE_LIST_IDX]="NATsrc=${arg_list_nat_ip[ARG_LIST_IDX]} "
	;;
	RAWDNAT)
		RULELIST_NAT_IP[RULE_LIST_IDX]="--to-destination ${arg_list_nat_ip[ARG_LIST_IDX]}"
		MSG_LIST_NAT_IP[RULE_LIST_IDX]="NATdst=${arg_list_nat_ip[ARG_LIST_IDX]} "
	;;
	*) log -i "$str_target" 'an iptables target'
		return 1
esac
} # -------------------------------------------------------------------------

_process_nat_port() { # fill the nat port address rulelist and msglist arrays
case "$str_target" in
	MASQUERADE|REDIRECT)
		case "$(string_tolower "${arg_list_proto[ARG_LIST_IDX]:-0}")" in # only valid with tcp or udp
			(tcp|udp|6|17)
				RULELIST_NAT_PORT[RULE_LIST_IDX]="--to-ports ${arg_list_nat_port[ARG_LIST_IDX]/:/} "
			;;
		esac
	;;
	*) RULELIST_NAT_PORT[RULE_LIST_IDX]=":${arg_list_nat_port[ARG_LIST_IDX]} "
esac
MSG_LIST_NAT_PORT[RULE_LIST_IDX]="NATport=${arg_list_nat_port[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_nat_option() {
case "${arg_list_nat_option[ARG_LIST_IDX]}" in
	random|persistent)
		RULELIST_NAT_OPTION[RULE_LIST_IDX]="--${arg_list_nat_option[ARG_LIST_IDX]}"
		MSG_LIST_NAT_OPTION[RULE_LIST_IDX]="NAToption=${arg_list_nat_option[ARG_LIST_IDX]}"
	;;
	*) log -U $FUNCNAME; return 1
esac
} # -------------------------------------------------------------------------

_process_reject_type() { # fill the reject type rulelist and msglist arrays
RULELIST_REJECT_TYPE[RULE_LIST_IDX]="--reject-with ${arg_list_reject_type[ARG_LIST_IDX]} "
MSG_LIST_REJECT_TYPE[RULE_LIST_IDX]="reject=${arg_list_reject_type[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_log_level() { # fill the loglevel rulelist and msglist arrays
arg_list_log_level[ARG_LIST_IDX]="$(string_tolower "${arg_list_log_level[ARG_LIST_IDX]}")"
RULELIST_LOG_LEVEL[RULE_LIST_IDX]="--log-level ${arg_list_log_level[ARG_LIST_IDX]} "
MSG_LIST_LOG_LEVEL[RULE_LIST_IDX]="level=${arg_list_log_level[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_log_prefix() { # fill the logprefix rulelist and msglist arrays
RULELIST_LOG_PREFIX[RULE_LIST_IDX]="--log-prefix \"${arg_list_log_prefix[ARG_LIST_IDX]} \" "
MSG_LIST_LOG_PREFIX[RULE_LIST_IDX]="prefix='${arg_list_log_prefix[ARG_LIST_IDX]} ' "
} # -------------------------------------------------------------------------

_process_log_options() {
local str_lopt
local -a arr_logcmd arr_logmsg
#for str_lopt in $(IFS=, split_val ${arg_list_log_options[ARG_LIST_IDX]}); do
for str_lopt in ${arg_list_log_options[ARG_LIST_IDX]//,/ }; do
	case "${str_lopt}" in
		log_tcp_seq)
			arr_logcmd[${#arr_logcmd[@]}]="--log-tcp-sequence"
			arr_logmsg[${#arr_logmsg[@]}]="tcp-sequence"
			RULELIST_LOG_TCPSEQ[RULE_LIST_IDX]="--log-tcp-sequence "
			MSG_LIST_LOG_TCPSEQ[RULE_LIST_IDX]="tcp-sequence "
		;;
		log_tcp_opt)
			arr_logcmd[${#arr_logcmd[@]}]="--log-tcp-options"
			arr_logmsg[${#arr_logmsg[@]}]="tcp-options"
			RULELIST_LOG_TCPOPT[RULE_LIST_IDX]="--log-tcp-options "
			MSG_LIST_LOG_TCPOPT[RULE_LIST_IDX]="tcp-options "
		;;
		log_ip_opt)
			arr_logcmd[${#arr_logcmd[@]}]="--log-ip-options"
			arr_logmsg[${#arr_logmsg[@]}]="ip-options"
			RULELIST_LOG_IPOPT[RULE_LIST_IDX]="--log-ip-options "
			MSG_LIST_LOG_IPOPT[RULE_LIST_IDX]="ip-options "
		;;
		log_uid)
			arr_logcmd[${#arr_logcmd[@]}]="--log-uid"
			arr_logmsg[${#arr_logmsg[@]}]="uid"
			RULELIST_LOG_UID[RULE_LIST_IDX]="--log-uid "
			MSG_LIST_LOG_UID[RULE_LIST_IDX]="uid "
		;;
		*) log -U $FUNCNAME; return 1
	esac
done
RULELIST_LOG_OPTIONS[RULE_LIST_IDX]="${arr_logcmd[*]} "
MSG_LIST_LOG_OPTIONS[RULE_LIST_IDX]="${arr_logmsg[*]} "
} # -------------------------------------------------------------------------

_process_rpfilter() {
local str_opt str_msg="rpfilter"
local -a arr_cmd=("-m rpfilter")
for str_opt in $(split_val : ' ' "${arg_list_rpfilter[ARG_LIST_IDX]}"); do
	case "$str_opt" in
		rpfilter) : ;;
		loose|validmark|accept-local|strict)
			arr_cmd[${#arr_cmd[@]}]="--$str_opt"
			str_msg+=":$str_opt"
		;;
		*) log -U $FUNCNAME; return 1
	esac
done
RULELIST_RPFILTER[RULE_LIST_IDX]="${arr_cmd[*]} "
MSG_LIST_RPFILTER[RULE_LIST_IDX]="$str_msg "
} # -------------------------------------------------------------------------

_process_nflog_group() { # fill the NFLOG netlink group rulelist and msglist arrays
RULELIST_NFLOG_GROUP[RULE_LIST_IDX]="--nflog-group ${arg_list_nflog_group[ARG_LIST_IDX]} "
MSG_LIST_NFLOG_GROUP[RULE_LIST_IDX]="nflog-group=${arg_list_nflog_group[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_nflog_prefix() { # fill the NFLOG prefix rulelist and msglist arrays
RULELIST_NFLOG_PREFIX[RULE_LIST_IDX]="--nflog-prefix \"${arg_list_nflog_prefix[ARG_LIST_IDX]} \" "
MSG_LIST_NFLOG_PREFIX[RULE_LIST_IDX]="nflog-prefix='${arg_list_nflog_prefix[ARG_LIST_IDX]} ' "
} # -------------------------------------------------------------------------

_process_nflog_range() { # fill the NFLOG copy to userspsace byte range rulelist and msglist arrays
RULELIST_NFLOG_RANGE[RULE_LIST_IDX]="--nflog-range ${arg_list_nflog_range[ARG_LIST_IDX]} "
MSG_LIST_NFLOG_RANGE[RULE_LIST_IDX]="nflog-range=${arg_list_nflog_range[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_nflog_thresh() { # fill the ULOG queue threshold size rulelist and msglist arrays
RULELIST_NFLOG_THRESH[RULE_LIST_IDX]="--nflog-threshold ${arg_list_nflog_thresh[ARG_LIST_IDX]} "
MSG_LIST_NFLOG_THRESH[RULE_LIST_IDX]="nflog-thresh=${arg_list_nflog_thresh[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ulog_group() { # fill the ULOG netlink group rulelist and msglist arrays
RULELIST_ULOG_GROUP[RULE_LIST_IDX]="--ulog-nlgroup ${arg_list_ulog_group[ARG_LIST_IDX]} "
MSG_LIST_ULOG_GROUP[RULE_LIST_IDX]="nlgroup=${arg_list_ulog_group[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ulog_prefix() { # fill the ULOG prefix rulelist and msglist arrays
RULELIST_ULOG_PREFIX[RULE_LIST_IDX]="--ulog-prefix \"${arg_list_ulog_prefix[ARG_LIST_IDX]} \" "
MSG_LIST_ULOG_PREFIX[RULE_LIST_IDX]="ulog-prefix='${arg_list_ulog_prefix[ARG_LIST_IDX]} ' "
} # -------------------------------------------------------------------------

_process_ulog_range() { # fill the ULOG copy to userspsace byte range rulelist and msglist arrays
RULELIST_ULOG_RANGE[RULE_LIST_IDX]="--ulog-cprange ${arg_list_ulog_range[ARG_LIST_IDX]} "
MSG_LIST_ULOG_RANGE[RULE_LIST_IDX]="cprange=${arg_list_ulog_range[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_ulog_thresh() { # fill the ULOG queue threshold size rulelist and msglist arrays
RULELIST_ULOG_THRESH[RULE_LIST_IDX]="--ulog-qthreshold ${arg_list_ulog_thresh[ARG_LIST_IDX]} "
MSG_LIST_ULOG_THRESH[RULE_LIST_IDX]="ulog-qthresh=${arg_list_ulog_thresh[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_nfqueue() {
case "${arg_list_nfqueue[ARG_LIST_IDX]}" in
	+([[:digit:]]))
		RULELIST_NFQUEUE[RULE_LIST_IDX]="--queue-num ${arg_list_nfqueue[ARG_LIST_IDX]} "
		MSG_LIST_NFQUEUE[RULE_LIST_IDX]="queue=${arg_list_nfqueue[ARG_LIST_IDX]} "
	;;
	+([[:digit:]]):+([[:digit:]])) # support --queue-balance - TO DO: check if system supports
		RULELIST_NFQUEUE[RULE_LIST_IDX]="--queue-balance ${arg_list_nfqueue[ARG_LIST_IDX]} "
		MSG_LIST_NFQUEUE[RULE_LIST_IDX]="queue-balance=${arg_list_nfqueue[ARG_LIST_IDX]} "
	;;
	*) log -U $FUNCNAME; return 1
esac
} # -------------------------------------------------------------------------

_process_t_class() {
RULELIST_SET_CLASS[RULE_LIST_IDX]="--set-class ${arg_list_t_class[ARG_LIST_IDX]} "
MSG_LIST_SET_CLASS[RULE_LIST_IDX]="class=${arg_list_t_class[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_process_t_tos() {
case "${arg_list_t_tos[ARG_LIST_IDX]}" in
	+([[:alpha:]])-+([[:alpha:]]) | +([[:digit:]]) | 0x+([[:xdigit:]]) | +([[:digit:]])/+([[:digit:]]) | ?(0x)+([[:xdigit:]])/?(0x)+([[:xdigit:]]))
		RULELIST_SET_TOS[RULE_LIST_IDX]="--set-tos ${arg_list_t_tos[ARG_LIST_IDX]} "
		MSG_LIST_SET_TOS[RULE_LIST_IDX]="tos=${arg_list_t_tos[ARG_LIST_IDX]} "
	;;
	@(and|or|xor):@(+([[:digit:]])|0x+([[:xdigit:]])))
		local str_act="${arg_list_t_tos[ARG_LIST_IDX]%:*}"
		RULELIST_SET_TOS[RULE_LIST_IDX]="--${str_act}-tos ${arg_list_t_tos[ARG_LIST_IDX]#${str_act}:} "
		MSG_LIST_SET_TOS[RULE_LIST_IDX]="${str_act}-tos=${arg_list_t_tos[ARG_LIST_IDX]#${str_act}:} "
	;;
	*) log -U $FUNCNAME; return 1
esac
} # -------------------------------------------------------------------------

_process_t_ttl() {
local ttl_val="${arg_list_t_ttl[ARG_LIST_IDX]}" ttl_msg str_ttl
case "${ttl_val}" in
	(+([[:digit:]]))
		ttl_msg="setting TTL to ${ttl_val}"
		str_ttl="--ttl-set ${ttl_val}"
	;;
	("+"+([[:digit:]]))
		ttl_msg="increasing TTL by ${ttl_val/+/}"
		str_ttl="--ttl-inc ${ttl_val/+/}"
	;;
	("-"+([[:digit:]]))
		ttl_msg="decreasing TTL by ${ttl_val/-/}"
		str_ttl="--ttl-dec ${ttl_val/-/}"
	;;
	*) log -U $FUNCNAME; return 1
esac
RULELIST_SET_TTL[RULE_LIST_IDX]="${str_ttl} "
MSG_LIST_SET_TTL[RULE_LIST_IDX]="${ttl_msg} "
} # -------------------------------------------------------------------------

_process_t_tcpmss() {
case "${arg_list_t_tcpmss[ARG_LIST_IDX]}" in
	pmtu)
		RULELIST_SET_TCPMSS[RULE_LIST_IDX]="--clamp-mss-to-pmtu"
		MSG_LIST_SET_TCPMSS[RULE_LIST_IDX]="mss=pmtu-40"
	;;
	+([[:digit:]]))
		RULELIST_SET_TCPMSS[RULE_LIST_IDX]="--set-mss ${arg_list_t_tcpmss[ARG_LIST_IDX]}"
		MSG_LIST_SET_TCPMSS[RULE_LIST_IDX]="mss=${arg_list_t_tcpmss[ARG_LIST_IDX]}"
	;;
	*) log -U $FUNCNAME; return 1
esac
} # -------------------------------------------------------------------------

_process_tproxy_opt() {
local str_cmd str_msg
set -- ${arg_list_tproxy_opt[ARG_LIST_IDX]//:/ }
while (($#)); do
	case "$1" in
		port)
			str_cmd+="--on-port $2 "
			str_msg+="tproxy-port=$2 "
		;;
		ip)
			str_cmd+="--on-ip $2 "
			str_msg+="tproxy-ip=$2 "
		;;
		mark)
			str_cmd+="--tproxy-mark $2 "
			str_msg+="tproxy-mark=$2 "
		;;
		*) log -U $FUNCNAME; return 1
	esac
	shift 2
done
RULELIST_TPROXY_OPT[RULE_LIST_IDX]="${str_cmd}"
MSG_LIST_TPROXY_OPT[RULE_LIST_IDX]="${str_msg}"
} # -------------------------------------------------------------------------

_process_tcpoptstrip() {
RULELIST_TCPOPTSTRIP[RULE_LIST_IDX]="--strip-options ${arg_list_tcpoptstrip[ARG_LIST_IDX]} "
MSG_LIST_TCPOPTSTRIP[RULE_LIST_IDX]="strip-opts=${arg_list_tcpoptstrip[ARG_LIST_IDX]} "
} # -------------------------------------------------------------------------

_validate_ipt_option_name() { # check if the given template option name is valid
[[ $1 = @(${ARG_LIST_CHECKSTRING}) ]] || {
	log -E "Unknown iptables option \`$1'."
	return 1
}
} # -------------------------------------------------------------------------

_val_tgtopt_set() {
check_var_no_sep_silent "$1" || {
	log -E "No $str_target target option value specified."
	return 1
}
} # -------------------------------------------------------------------------

_check_mandatory_vars() {
# check for variables, which are defined as mandatory in the refering rule template
# the rule string is set as positional parameters
local -i tmp_opt_idx reference_positional_param
#local -i option_list_sum=$(arr_members_sum option_list_${OPTION_LIST_IDX})
# last array member of the option list
local -i option_list_sum=$(last_arr_member option_list_${OPTION_LIST_IDX})
local str_var_name
[[ $DEBUG_INFO ]] && pr_str "mandatory_vars_${OPTION_LIST_IDX}: ${mandatory_vars[OPTION_LIST_IDX]}"
# for every variable name (comma separated) in mandatory_vars check if it's defined
#for str_var_name in $(IFS=, split_val ${mandatory_vars[OPTION_LIST_IDX]}); do
for str_var_name in ${mandatory_vars[OPTION_LIST_IDX]//,/ }; do
	reference_positional_param=1 # references to column #1 in the ruleblock
	# check for a valid option name
	_validate_ipt_option_name "${str_var_name}" || return $ER_NODEF
	# look in the option list for a matching name
	for tmp_opt_idx in $(arr_indicies "option_list_${OPTION_LIST_IDX}"); do
		# if the mandatory variable name is found in the option list
		if [[ ${str_var_name} = $(eval 'printf "%s\n" "${option_list_'${OPTION_LIST_IDX}'[tmp_opt_idx]%%=*}"') ]]; then
			# if it is already defined in the template as default value (option_name=X), there is nothing more to do
			if [[ ${!str_var_name} ]]; then
				[[ ${!str_var_name} = $RULE_SEP ]] && {
					log -E "Mandatory configuration entry \`${str_var_name}' missing, placeholder not allowed at position \`${reference_positional_param}'."
					return $ER_NODEF
				}
				break
			fi
			# now see if user has placed an entry in the rule
			# positional parameters correspond to columns in the users rule
			if [[ ${!reference_positional_param} ]]; then
				# ok, the positional parameter reference to the option variable name tells us, that the option is set.
				# now check if the mandatory variable is a rule separator, which is not allowed
				[[ ${!reference_positional_param} = $RULE_SEP ]] && {
					log -E "Mandatory configuration entry \`${str_var_name}' missing, placeholder not allowed at position \`${reference_positional_param}'."
					return $ER_NODEF
				}
				# all seems good if we reach this point. variable is definded and not a placeholder.
				# we can now continue with the next variable name
				continue 2
			else
				# fail condition. variable is not defined.
				log -E "Mandatory configuration entry \`${str_var_name}' missing at position \`${reference_positional_param}'."
				return $ER_NODEF
			fi
		fi
		((reference_positional_param++)) # next positional parameter to be processed
	done
	if ((option_list_sum == tmp_opt_idx)); then
		# if this point is reached, the variable name is not found in the option list
		# ergo it cannot be defined -> fail condition reached
		log -E "Configuration error in \`${target_template}'.  Mandatory variable named \`${str_var_name}' is not defined in array \`option_list_${OPTION_LIST_IDX}'."
		return $ER_CONF
	fi
done
} # -------------------------------------------------------------------------

_read_option_list() {
# read the values of the template option list and fill the according arrays for later processing
# the rule string is set as positional parameters
[[ $DEBUG_INFO ]] && {
	pr_str "Parameters to ${FUNCNAME}(): ${*}"
	pr_str "Referenced option list in ${FUNCNAME}(): ${!reference_command_array}"
}
local str_arr_var_name arr_element
local -i reference_positional_param=1 tmp_opt_idx=0
# for every option name in either option_list_0 or option_list_1 do...
for arr_element in ${!reference_command_array}; do
	# if positional param (column in rule) is not set, end of processing condition is reached
	[[ ${!reference_positional_param} ]] || break
	# if the option name is defined 'empty', continue with the next one
	[[ ${arr_element} = empty ]] && {
		((reference_positional_param++))
		continue
	}
	# the option could have assigned a default value, therefor remove eventually existing
	# definition strings, to retrieve the option name.
	str_arr_var_name="${arr_element%%=*}"
	# check if a known option name
	_validate_ipt_option_name "${str_arr_var_name}" || return $ER_CONF
	# if users has defined a default value for the option in the template
	# AND the according rule entry is the rule separator value, use the default value from the template
	if [[ ${!str_arr_var_name} &&  ${!reference_positional_param} = $RULE_SEP ]]; then
		if [[ -z ${tmp_pos_par_val_array[reference_positional_param -1]} ]]; then
			tmp_pos_par_val_array[reference_positional_param -1]="${str_arr_var_name} ${!str_arr_var_name}"
		fi
		eval arr_tmp_rule_opt_${OPTION_LIST_IDX}[tmp_opt_idx]=${str_arr_var_name}
		eval 'arg_list_'${str_arr_var_name}'[OPTION_LIST_IDX]="'"${!str_arr_var_name}"'"'
		((++tmp_opt_idx))
	else
		# option has no default value.
		# if the option is NOT the rule separator character, it's ok to process
		if [[ ${!reference_positional_param} != $RULE_SEP ]]; then
			if [[ -z ${tmp_pos_par_val_array[reference_positional_param -1]} ]]; then
				tmp_pos_par_val_array[reference_positional_param -1]="${str_arr_var_name} ${!reference_positional_param}"
			fi
			eval arr_tmp_rule_opt_${OPTION_LIST_IDX}[tmp_opt_idx]=${str_arr_var_name}
			# ugly hack for multiple ipset (m_set) match entries in rule
			if [[ ${str_arr_var_name} = m_set ]] && var_defined_silent "arg_list_${str_arr_var_name}[$OPTION_LIST_IDX]"; then
				eval 'arg_list_'${str_arr_var_name}'[OPTION_LIST_IDX]="${arg_list_'${str_arr_var_name}'[OPTION_LIST_IDX]} '"${!reference_positional_param}"'"'
			else
				eval 'arg_list_'${str_arr_var_name}'[OPTION_LIST_IDX]="'"${!reference_positional_param}"'"'
			fi
			[[ $DEBUG_INFO ]] && dbg_arr "arg_list_${str_arr_var_name}"
			((++tmp_opt_idx))
		fi
	fi
	((reference_positional_param++))
done
# there could be a state match definition in the template
if [[ ${state_match_arg[OPTION_LIST_IDX]} ]]; then
	eval arr_tmp_rule_opt_${OPTION_LIST_IDX}[tmp_opt_idx]="state"
	arg_list_state[OPTION_LIST_IDX]="${state_match_arg[OPTION_LIST_IDX]}"
	[[ $DEBUG_INFO ]] && pr_str "arg_list_state[${OPTION_LIST_IDX}]: ${arg_list_state[OPTION_LIST_IDX]}"
fi
[[ $DEBUG_INFO ]] && {
	pr_str "arr_tmp_rule_opt_${OPTION_LIST_IDX} in ${FUNCNAME}():"
	dbg_arr "arr_tmp_rule_opt_${OPTION_LIST_IDX}"
	pr_str "tmp_pos_par_val_array in ${FUNCNAME}():"
	dbg_arr "tmp_pos_par_val_array"
}
return 0
} # -------------------------------------------------------------------------

_pre_process_checks() {
# run rule sanity checks before running the _process* functions.
# These checks do not require that the target or the chain is known.
local -i pos_idx del_idx
# check if there are port definitions, 
# A: if protocol is icmp, assume the port definition is meant as icmp_type,
# set according values to reflect the changes
# B: which are only valid with either tcp, or udp
if [[ ${arg_list_sport[OPTION_LIST_IDX]} || ${arg_list_dport[OPTION_LIST_IDX]} ]]; then
	if [[ -z ${arg_list_proto[OPTION_LIST_IDX]} ]]; then
		log -E "Protocol is undefined. Port specifications are only valid with the tcp, udp or sctp protocol."
		return 1
	else
		# see if protocol is icmp
		if [[ $(string_tolower "${arg_list_proto[OPTION_LIST_IDX]}") = icmp ]]; then
			# register the icmp type and unset the port definitions
			if [[ ${arg_list_sport[OPTION_LIST_IDX]} ]]; then
				arg_list_icmp_type[OPTION_LIST_IDX]="${arg_list_sport[OPTION_LIST_IDX]}"
				unset arg_list_sport[OPTION_LIST_IDX] arg_list_dport[OPTION_LIST_IDX]
			else
				arg_list_icmp_type[OPTION_LIST_IDX]="${arg_list_dport[OPTION_LIST_IDX]}"
				unset arg_list_dport[OPTION_LIST_IDX]
			fi
			for pos_idx in ${!tmp_pos_par_val_array[@]}; do
				[[ ${tmp_pos_par_val_array[pos_idx]%% *} = @(sport|dport) ]] && {
					unset tmp_pos_par_val_array[pos_idx]
					local -i del_idx=${pos_idx}
				}
			done
			# set positional param array entry
			tmp_pos_par_val_array[${del_idx}]="icmp_type ${arg_list_icmp_type[OPTION_LIST_IDX]}"
			for pos_idx in $(arr_indicies arr_tmp_rule_opt_${OPTION_LIST_IDX}); do
				[[ $(subst_var "arr_tmp_rule_opt_${OPTION_LIST_IDX}[${pos_idx}]") = @(sport|dport) ]] && {
					unset arr_tmp_rule_opt_${OPTION_LIST_IDX}[pos_idx]
					del_idx=${pos_idx}
				}
			done
			# set rule option array entry
			eval arr_tmp_rule_opt_${OPTION_LIST_IDX}[${del_idx}]="icmp_type"
		fi
	fi
fi
# if icmp types are specifed, check if protocol is icmp
if [[ ${arg_list_icmp_type[OPTION_LIST_IDX]} && $(string_tolower "${arg_list_proto[OPTION_LIST_IDX]:-0}") != @(icmp|1) ]]; then
	log -E "ICMP types are specified, but protocol is not icmp."
	return 1
#	}
fi
# if connlimit match is used, check if protocol is tcp and syn packets are selected
if [[ ${arg_list_connlimit[OPTION_LIST_IDX]} ]]; then
	[[ $(string_tolower "${arg_list_proto[OPTION_LIST_IDX]:-0}") = @(tcp|6) ]] || {
		log -E "Connlimit is only valid with tcp."
		return 1
	}
	if ! [[ $(string_tolower "${arg_list_tcp_syn[OPTION_LIST_IDX]:-0}") = @(s|sy|syn) || ${arg_list_tcp_flags[OPTION_LIST_IDX]} = FIN,SYN,RST,ACK:SYN ]]; then
		log -E "Connlimit is only valid with tcp SYN."
		return 1
	fi
fi
} # -------------------------------------------------------------------------

_validate_option_values() { # validate the rule given values
local -i pos_idx arg_idx
local str str_var tmp_opt_var tmp_opt_var_value tmp_opt_var_value_neg_ok
table_in_rule=0 target_in_rule=0 chain_in_rule=0 state_in_rule=0 multi_icmp_types=0 multi_source_ports=0
multi_destination_ports=0 multi_protocols=0 multi_input_devices=0 multi_output_devices=0
# if the table is not defined in the template, clear it to not reuse the value of the previous loop
((table_in_template == 0)) && table=""

[[ $DEBUG_INFO ]] && {
	pr_str "tmp_pos_par_val_array in ${FUNCNAME}():"
	dbg_arr "tmp_pos_par_val_array"
}

for pos_idx in ${!tmp_pos_par_val_array[@]}; do
	tmp_opt_var="${tmp_pos_par_val_array[pos_idx]%% *}"
#	tmp_opt_var_value="${tmp_pos_par_val_array[pos_idx]##* }"
	tmp_opt_var_value="${tmp_pos_par_val_array[pos_idx]#* }"
	tmp_opt_var_value_neg_ok=$(remove_negation "$tmp_opt_var_value")
	case "$tmp_opt_var" in
		(table)
			val_table "$tmp_opt_var_value" || return 1
			((table_in_template == 1)) && {
				log -N "Table definition \`$tmp_opt_var_value' from option list \
					overwrites entry \`$table' from template."
			}
			table="$tmp_opt_var_value"
			table_in_rule=1
		;;
		(target)
			((target_in_template == 1)) && {
				log -N "Target definition \`$tmp_opt_var_value' from option list \
					overwrites entry \`${arr_tmp_targets[*]}' from template."
			}
			arg_list_target=()
#			for str_var in $(IFS=, split_val $tmp_opt_var_value); do
			for str_var in ${tmp_opt_var_value//,/ }; do
				validate_target "$str_var" || return 1
				arg_list_target[${#arg_list_target[@]}]="$str_var"
			done
			target_in_rule=1 # there is a target definition in the rule
		;;
		(chain)
			((chain_in_template == 1)) && {
				log -N "Chain definition \`$tmp_opt_var_value' from option list \
					overwrites entry \`${arr_tmp_chains[*]}' from template."
			}
			arg_idx=$(($(IFS=, members_in_string $tmp_opt_var_value) - 1))
			chain_max=$((chain_max == -1 ? arg_idx : chain_max))
			if ((arg_idx > chain_max)); then
				log -E "Not more than $((chain_max + 1)) chain specifications allowed."
				return 1
			fi
			arg_list_chain=()
			arg_idx=0
#			for str_var in $(IFS=, split_val $tmp_opt_var_value); do
			for str_var in  ${tmp_opt_var_value//,/ }; do
				val_userdef_chain_target "$str_var" || return 1
				arg_list_chain[${#arg_list_chain[@]}]="$str_var"
				((++arg_idx > chain_max)) && break
			done
			chain_in_rule=1 # there is a chain definition in the rule
		;;
		(idev|odev)
			if (($(IFS=, members_in_string $tmp_opt_var_value) > 1)); then
				val_multi_device "$tmp_opt_var_value" || return 1
				case "$tmp_opt_var" in
					(idev)
						multi_input_devices=1
						str_multi_input_devices="$tmp_opt_var_value"
					;;
					(odev)
						multi_output_devices=1
						str_multi_output_devices="$tmp_opt_var_value"
					;;
				esac
			else
				val_ifname "$tmp_opt_var_value_neg_ok" || return 1
			fi
		;;
		(src|dst)
			# see if the address specified matches a net name
			if [[ $tmp_opt_var_value_neg_ok = @(${NET_NAME_LIST//[[:space:]]/|}) ]]; then
				if string_negated "$tmp_opt_var_value"; then
					str_var="!$(get_net_addr "$tmp_opt_var_value_neg_ok")"
				else
					str_var=$(get_net_addr "$tmp_opt_var_value")
				fi
				[[ $str_var ]] || {
					log -E "Unable to retrieve address for net \`$tmp_opt_var_value_neg_ok'."
					return 1
				}
				for arg_idx in "${!arg_list_src[@]}"; do
					if [[ ${arg_list_src[arg_idx]} = $tmp_opt_var_value ]]; then
						arg_list_src[arg_idx]="$str_var"
					fi
				done
				for arg_idx in "${!arg_list_dst[@]}"; do
					if [[ ${arg_list_dst[arg_idx]} = $tmp_opt_var_value ]]; then
						arg_list_dst[arg_idx]="$str_var"
					fi
				done
			else
				val_ip4_addr "$tmp_opt_var_value_neg_ok" || return 1
				if [[ ${IPSTRING} = IPRANGE ]]; then
					((iprange_MOD_EXIST)) || { log -s 'iprange'; return 1; }
				fi
			fi
		;;
		(mac)
			((mac_MOD_EXIST)) || { log -s 'mac'; return 1; }
			val_mac "$tmp_opt_var_value_neg_ok" || return 1
		;;
		(nfqueue)
			((NFQUEUE_TGT_EXIST)) || { log -t 'NFQUEUE'; return 1; }
			case "$tmp_opt_var_value" in
				+([[:digit:]]))
					if ! val_16bit "$tmp_opt_var_value"; then
						log -i "$tmp_opt_var_value" "queue number"
						return 1
					fi
				;;
				+([[:digit:]]):+([[:digit:]])) # support --queue-balance - TO DO: check if system supports
					for arg_idx in ${tmp_opt_var_value/:/ }; do
						if ! val_16bit "${arg_idx}"; then
							log -i "${arg_idx}" "queue number"
							return 1
						fi
					done
					val_range "${tmp_opt_var_value%:*}" "${tmp_opt_var_value#*:}" || return 1
				;;
				*) log -i "$tmp_opt_var_value" "nfqueue descriptor"
					return 1
			esac
		;;
		(helper)
			((helper_MOD_EXIST)) || { log -s 'helper'; return 1; }
			case "$tmp_opt_var_value" in
				+([[:word:]])) : ;;
				+([[:word:]])-*)
					val_port "${tmp_opt_var_value#+([[:word:]])-}" || return 1
				;;
				*) log -i "$tmp_opt_var_value" "conntrack helper descriptor"
					return 1
			esac
		;;
		(m_ecn)
			((ecn_MOD_EXIST)) || { log -s 'ecn'; return 1; }
			set -- $(split_val : ' ' "$tmp_opt_var_value")
			check_str_unique "$*" || return 1
			while (($#)); do
				case "$1" in
					?(\!)ip-ect)
						val_numeric "$2"
						(($2 >= 0 && $2 <=3)) || {
							log -E "ecn-ip-ect value is out of range, expecting value of 0-3."
							return 1
						}
						shift 2
					;;
					?(\!)@(tcp-cwr|tcp-ece))
						shift
					;;
					*) log -i "$tmp_opt_var_value" "ecn match descriptor"
						return 1
				esac
			done
		;;
		(devgroup)
			((devgroup_MOD_EXIST)) || { log -s 'devgroup'; return 1; }
			set -- $(split_val : ' ' "$tmp_opt_var_value")
			check_str_unique "$*" || return 1
			while (($#)); do
				case "$1" in
					?(\!)@(src|dst))
						[[ $2 ]] || {
							log -E "Device group name is missing."
							return 1
						}
						shift 2
					;;
					*) log -i "$tmp_opt_var_value" "devgroup match descriptor"
						return 1
				esac
			done
		;;
		(owner)
			((owner_MOD_EXIST)) || { log -s 'owner'; return 1; }
			set -- ${tmp_opt_var_value//:/ }
			check_str_unique "$*" || return 1
			while (($#)); do
				case "$1" in
					?(\!)@(uid|gid))
						if [[ $2 = +([[:digit:]])-+([[:digit:]]) ]]; then
							val_range ${2/-/ } || return 1
						fi
						shift 2
					;;
					?(\!)socket)
						shift
					;;
					*) log -i "$tmp_opt_var_value" "owner match descriptor"
						return 1
				esac
			done
		;;
		(length)
			((length_MOD_EXIST)) || { log -s 'length'; return 1; }
			case "$tmp_opt_var_value_neg_ok" in
				+([[:digit:]])) : ;;
				+([[:digit:]]):+([[:digit:]]))
					val_range "${tmp_opt_var_value_neg_ok%:*}" "${tmp_opt_var_value_neg_ok#*:}" || return 1
				;;
				*) log -i "$tmp_opt_var_value" "length descriptor"
					return 1
			esac
		;;
		(osf)
			((osf_MOD_EXIST)) || { log -s 'osf'; return 1; }
			case "$tmp_opt_var_value_neg_ok" in
				+([[:graph:]])*(:+([[:word:]]):@(0|1|2)))
					local str="${tmp_opt_var_value_neg_ok%%:*}"
					str_var="${tmp_opt_var_value_neg_ok#$str}"
					str_var="${str_var#:}"
					while [[ $str_var ]]; do
						local str=${str_var%%:*}
						case "$str" in
							"") break ;;
							log|ttl)
								str_var=${str_var#${str}:}
								if ! [[ ${str_var%%:*} = @(0|1|2) ]]; then
									log -i "$tmp_opt_var_value" "osf descriptor"
									return 1
								fi
								str_var=${str_var#[012]}
								str_var=${str_var#:}
								;;
							*) log -i "$tmp_opt_var_value" "osf descriptor"
								return 1
						esac
					done
				;;
				*) log -i "$tmp_opt_var_value" "osf descriptor"
					return 1
			esac
		;;
		(rpfilter)
			((rpfilter_MOD_EXIST)) || { log -s 'rpfilter'; return 1; }
			case "$tmp_opt_var_value" in
				""|rpfilter) : ;;
			+([[:graph:]])*(:+([[:graph:]])))
					for str_var in $(split_val : ' ' "$tmp_opt_var_value"); do
						case "$str_var" in
							loose|validmark|accept-local|strict) : ;;
							*) log -i "$tmp_opt_var_value" "rpfilter descriptor"
								return 1
						esac
					done
				;;
				*) log -i "$tmp_opt_var_value" "rpfilter descriptor"
					return 1
			esac
		;;
		(fragment)
			if [[ $(string_tolower "$tmp_opt_var_value_neg_ok") != @(f|fr|fra|frag|fragm|fragme|fragmen|fragment) ]]; then
				log -i "$tmp_opt_var_value" "fragment descriptor"
				return 1
			fi
		;;
		(proto)
			if (($(IFS=, members_in_string $tmp_opt_var_value) > 1)); then
				val_multi_proto "$tmp_opt_var_value" || return 1
				multi_protocols=1
				str_multi_protocols="$tmp_opt_var_value"
			else
				val_proto "$tmp_opt_var_value_neg_ok" || return 1
			fi
		;;
		(sport|dport)
			# check if option value is a multiport string
			local -i multi_count=$(IFS=, members_in_string $tmp_opt_var_value)
			if ((multi_count > 1)); then
				# if the system does not support the multiport match, save data for later processing
				if ((multiport_MOD_EXIST == 0)); then
					case "$tmp_opt_var" in
						(sport)
							multi_source_ports=1
							str_source_ports="$tmp_opt_var_value"
						;;
						(dport)
							multi_destination_ports=1
							str_destination_ports="$tmp_opt_var_value"
						;;
					esac
				else
					((multi_count > 15)) && {
						log -E "Multiport definitions may contain a maximum of 15 port entries."
						return 1
					}
				fi
				val_multi_ports "$tmp_opt_var_value" || return 1
			else
				val_port "$tmp_opt_var_value_neg_ok" || return 1
			fi
		;;
		(tcp_flags)
			case "$tmp_opt_var_value_neg_ok" in
				+(+([[:alpha:]])?(,)):+(+([[:alpha:]])?(,)))
					val_tcp_flags "$tmp_opt_var_value_neg_ok" || {
						log -i "$tmp_opt_var_value" "TCP flag descriptor"
						return 1
					}
				;;
				*) log -i "$tmp_opt_var_value" "TCP flag descriptor"
					return 1
			esac
		;;
		(tcp_syn)
			if [[ $(string_tolower "$tmp_opt_var_value_neg_ok") != @(s|sy|syn) ]]; then
				log -i "$tmp_opt_var_value" "TCP SYN description"
				return 1
			fi
		;;
		(tcp_option)
			if ! val_numeric_quiet "$tmp_opt_var_value_neg_ok" && val_8bit "$tmp_opt_var_value_neg_ok"; then
				log -i "$tmp_opt_var_value" "TCP option"
				return 1
			fi
		;;
		(icmp_type)
			# check if there are multiple icmp types
			if (($(IFS=, members_in_string $tmp_opt_var_value) > 1)); then
				val_icmp_types "$tmp_opt_var_value" || return 1
				# set values so we know it later
				multi_icmp_types=1
				str_icmp_types="$tmp_opt_var_value"
			else
				val_icmp_type "$tmp_opt_var_value_neg_ok" || return 1
			fi
		;;
		(state)
			((state_MOD_EXIST)) || { log -s 'state'; return 1; }
			val_state "$tmp_opt_var_value_neg_ok" || return 1
			# remember that there is a state match definition in the rule
			state_in_rule=1
		;;
		(sctp)
			((sctp_MOD_EXIST)) || { log -s 'sctp'; return 1; }
			case "$tmp_opt_var_value_neg_ok" in
				@(all|any|only)?(:*))
					tmp_opt_var_value_neg_ok="${tmp_opt_var_value_neg_ok#@(all|any|only)}"
					case "$tmp_opt_var_value_neg_ok" in
						"") log -E "Missing sctp chunk type(s)."
							return 1
						;;
						:*) val_sctp_chunk_types "${tmp_opt_var_value_neg_ok#:}" || return 1
					;;
					esac
				;;
				*) log -i "$tmp_opt_var_value" "sctp descriptor"
					return 1
			esac
		;;
		(limit)
			((limit_MOD_EXIST)) || { log -s 'limit'; return 1; }
			val_limit "$tmp_opt_var_value_neg_ok" || return 1
		;;
		(limit_burst)
			((limit_MOD_EXIST)) || { log -s 'limit'; return 1; }
			val_limit_burst "$tmp_opt_var_value" || return 1
		;;
		(connbytes)
			((connbytes_MOD_EXIST)) || { log -s 'connbytes'; return 1; }
			[[ $tmp_opt_var_value_neg_ok = @(original|reply|both):@(packets|bytes|avgpkt):+([[:digit:]])?(:+([[:digit:]])) ]] || {
				log -i "$tmp_opt_var_value" "connbytes descriptor"
				return 1
			}
		;;
		(connlimit)
			((connlimit_MOD_EXIST)) || { log -s 'connlimit'; return 1; }
			case "$tmp_opt_var_value_neg_ok" in
				+([[:digit:]])|+([[:digit:]])/+([[:digit:]])) : ;;
				*) log -i "$tmp_opt_var_value" "connlimit descriptor"
					return 1
			esac
		;;
		(ctstate)
			((conntrack_MOD_EXIST)) || { log -s 'conntrack'; return 1; }
			case "$(string_toupper "$tmp_opt_var_value_neg_ok")" in
				NEW|ESTABLISHED|RELATED|INVALID|UNTRACKED|SNAT|DNAT) : ;;
				*) log -i "$tmp_opt_var_value" "$tmp_opt_var descriptor"
					return 1
			esac
		;;
		(ctproto)
			((conntrack_MOD_EXIST)) || { log -s 'conntrack'; return 1; }
			val_proto "$tmp_opt_var_value_neg_ok" || return 1
		;;
		(ctorigsrc|ctorigdst|ctreplsrc|ctrepldst)
			((conntrack_MOD_EXIST)) || { log -s 'conntrack'; return 1; }
			val_ipv4_addr_no_range "$tmp_opt_var_value_neg_ok" || return 1
		;;
		(ctorigsrcport|ctorigdstport|ctreplsrcport|ctrepldstport)
			((conntrack_MOD_EXIST)) || { log -s 'conntrack'; return 1; }
			case "$tmp_opt_var_value_neg_ok" in
				+([[:digit:]])) 
					for arg_idx in ${!tmp_pos_par_val_array[@]}; do # TO DO: DOES IT REFER TO PROTO OR CTPROTO?
						if [[ ${tmp_pos_par_val_array[pos_idx]%% *} = proto ]]; then
							if [[ $(string_tolower "${tmp_pos_par_val_array[pos_idx]#* }") = @(gre|47) ]]; then
								val_32bit "$tmp_opt_var_value_neg_ok" || {
									log -i "$tmp_opt_var_value" "$tmp_opt_var descriptor"
									return 1
								}
							else
								val_port "$tmp_opt_var_value_neg_ok" || return 1
							fi
							break
						fi
					done
				;;
				*) val_port "$tmp_opt_var_value_neg_ok" || return 1
			esac
		;;
		(ctstatus)
			((conntrack_MOD_EXIST)) || { log -s 'conntrack'; return 1; }
			case "$(string_toupper "$tmp_opt_var_value_neg_ok")" in
				NONE|EXPECTED|SEEN_REPLY|ASSURED|CONFIRMED) : ;;
				*) log -i "$tmp_opt_var_value" "$tmp_opt_var descriptor"
					return 1
			esac
		;;
		(ctexpire)
			((conntrack_MOD_EXIST)) || { log -s 'conntrack'; return 1; }
			case "$tmp_opt_var_value_neg_ok" in
				+([[:digit:]])) : ;;
				+([[:digit:]]):+([[:digit:]]))
					set -- ${tmp_opt_var_value_neg_ok/:/ }
					(($2 >= $1)) || {
						log -E "$tmp_opt_var min. range value \`$1' greater than max. range value \`$2'."
						return 1
					}
				;;
				*) log -i "$tmp_opt_var_value" "$tmp_opt_var descriptor"
					return 1
			esac
		;;
		(ctdir)
			((conntrack_MOD_EXIST)) || { log -s 'conntrack'; return 1; }
			[[ $tmp_opt_var_value = @(ORIGINAL|REPLY) ]] || {
				log -E "Invalid value \`$tmp_opt_var_value' for \`$tmp_opt_var' descriptor. Valid content is: ORIGINAL or REPLY."
				return 1
			}
		;;
		(log_level)
			((LOG_TGT_EXIST)) || { log -t 'LOG'; return 1; }
			val_loglevel "$tmp_opt_var_value" || return 1
		;;
		(log_prefix)
			((LOG_TGT_EXIST)) || { log -t 'LOG'; return 1; }
			if ((${#tmp_opt_var_value} > 28)); then
				log -E "Log prefix value \`$tmp_opt_var_value' longer then 28 characters."
				return 1
			fi
		;;
		(log_options)
			((LOG_TGT_EXIST)) || { log -t 'LOG'; return 1; }
			for str_var in ${tmp_opt_var_value//,/ }; do
#			for str_var in $(IFS=, split_val $tmp_opt_var_value); do
				[[ $str_var = @(log_tcp_seq|log_tcp_opt|log_ip_opt|log_uid) ]] || {
					log -E "Invalid value \`$str_var' in \`$tmp_opt_var_value' for \`$tmp_opt_var'."
					return 1
				}
			done
		;;
		(nflog_group)
			((NFLOG_TGT_EXIST)) || { log -t 'NFLOG'; return 1; }
			case "$tmp_opt_var_value" in
				+([[:digit:]])) 
					val_32bit_off1 "$tmp_opt_var_value" || {
						log -E "NFLOG netlink group value is out of range. Allowed range: 1-4294967295."
						return 1
					}
				;;
				*) log -i "$tmp_opt_var_value" "NFLOG netlink group descriptor"
					return 1
			esac
		;;
		(nflog_prefix)
			((NFLOG_TGT_EXIST)) || { log -t 'NFLOG'; return 1; }
			if ((${#tmp_opt_var_value} > 63)); then
				log -E "NFLOG prefix value \`$tmp_opt_var_value' longer then 63 characters."
				return 1
			fi
		;;
		(nflog_range)
			((NFLOG_TGT_EXIST)) || { log -t 'NFLOG'; return 1; }
			val_numeric_quiet "$tmp_opt_var_value" || {
				log -i "$tmp_opt_var_value" "NFLOG byte size descriptor"
				return 1
			}
		;;
		(nflog_thresh)
			((NFLOG_TGT_EXIST)) || { log -t 'NFLOG'; return 1; }
			val_numeric_quiet "$tmp_opt_var_value" || {
				log -i "$tmp_opt_var_value" "NFLOG threshold size descriptor"
				return 1
			}
		;;
		(ulog_group)
			((ULOG_TGT_EXIST)) || { log -t 'ULOG'; return 1; }
			case "$tmp_opt_var_value" in
				+([[:digit:]])) 
					((tmp_opt_var_value >= 1 || tmp_opt_var_value <= 32)) || {
						log -E "ULOG netlink group value is out of range. Allowed range: 1-32."
						return 1
					}
				;;
				*) log -i "$tmp_opt_var_value" "ULOG netlink group descriptor"
					return 1
			esac
		;;
		(ulog_prefix)
			((ULOG_TGT_EXIST)) || { log -t 'ULOG'; return 1; }
			if ((${#tmp_opt_var_value} > 31)); then
				log -E "ULOG prefix value \`$tmp_opt_var_value' longer then 31 characters."
				return 1
			fi
		;;
		(ulog_range)
			((ULOG_TGT_EXIST)) || { log -t 'ULOG'; return 1; }
			val_numeric_quiet "$tmp_opt_var_value" || {
				log -i "$tmp_opt_var_value" "ULOG byte size descriptor"
				return 1
			}
		;;
		(ulog_thresh)
			((ULOG_TGT_EXIST)) || { log -t 'ULOG'; return 1; }
			case "$tmp_opt_var_value" in
				+([[:digit:]])) 
					((tmp_opt_var_value >= 1 || tmp_opt_var_value <= 50)) || {
						log -E "ULOG queue threshold value is out of range. Allowed range: 1-50."
						return 1
					}
					;;
				*) log -i "$tmp_opt_var_value" "ULOG queue threshold descriptor"
					return 1
			esac
		;;
		(addrtype)
			((addrtype_MOD_EXIST)) || { log -s 'addrtype'; return 1; }
			case "${tmp_opt_var_value_neg_ok%:*}" in
				src|dst) : ;;
				*) log -i "$tmp_opt_var_value" "addrtype descriptor."
					return 1
			esac
			case "${tmp_opt_var_value_neg_ok#*:}" in
				UNSPEC|UNICAST|LOCAL|BROADCAST|ANYCAST|MULTICAST|BLACKHOLE|UNREACHABLE|PROHIBIT|THROW|NAT|XRESOLVE) : ;;
				*) log -i "$tmp_opt_var_value" "addrtype descriptor"
					return 1
			esac
		;;
		(pkttype)
			((pkttype_MOD_EXIST)) || { log -s 'pkttype'; return 1; }
			case "$tmp_opt_var_value_neg_ok" in
				unicast|broadcast|multicast) : ;;
				*) log -i "$tmp_opt_var_value" "pkttype descriptor"
					return 1
			esac
		;;
		(socket)
			((socket_MOD_EXIST)) || { log -s 'socket'; return 1; }
			if [[ $(string_tolower "$tmp_opt_var_value") != @(s|so|soc|sock|socke|socket|transparent) ]]; then
				log -i "$tmp_opt_var_value" "socket descriptor"
				return 1
			fi
		;;
		(t_mark)
			((MARK_TGT_EXIST)) || { log -t 'MARK'; return 1; }
			case "$tmp_opt_var_value" in
				?(@(set|xset):)?(0x)+([[:xdigit:]])?(/?(0x)+([[:xdigit:]]))) : ;;
				@(and|or|xor):?(0x)+([[:xdigit:]])) : ;;
				*) log -i "$tmp_opt_var_value" "MARK value descriptor"
					return 1
			esac
			local str_msk=""
			if [[ $tmp_opt_var_value = */* ]]; then
				local str_mrk="${tmp_opt_var_value%/*}" str_msk="${tmp_opt_var_value#*/}"
				local str_mrk=${str_mrk/@(@(and|or|set|xset|xor):)/}
			else
				local str_mrk=${tmp_opt_var_value/@(@(and|or|set|xset|xor):)/}
			fi
			if [[ ${str_mrk} ]]; then
				val_nf_mark "${str_mrk}" || return 1
			fi
			if [[ ${str_msk} ]]; then
				val_nf_mark "${str_msk}" || return 1
			fi
		;;
		(t_connmark)
			((CONNMARK_TGT_EXIST)) || { log -t 'CONNMARK'; return 1; }
			case "$tmp_opt_var_value" in
				@(save|restore)?(:?(0x)*([[:xdigit:]]))?(/?(0x)+([[:xdigit:]]))) : ;;
				@(set|xset):?(0x)+([[:xdigit:]])?(/?(0x)+([[:xdigit:]]))) : ;;
				@(and|or|xor):?(0x)+([[:xdigit:]])) : ;;
				*) log -i "$tmp_opt_var_value" "CONNMARK value descriptor"
					return 1
			esac
			local str_msk=""
			if [[ $tmp_opt_var_value = */* ]]; then
				local str_mrk="${tmp_opt_var_value%/*}" str_msk="${tmp_opt_var_value#*/}"
				local str_mrk=${str_mrk/@(@(and|or|set|xset|xor|save|restore)?(:))/}
			else
				local str_mrk=${tmp_opt_var_value/@(@(and|or|set|xset|xor|save|restore)?(:))/}
			fi
			if [[ $tmp_opt_var_value = @(save|restore)* && ${str_mrk} && -z ${str_msk} ]]; then
				log -E "If nfmask is specified, ctmask is mandatory."
				return 1
			fi
			if [[ ${str_mrk} ]]; then
				val_nf_mark "${str_mrk}" || return 1
			fi
			if [[ ${str_msk} ]]; then
				val_nf_mark "${str_msk}" || return 1
			fi
		;;
		(t_secmark)
			((SECMARK_TGT_EXIST)) || { log -t 'SECMARK'; return 1; }
			# TODO: how to check for valid SElinux context
		;;
		(t_connsecmark)
			((CONNSECMARK_TGT_EXIST)) || { log -t 'CONNSECMARK'; return 1; }
			[[ $tmp_opt_var_value = @(s|sa|sav|save|r|re|res|rest|resto|restore) ]] || {
				log -i "$tmp_opt_var_value" "CONNSECMARK option descriptor"
				return 1
			}
		;;
		(m_mark)
			((mark_MOD_EXIST)) || { log -s 'mark'; return 1; }
			case "$tmp_opt_var_value_neg_ok" in
				?(0x)+([[:xdigit:]])|?(0x)+([[:xdigit:]])/?(0x)+([[:xdigit:]])) : ;;
				*) log -i "$tmp_opt_var_value" "mark match descriptor"
					return 1
			esac
			local str_mrk="${tmp_opt_var_value_neg_ok%/*}" str_msk="${tmp_opt_var_value_neg_ok#*/}"
			val_nf_mark "${str_mrk}" || return 1
			if [[ ${str_msk} ]]; then
				val_nf_mark "${str_msk}" || return 1
			fi
		;;
		(m_connmark)
			((connmark_MOD_EXIST)) || { log -s 'connmark'; return 1; }
			case "$tmp_opt_var_value_neg_ok" in
				?(0x)+([[:xdigit:]])|?(0x)+([[:xdigit:]])/?(0x)+([[:xdigit:]])) : ;;
				*) log -i "$tmp_opt_var_value" "connmark match descriptor"
					return 1
			esac
			local str_mrk="${tmp_opt_var_value_neg_ok%/*}" str_msk="${tmp_opt_var_value_neg_ok#*/}"
			val_nf_mark "${str_mrk}" || return 1
			if [[ ${str_msk} ]]; then
				val_nf_mark "${str_msk}" || return 1
			fi
		;;
		(m_cpu)
			((cpu_MOD_EXIST)) || { log -s 'cpu'; return 1; }
			val_numeric "$tmp_opt_var_value_neg_ok" || return 1
		;;
		(m_quota)
			((quota_MOD_EXIST)) || { log -s 'quota'; return 1; }
			val_numeric "$tmp_opt_var_value_neg_ok" || return 1
		;;
		(m_tcpmss)
			((tcpmss_MOD_EXIST)) || { log -s 'tcpmss'; return 1; }
			case "$tmp_opt_var_value_neg_ok" in
				+([[:digit:]])|+([[:digit:]]):+([[:digit:]])) : ;;
				*) log -i "$tmp_opt_var_value" "tcpmss match descriptor"
					return 1
			esac
		;;
		(m_dscp)
			((dscp_MOD_EXIST)) || { log -s 'dscp'; return 1; }
			val_dscp "$tmp_opt_var_value_neg_ok" || return 1
		;;
		(t_dscp)
			((DSCP_TGT_EXIST)) || { log -t 'DSCP'; return 1; }
			val_dscp "$tmp_opt_var_value_neg_ok" || return 1
		;;
		(tee_gw)
			((TEE_TGT_EXIST)) || { log -t 'TEE'; return 1; }
			val_ip4_ip "$tmp_opt_var_value" || return 1
			if [[ $tmp_opt_var_value = 0.0.0.0 ]]; then
				log -i "$tmp_opt_var_value" "TEE gateway descriptor"
			fi
		;;
		(m_tos)
			((tos_MOD_EXIST)) || { log -s 'tos'; return 1; }
			case "$tmp_opt_var_value_neg_ok" in
				+([[:digit:]])|?(0x)+([[:xdigit:]])|+([[:word:]])-+([[:word:]]))
					val_tos "$tmp_opt_var_value_neg_ok" || return 1
				;;
				+([[:digit:]])/+([[:digit:]])|?(0x)+([[:xdigit:]])/?(0x)+([[:xdigit:]]))
					val_tos "${tmp_opt_var_value_neg_ok%/*}" || return 1
					val_32bit "${tmp_opt_var_value_neg_ok#*/}" || {
						log -E "tos mask \`${tmp_opt_var_value_neg_ok#*/}' is out of bounds."
						return 1
					}
				;;
				*) log -i "$tmp_opt_var_value" "tos match descriptor"
					return 1
			esac
		;;
		(m_set)
			((set_MOD_EXIST)) || { log -s 'set'; return 1; }
			case "$tmp_opt_var_value_neg_ok" in
				*:@(src|dst)*(,@(src|dst)))
					val_set_flags "${tmp_opt_var_value_neg_ok#*:}" || return 1
				;;
				*) log -i "$tmp_opt_var_value" "set match descriptor"
					return 1
			esac
		;;
		(t_set)
			((SET_TGT_EXIST)) || { log -t 'SET'; return 1; }
			case "$tmp_opt_var_value" in
				@(add|del):*:@(src|dst)*(,@(src|dst)))
					val_set_flags "${tmp_opt_var_value##*:}" || return 1
				;;
				*) log -i "$tmp_opt_var_value" "SET option descriptor"
					return 1
			esac
		;;
		(ahspi)
			((ah_MOD_EXIST)) || { log -s 'ah'; return 1; }
			val_spi "$tmp_opt_var_value_neg_ok" || return 1
		;;
		(espspi)
			((esp_MOD_EXIST)) || { log -s 'esp'; return 1; }
			val_spi "$tmp_opt_var_value_neg_ok" || return 1
		;;
		(audit)
			((AUDIT_TGT_EXIST)) || { log -t 'AUDIT'; return 1; }
			case "$tmp_opt_var_value" in
				accept|drop|reject) : ;;
				*) log -i "$tmp_opt_var_value" "AUDIT option descriptor"
					return 1
			esac
		;;
		(t_class)
			((CLASSIFY_TGT_EXIST)) || { log -t 'CLASSIFY'; return 1; }
			case "$tmp_opt_var_value" in
				?(0x)+([[:xdigit:]])| ?(0x)+([[:xdigit:]]):?(0x)+([[:xdigit:]])) : ;;
				*) log -i "$tmp_opt_var_value" "class"
					return 1
			esac
		;;
		(t_tos)
			((TOS_TGT_EXIST)) || { log -t 'TOS'; return 1; }
			case "$tmp_opt_var_value" in
				+([[:alpha:]])-+([[:alpha:]]) | +([[:digit:]]) | 0x+([[:xdigit:]]))
					val_tos "$tmp_opt_var_value" || return 1
				;;
				+([[:digit:]])/+([[:digit:]]) | ?(0x)+([[:xdigit:]])/?(0x)+([[:xdigit:]]))
					val_tos "${tmp_opt_var_value%/*}" || return 1
					val_8bit "${tmp_opt_var_value#*/}" || {
						log -i "${tmp_opt_var_value#*/}" "TOS mask"
						return 1
					}
				;;
				@(and|or|xor):@(+([[:digit:]])|0x+([[:xdigit:]])))
					val_tos "${tmp_opt_var_value#@(and|or|xor):}" || return 1
				;;
				*) log -i "$tmp_opt_var_value" "TOS option descriptor"
					return 1
			esac
		;;
		(t_tcpmss)
			((TCPMSS_TGT_EXIST)) || { log -t 'TCPMSS'; return 1; }
			case "$tmp_opt_var_value" in
				pmtu|+([[:digit:]])) : ;;
				*) log -i "$tmp_opt_var_value" "TCPMSS option descriptor"
					return 1
			esac
		;;
		(tproxy_opt)
			((TPROXY_TGT_EXIST)) || { log -t 'TPROXY'; return 1; }
			local -i tproxy_port_opt_set=0
			set -- ${tmp_opt_var_value//:/ }
			while (($#)); do
				case "$1" in
					port)
						if [[ $2 ]]; then
							val_port "$2" || return 1
							tproxy_port_opt_set=1
						else
							log -E "TPROXY port specification is missing."
							return 1
						fi
						shift
					;;
					ip)
						if [[ $2 ]]; then
							val_ip4_addr "$2" || return 1
							[[ ${IPSTRING} = IPADDR ]] || {
								log -E "TPROXY option \`$2' is not a valid IP address."
								return 1
							}
						else
							log -E "TPROXY ip specification is missing."
							return 1
						fi
						shift
					;;
					mark)
						case "$2" in
							"") log -E "TPROXY mark specification is missing."
								return 1
							;;
							?(0x)+([[:xdigit:]])|?(0x)+([[:xdigit:]])/?(0x)+([[:xdigit:]])) : ;;
							*) log -i "$2" "TPROXY mark descriptor"
								return 1
						esac
						local str_mrk="${2%/*}" str_msk="${2#*/}"
						val_nf_mark "${str_mrk}" || return 1
						if [[ ${str_msk} ]]; then
							val_nf_mark "${str_msk}" || return 1
						fi
						shift
					;;
					*) log -i "$tmp_opt_var_value" "TPROXY option descriptor"
						return 1
				esac
				shift
			done
			((tproxy_port_opt_set == 1)) || {
				log -E "The TPROXY target requires the port option to be set."
				return 1
			}
		;;
		(tcpoptstrip)
			((TCPOPTSTRIP_TGT_EXIST)) || { log -t 'TCPOPTSTRIP'; return 1; }
			for str_var in ${tmp_opt_var_value//,/ }; do
#			for str_var in $(IFS=, split_val $tmp_opt_var_value); do
				case "$str_var" in
					+([[:digit:]]))
						if val_bool_bin "$str_var"; then
							log -E "TCPOPTSTRIP option may not be 0 or 1."
							return 1
						else
							val_8bit "$str_var" || {
								log -E "TCPOPTSTRIP option value \`$str_var' is out of bounds. Allowed range: 2 - 255."
								return 1
							}
						fi
					;;
					wscale|mss|sack-permitted|sack|timestamp|md5) : ;;
					*) log -E "Invalid value \`$str_var' for TCPOPTSTRIP option descriptor in \`$tmp_opt_var_value'."
						return 1
				esac
			done
		;;
		(nat_ip)
			validate_nat_ip "$tmp_opt_var_value" || return 1
		;;
		(nat_port)
			val_nat_port "$tmp_opt_var_value" || return 1
		;;
		(nat_option)
			case "$tmp_opt_var_value" in
				random)
					if ((KERN_VER[0] == 2)); then
						if ((KERN_VER[1] < 6)); then
							log -E "NAT \`random' option requires kernel versions greater or equal to \`2.6.21'."
							return 1
						elif ((KERN_VER[1] == 6 && KERN_VER[2] < 21)); then
							log -E "NAT \`random' option requires kernel versions greater or equal to \`2.6.21'."
							return 1
						fi
					fi
				;;
				persistent)
					if ((KERN_VER[0] == 2)); then
						if ((KERN_VER[1] < 6)); then
							log -E "NAT \`persistent' option requires kernel versions greater or equal to \`2.6.29'."
							return 1
						elif ((KERN_VER[1] == 6 && KERN_VER[2] < 29)); then
							log -E "NAT \`persistent' option requires kernel versions greater or equal to \`2.6.29'."
							return 1
						fi
					fi
				;;
				*) log -i "$tmp_opt_var_value" "NAT option descriptor"
					return 1
			esac
		;;
		(t_ttl|m_ttl)
			case "$tmp_opt_var" in
				m_ttl)
					((ttl_MOD_EXIST)) || { log -s 'ttl'; return 1; }
				;;
				t_ttl)
					((TTL_TGT_EXIST)) || { log -t 'TTL'; return 1; }
				;;
			esac
			case "$tmp_opt_var_value" in
				(+([[:digit:]]))
					val_ttl $tmp_opt_var_value || return 1
				;;
				("+"+([[:digit:]]))
					val_ttl ${tmp_opt_var_value/+/} || return 1
				;;
				("-"+([[:digit:]]))
					val_ttl ${tmp_opt_var_value/-/} || return 1 
				;;
				(*) log -E "Illegal TTL value \`$tmp_opt_var_value'"
					return 1
			esac
		;;
		(reject_type) # to be verified in _post_multiply_checks
			((REJECT_TGT_EXIST)) || { log -t 'REJECT'; return 1; }
		;;
		(comment)
			((comment_MOD_EXIST)) || { log -s 'comment'; return 1; }
			if ((${#tmp_opt_var_value} > 256)); then
				log -E "Comment is longer than 256 characters: \`$tmp_opt_var_value'."
				return 1
			fi
		;;
		*) log -o "$tmp_opt_var" $FUNCNAME || return 1 ;;
	esac
done
} # -------------------------------------------------------------------------

_post_data_collection_checks() {
# check for configuration errors in the rule provided by the user.
# These checks can be done now, as all information, including targets and
# chains, is collected now.
if ((multi_input_devices == 1 && multi_output_devices == 1)); then
	log -E "Either the input device or output device option may contain a multi device list, not both."
	return 1
fi
if ((multi_source_ports == 1 && multi_destination_ports == 1)); then
	log -E "System does not support the multiport match, so either the source \
		or the destination port option may contain a multi port list, not both."
	return 1
fi
# rare error condition, if rule is a reverse rule and only one chain is specified
# and that chain is either INPUT or OUTPUT and we have an input or output device
# definition, the rule may cause empty interface strings
if ((reverse_rule == 1 && ${#arg_list_chain[@]} == 1)); then
	if [[ ${arg_list_chain[0]} = @(INPUT|OUTPUT) && ${JUMP_TREE[1]} = interface ]]; then
		if ((${#arg_list_idev[@]} > 0 || ${#arg_list_odev[@]} > 0)); then
			log -W "This rule could cause empty interface strings: \`"${arr_user_pos_p[*]}"'."
		fi
	fi
fi
local -i target_idx chain_idx ARG_LIST_IDX RULE_LIST_IDX
RULE_LIST_IDX=0
# for every target in the list, do...
# there always must be a target definition, otherwise the whole thing will fail
# if no target is what we want, the user has to specify it as 'empty'
for target_idx in ${!arg_list_target[@]}; do
	ARG_LIST_IDX=0 # reset arg_list counter on each loop
	local str_target="${arg_list_target[target_idx]}"
	for ((chain_idx=0; chain_idx<${#arg_list_chain[@]} && chain_idx<=chain_max; chain_idx++)); do
		
		case "${arg_list_chain[chain_idx]}" in
			INPUT|PREROUTING)
				if [[ ${arg_list_odev[ARG_LIST_IDX]} ]]; then
					log -E "Output device is not valid for \`${arg_list_chain[chain_idx]}' chain."
					return 1
				fi
			;;
			OUTPUT|POSTROUTING)
				if [[ ${arg_list_idev[ARG_LIST_IDX]} ]]; then
					log -E "Input device is not valid for \`${arg_list_chain[chain_idx]}' chain."
					return 1
				fi
			;;
		esac

		if [[ $str_target = @(DSCP|CHECKSUM|ECN|MARK|TCPMSS|TCPOPTSTRIP|TOS|TPROXY|TTL) && $table != mangle ]]; then # targets only valid in mangle table
			log -E "The $str_target target is only valid in the mangle table."
			return 1
		elif [[ $str_target = @(SECMARK|CONNSECMARK) && $table != @(mangle|security) ]]; then # targets only valid in mangle or security table
			log -E "The $str_target target is only valid in the mangle or security table."
			return 1
		elif [[ $str_target = @(DNAT|SNAT|MASQUERADE|NETMAP|REDIRECT) && $table != nat ]]; then # targets only valid in nat table
			log -E "The $str_target target is only valid in the nat table."
			return 1
		fi

		# if CONNMARK match is used with --restore-mark, check if table is mangle
		if [[ ${arg_list_t_connmark[ARG_LIST_IDX]:-0} = restore* && $table != mangle ]]; then
			log -E "restore-mark is only valid in the mangle table."
			return 1
		fi

		if [[ $str_target = NOTRACK && $table != raw ]]; then # NOTRACK is only valid in raw table
			log -E "The $str_target target is only valid in the raw table."
			return 1
		fi

		if [[ ${arg_list_ahspi[ARG_LIST_IDX]} && ${arg_list_proto[ARG_LIST_IDX]} != 51 ]]; then # if ah match is used, check for proto #51
			log -E "The ah match is only valid with protocol #51."
			return 1
		fi

		if [[ ${arg_list_espspi[ARG_LIST_IDX]} && ${arg_list_proto[ARG_LIST_IDX]} != 50 ]]; then # if esp match is used, check for proto #50
			log -E "The esp match is only valid with protocol #50."
			return 1
		fi

		if [[ ${arg_list_osf[ARG_LIST_IDX]} && ${arg_list_proto[ARG_LIST_IDX]} != @(6|tcp) ]]; then # if osf match is used, check for proto tcp
			log -E "The osf match is only valid with the tcp protocol."
			return 1
		fi

		if [[ ${arg_list_rpfilter[ARG_LIST_IDX]} && $table != @(raw|mangle) ]]; then # rpfilter match is only valid in raw and mangle table
			log -E "The rpfilter match is only valid in the raw or mangle table."
			return 1
		fi

		case "$str_target" in # target dependant checks
		# empty target params should not happen, if they are defined as mandatory variable in the template	
		# still we check for them here for safety
			CLASSIFY)
				_val_tgtopt_set "${arg_list_t_class[ARG_LIST_IDX]}" || return 1
			;;
			MARK)
				_val_tgtopt_set "${arg_list_t_mark[ARG_LIST_IDX]}" || return 1
			;;
			CONNMARK)
				_val_tgtopt_set "${arg_list_t_connmark[ARG_LIST_IDX]}" || return 1
			;;
			SECMARK)
				_val_tgtopt_set "${arg_list_t_secmark[ARG_LIST_IDX]}" || return 1
			;;
			CONNSECMARK)
				_val_tgtopt_set "${arg_list_t_connsecmark[ARG_LIST_IDX]}" || return 1
			;;
			CHECKSUM)
				((CHECKSUM_TGT_EXIST)) || { log -t 'CHECKSUM'; return 1; }
			;;
			ECN)
				((ECN_TGT_EXIST)) || { log -t 'ECN'; return 1; }
				if [[ $(string_tolower "${arg_list_proto[ARG_LIST_IDX]:-0}") != @(tcp|6) ]]; then
					log -E "The $str_target target is only valid with the tcp protocol."
					return 1
				fi
			;;
			TCPMSS)
				_val_tgtopt_set "${arg_list_t_tcpmss[ARG_LIST_IDX]}" || return 1
				[[ $(string_tolower "${arg_list_proto[ARG_LIST_IDX]:-0}") = @(tcp|6) ]] || {
					log -E "The $str_target target is only valid with the tcp protocol."
					return 1
				}
				[[ $(string_tolower "${arg_list_tcp_syn[ARG_LIST_IDX]:-_}") = @(s|sy|syn) || ${arg_list_tcp_flags[ARG_LIST_IDX]} = FIN,SYN,RST,ACK:SYN ]] || {
					log -E "The $str_target target is only valid with tcp SYN packets."
					return 1
				}
			;;
			TCPOPTSTRIP)
				_val_tgtopt_set "${arg_list_tcpoptstrip[ARG_LIST_IDX]}" || return 1
				if [[ $(string_tolower "${arg_list_proto[ARG_LIST_IDX]:-0}") != @(tcp|6) ]]; then
					log -E "The $str_target target is only valid with the tcp protocol."
					return 1
				fi
			;;
			TOS)
				_val_tgtopt_set "${arg_list_t_tos[ARG_LIST_IDX]}" || return 1
			;;
			TTL)
				_val_tgtopt_set "${arg_list_t_ttl[ARG_LIST_IDX]}" || return 1
			;;
			DNAT|SNAT|NETMAP) # should not happen if option is defined as mandatory
				check_var_no_sep_silent "${arg_list_nat_ip[ARG_LIST_IDX]}" || {
					log -E "No $str_target target IP address specified."
					return 1
				}
				if [[ ${arg_list_nat_option[ARG_LIST_IDX]} && ${arg_list_nat_option[ARG_LIST_IDX]} = @(random|persistent) && $str_target != @(DNAT|SNAT) ]]
				then
					log -E "\`${arg_list_nat_option[ARG_LIST_IDX]}' is not valid with $str_target target."
					return 1
				fi
			;;
			MASQUERADE|REDIRECT)
				if [[ ${arg_list_nat_option[ARG_LIST_IDX]} && ${arg_list_nat_option[ARG_LIST_IDX]} != random ]]; then
					log -E "\`${arg_list_nat_option[ARG_LIST_IDX]}' is not valid with $str_target target."
					return 1
				else
					if [[ $str_target = REDIRECT ]]; then
						if ((KERN_VER[0] == 2)); then
							if ((KERN_VER[1] < 6)) || ((KERN_VER[1] == 6 && KERN_VER[2] < 22)); then
								log -E "NAT \`random' option requires kernel versions greater or equal to \`2.6.22'."
								return 1
							fi
						fi
					fi
				fi
				
				if [[ ${arg_list_nat_port[ARG_LIST_IDX]} ]]; then # if a nat port is defined
					check_var_no_sep_silent "${arg_list_proto[ARG_LIST_IDX]}" || {
						log -E "Protocol not defined, port specifications with $str_target are only valid with tcp or udp."
						return 1
					}
				fi
			;;
		esac
		case "$table" in # table dependant checks
#			filter)
#			;;
#			security)
#			;;
			mangle)
				if ((ALL_MANGLE_CHAINS_PRESENT == 0)); then
					case "${arg_list_chain[chain_idx]}" in
						INPUT|FORWARD|POSTROUTING)
							log -E "\`${arg_list_chain[chain_idx]}' is not available on current kernel version: $("${UNAME}" -r)."
							return 1
						;;
					esac
				fi
			;;
			nat) # nat rule logic
				case "$str_target" in
					DROP|REJECT)
						log -E "Do NOT drop in the nat table."
						return 1
					;;
				esac
			;;
			raw|rawpost)
				if [[ ${arg_list_state[ARG_LIST_IDX]} ]]; then
					log -E "There is no connection tracking available in $table table."
					return 1
				fi
				local str_state
				for str_state in ctstate ctproto ctorigsrc ctorigdst ctreplsrc ctrepldst ctorigsrcport \
					ctorigdstport ctreplsrcport ctrepldstport ctstatus ctexpire ctdir
				do
					if var_defined_silent "arg_list_${str_state}[${ARG_LIST_IDX}]"; then
						log -E "There is no connection tracking available in $table table."
						return 1
					fi
				done
			;;
		esac
		((++RULE_LIST_IDX))
		((++ARG_LIST_IDX))
	done
done
return 0
} # -------------------------------------------------------------------------

_template_logic_checks() { # check for configuration errors in the template
if ((table_in_template == 0 && table_in_rule == 0)); then
	log -w "No iptables table specified. Setting it to default: filter."
	table='filter'
fi
if ((target_in_template == 0 && target_in_rule == 0)); then
	log -E "No target specified. Target must be configured in either the template, or the rule."
	return 1
elif ((chain_in_template == 0 && chain_in_rule == 0)); then
	log -E "No chain specified. Chain must be configured in either the template, or the rule."
	return 1
elif ((state_in_template == 1 && state_in_rule == 1)); then
	log -E "State match may be configured in either the template, or the rule, not in both."
	return 1
fi
} # -------------------------------------------------------------------------

_post_multiply_checks() {
case "$table" in
#	filter) : ;;
	mangle)
		case "$str_target" in
			TPROXY)
				if [[ $(string_tolower "${arg_list_proto[ARG_LIST_IDX]:-0}") != @(tcp|udp|6|17) ]]; then
					log -E "The $str_target is only valid with tcp or udp."
					return 1
				fi
			;;
		esac
	;;
	nat)
		case "$str_target" in
			MASQUERADE|REDIRECT)
				if [[ ${arg_list_nat_port[ARG_LIST_IDX]} ]]; then # if a nat port is defined
					if [[ $(string_tolower "${arg_list_proto[ARG_LIST_IDX]:-0}") != @(tcp|udp|6|17) ]]; then
						log -E "Port specifications with $str_target are only valid with tcp or udp."
						return 1
					fi
				fi	
			;;
		esac
	;;
#	raw) : ;;
#	rawpost) : ;;
esac
if [[ ${arg_list_sport[ARG_LIST_IDX]} || ${arg_list_dport[ARG_LIST_IDX]} ]]; then
	string_negated "${arg_list_proto[ARG_LIST_IDX]}" && { # checking if proto is defined is done earlier in _pre_process_checks
		log -E "Port specifications with protocol negation are not valid."
		return 1
	}
	[[ $(string_tolower ${arg_list_proto[ARG_LIST_IDX]}) = !(tcp|udp|sctp|6|17|132) ]] && {
		log -E "Port specifications are only valid with the tcp, udp or sctp protocol."
		return 1
	}
fi
if [[ ${arg_list_reject_type[ARG_LIST_IDX]} ]]; then # validation of reject type is done here, as proto could be multiply value
	val_rej_type "${arg_list_reject_type[ARG_LIST_IDX]}" "${arg_list_proto[ARG_LIST_IDX]:-none}" || return 1
fi
if [[ ${arg_list_m_tcpmss[ARG_LIST_IDX]} ]]; then # validate that proto is tcp if tcpmss match is used
	if [[ $(string_tolower ${arg_list_proto[ARG_LIST_IDX]}) = !(tcp|6) ]]; then # TODO: add checks for syn|syn/ack
		log -E "The tcpmss match is only valid with the tcp protocol."
		return 1
	fi
fi

} # -------------------------------------------------------------------------

_pre_multiply_rules() {
# compute multiple rules, if a multiple option type was provided
# as comma separated input in the rule.
[[ $2 ]] || { reqparm $FUNCNAME 2; return 1; }
local rule_array tmp_str_rulelist_array
local -a tmp_multi_type_array
local -i rule_idx rule_count_after new_rule_count range_idx multi_type_idx rev_idx

local str_multi_types="$1"		# the multi option type string
local str_rulelist_array="$2"		# the according rulelist array name(s)

# load the multi types into an array
#read -a tmp_multi_type_array < <(printf "%s " $(IFS=, split_val ${str_multi_types}))
read -a tmp_multi_type_array < <(printf "%s " ${str_multi_types//,/ })
local -i multi_count=${#tmp_multi_type_array[@]}

# initialize rule count on first call
((RULE_COUNT == 0)) && RULE_COUNT=$(arr_members_sum arg_list_chain)

# if the rule multiplicator is greater zero (raised from a previous call)
# multiply it with the new multiplicator for the current call
# otherwise set it to the multiplicator value of the current call
RULE_MULTIPLICATOR=$((RULE_MULTIPLICATOR > 0 ? RULE_MULTIPLICATOR * multi_count : multi_count))

# the amount of rules before multiplication
local -i rule_count_before=${RULE_COUNT}

# the amount of rules after multiplication
local -i rule_count_after=$((rule_count_before * multi_count))
RULE_COUNT=${rule_count_after}

[[ $DEBUG_INFO ]] && {
	pr_str "Multiplying: ${str_rulelist_array} Global factor: ${RULE_MULTIPLICATOR} Rule Count before: ${rule_count_before} Current factor: ${multi_count} Rule sum: ${rule_count_after}"
}
# for every arg_list array, check if it contains data. if yes, duplicate the entries
for rule_array in ${ARG_LIST_ARRAYS_MULTIPLY}; do
	if arr_populated "${rule_array}"; then
		new_rule_count=${rule_count_before}
		for ((multi_type_idx=rule_count_before; multi_type_idx<=rule_count_after-1; multi_type_idx=multi_type_idx+rule_count_before)); do
			for ((rule_idx=0; rule_idx<=rule_count_before-1; ++rule_idx)); do
				[[ $DEBUG_INFO ]] && pr_str "new_rule_count: $new_rule_count multi_type_idx: $multi_type_idx rule_idx: $rule_idx"
				[[ $DEBUG_INFO ]] && pr_str "${rule_array}[$new_rule_count]=${rule_array}[$rule_idx]"
				eval ${rule_array}'[new_rule_count++]="${'${rule_array}'[rule_idx]}"'
			done
		done
	fi
done

# now place the multi types into the according arg_list array
for ((rule_idx=0,multi_type_idx=0; rule_idx<=rule_count_after-1; rule_idx=rule_idx+rule_count_before,++multi_type_idx)); do
	for ((rev_idx=0,range_idx=rule_idx; range_idx < rule_idx + rule_count_before; ++range_idx)); do
		tmp_str_rulelist_array="${str_rulelist_array%,*}" # name of the arg_list array
		if ((reverse_rule == 1)); then # this is a rule to reverse
			if ((rev_idx == 0)); then # first pass
				rev_idx=1
			else # second pass - reverse option data
				tmp_str_rulelist_array="${str_rulelist_array#*,}" # name of the reverse arg_list_array
				rev_idx=0
			fi
		fi
		[[ $DEBUG_INFO ]] && pr_str "multi_type_idx: $multi_type_idx rule_idx: $rule_idx range_idx: $range_idx"
		[[ $DEBUG_INFO ]] && eval 'printf "%s\n" "'${tmp_str_rulelist_array}'['${range_idx}']: ${'${tmp_str_rulelist_array}'[range_idx]}"'
		eval ${tmp_str_rulelist_array}'[range_idx]="'"${tmp_multi_type_array[multi_type_idx]}"'"'
	done
done
} # -------------------------------------------------------------------------

_multiply_rules() {
# if there are multiple input or output interfaces defined by the user,
# the rules need to be duplicated for each interface.
if ((multi_input_devices == 1)); then
	_pre_multiply_rules "${str_multi_input_devices}" "arg_list_idev,arg_list_odev" || return 1
fi
if ((multi_output_devices == 1)); then
	_pre_multiply_rules "${str_multi_output_devices}" "arg_list_odev,arg_list_idev" || return 1
fi
# if there are multiple protocols defined by the user,
# the rules need to be duplicated for each protocol.
if ((multi_protocols == 1)); then
	_pre_multiply_rules "${str_multi_protocols}" "arg_list_proto" || return 1
fi
# if there are multiple icmp types defined by the user,
# the rules need to be duplicated for each icmp type.
if ((multi_icmp_types == 1)); then
	_pre_multiply_rules "${str_icmp_types}" "arg_list_icmp_type" || return 1
fi
# if there are multiple source or destination ports defined by the user,
# the rules need to be duplicated for each port.
if ((multi_source_ports == 1)); then
	_pre_multiply_rules "${str_source_ports}" "arg_list_sport,arg_list_dport" || return 1
fi
if ((multi_destination_ports == 1)); then
	_pre_multiply_rules "${str_destination_ports}" "arg_list_dport,arg_list_sport" || return 1
fi
} # -------------------------------------------------------------------------

addr_in_network() {
local -i tmp_mask
case "$1" in
	""|0/0|0.0.0.0/0) : ;;
	# IP string is single IP
	(+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]]))
		in_network "$1" "${str_netaddr}/${str_net_mask}" && return 0
	;;
	# IP string is IP/Mask
	(+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]])/+([[:digit:]]))
		if [[ $1 = ${str_netip}/${str_net_mask} ]]; then
			return 0
		else
			in_network "$(demask $1)" "${str_netaddr}/${str_net_mask}" && return 0
		fi
	;;
	(+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]])/+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]]))
		tmp_mask=$(ip_vlsm ${1#*/}) || {
			return $ER_CONF
		}
		if [[ ${1%/*}/${tmp_mask} = ${str_netip}/${str_net_mask} ]]; then
			return 0
		else
			in_network "$(demask $1)" "${str_netaddr}/${str_net_mask}" && return 0
		fi
	;;
	# IP string is IP-range
	(+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]])-+([[:digit:]]).+([[:digit:]]).+([[:digit:]]).+([[:digit:]]))
		if in_network "${1%-*}" "${str_netaddr}/${str_net_mask}" && in_network "${1#*-}" "${str_netaddr}/${str_net_mask}"; then
			return 0
		fi
	;;
	*) log -U $FUNCNAME
		raise_gen_err_count
esac
return 1
} # -------------------------------------------------------------------------

get_netname_by_iface() {
local str_iface="$1" str_net
for str_net in $NET_NAME_LIST; do
	if [[ $(get_net_iface $str_net) = $str_iface ]]; then
		pr_str "$str_net"
		break
	fi
done
} # -------------------------------------------------------------------------

_set_chain_by_netname() { # set the target chain classified by netname
#[[ ${str_target_chain} = @(INPUT|OUTPUT|FORWARD|PREROUTING|POSTROUTING) ]] || {
[[ ${str_target_chain} = @(@(IN|OUT)PUT|FORWARD|@(PRE||POST)ROUTING) ]] || {
	[[ $DEBUG_INFO ]] && pr_str "${FUNCNAME}(): chain is not a builtin quitting."
	return 0
}
local str_src="${arg_list_src[ARG_LIST_IDX]}" str_dst="${arg_list_dst[ARG_LIST_IDX]}"
local str_idev="${arg_list_idev[ARG_LIST_IDX]}" str_odev="${arg_list_odev[ARG_LIST_IDX]}"
local str_netip str_net_mask str_netaddr str_net_iface src_net_dev dst_net_dev
local new_target_chain="" str_src_netname="" str_dst_netname="" str_in_dev="" str_out_dev=""
local -i idev_members=odev_members=src_net_negated=dst_net_negated=src_net_external=dst_net_external=idev_external=odev_external=0

[[ -z ${str_src} && -z ${str_dst} && -z ${str_idev} && -z ${str_odev} ]] && {
	[[ $DEBUG_INFO ]] && pr_str "${FUNCNAME}(): src, dst, idev and odev are empty - nothing to match"
	return 0
}
if [[ ${str_idev} ]]; then
	if string_negated "${str_idev}"; then str_idev=""
	elif is_ifname_wcard "${str_idev}"; then str_idev=""
	fi
fi
if [[ ${str_odev} ]]; then
	if string_negated "${str_odev}"; then str_odev=""
	elif is_ifname_wcard "${str_odev}"; then str_odev=""
	fi
fi
for str_netname in ${NET_NAME_LIST}; do
	set -- $(get_net_data "${str_netname}")
	str_net_iface="$1" str_netip="$3" str_net_mask="$4" str_netaddr="$5"
	[[ ${str_netip} ]] || continue
	if [[ ${str_src} && -z ${str_src_netname} ]]; then
		string_negated "${str_src}" && src_net_negated=1
		if addr_in_network "$(remove_negation "${str_src}")"; then
			str_src_netname="${str_netname}" src_net_dev="${str_net_iface}"
			if ((src_net_negated == 0)); then
				case "${str_target_chain}" in
#					INPUT|PREROUTING)
					INPUT)
						if [[ ${str_idev} && ${str_net_iface} != ${str_idev} ]]; then
							log -E "Device missmatch - input device in rule does not match the device configured for the network."
							return 1
						fi
					;;
#					OUTPUT|POSTROUTING)
					OUTPUT)
						if [[ ${str_odev} && ${str_net_iface} != ${str_odev} ]]; then
							log -E "Device missmatch - output device in rule does not match the device configured for the network."
							return 1
						fi
					;;
					FORWARD)
						if [[ ${str_idev} && ${str_net_iface} != ${str_idev} ]]; then
							log -E "Device missmatch - input device in rule does not match the device configured for the network."
							return 1
						fi
					;;
				esac
				if lsearch "${str_src_netname}" ${EXT_NETNAME_LIST}; then # source network is external
					src_net_external=1
				fi
			fi
		else
			((${?} != 1)) && return 1
		fi
	fi
	if [[ ${str_dst} && -z ${str_dst_netname} ]]; then
		string_negated "${str_dst}" && dst_net_negated=1
		if addr_in_network "$(remove_negation "${str_dst}")"; then
			str_dst_netname="${str_netname}" dst_net_dev="${str_net_iface}"
			if ((dst_net_negated == 0)); then
				case "${str_target_chain}" in
#					INPUT|PREROUTING)
					INPUT)
						if [[ ${str_idev} && ${str_net_iface} != ${str_idev} ]]; then
							log -E "Device missmatch - input device in rule does not match the device configured for the network."
							return 1
						fi
					;;
#					OUTPUT|POSTROUTING)
					OUTPUT)
						if [[ ${str_odev} && ${str_net_iface} != ${str_odev} ]]; then
							log -E "Device missmatch - output device in rule does not match the device configured for the network."
							return 1
						fi
					;;
					FORWARD)
						if [[ ${str_odev} && ${str_net_iface} != ${str_odev} ]]; then
							log -E "Device missmatch - output device in rule does not match the device configured for the network."
							return 1
						fi
					;;
				esac
				if lsearch "${str_dst_netname}" ${EXT_NETNAME_LIST}; then # destination network is external
					dst_net_external=1
				fi
			fi
		else
			((${?} != 1)) && return 1
		fi
	fi
	[[ ${str_idev} && -z ${str_in_dev} && ${str_idev} = ${str_net_iface} ]] && str_in_dev="${str_idev}"
	[[ ${str_odev} && -z ${str_out_dev} && ${str_odev} = ${str_net_iface} ]] && str_out_dev="${str_odev}"
	if [[ ${str_src_netname} && ${str_dst_netname} ]]; then break; fi
done
#case "${str_target_chain}" in
##	PREROUTING)
##		if [[ ${str_in_dev} ]] && ((dst_net_negated == 1)); then
##			log -W "Destination network is negated but input device is specified, cannot set chain for \`${str_target_chain}'."
##			return 0
##		fi
##	;;
##	POSTROUTING)
##		if [[ ${str_out_dev} ]] && ((src_net_negated == 1)); then
##			log -W "Source network is negated but output device is specified, cannot set chain for \`${str_target_chain}'."
##			return 0
##		fi
##	;;
#	INPUT)
#		if ((dst_net_negated == 1)); then
#			log -W "Destiantion network is negated, cannot set chain for \`${str_target_chain}'."
#			return 0
#		fi
#	;;
#	OUTPUT)
#		if ((src_net_negated == 1)); then
#			log -W "Source network is negated, cannot set chain for \`${str_target_chain}'."
#			return 0
#		fi
#	;;
#esac
((src_net_negated == 1)) && { str_src_netname=""; src_net_dev=""; src_net_external=0 ; }
((dst_net_negated == 1)) && { str_dst_netname=""; dst_net_dev=""; dst_net_external=0 ; }
[[ $DEBUG_INFO ]] && pr_str "${FUNCNAME}(): source network: '${str_src_netname}' destination network: '${str_dst_netname}'"

[[ ${str_in_dev:-0} = ${str_out_dev:-1} ]] && {
	log -W "Input and output device are equal, cannot set chain for \`${str_target_chain}'."
	return 0
}
if [[ ${str_in_dev} ]]; then
	lsearch "${str_in_dev}" ${EXT_IFLIST} && idev_external=1 # input device is external
	idev_members=$(arr_members_sum "IFDATA_ARRAY_${str_in_dev}")
fi
if [[ ${str_out_dev} ]]; then
	lsearch "${str_out_dev}" ${EXT_IFLIST} && odev_external=1 # output device is internal
	odev_members=$(arr_members_sum "IFDATA_ARRAY_${str_out_dev}")
fi

if [[ ${str_src_netname} && ${str_dst_netname} ]]; then # source and destination networks are known
	case "${str_target_chain}" in
		PREROUTING)
			if [[ ${str_src_netname} = ${str_dst_netname} ]]; then
				new_target_chain="${str_dst_netname}_PRE"
			elif ((src_net_external == 1 && dst_net_external == 1)); then # source and destination network are external
				log -W "Source and destination network are known, but external, cannot set chain for \`${str_target_chain}'."
				return 0
			elif ((src_net_external == 1)); then # source network is external
				new_target_chain="${str_dst_netname}_PRE"
			elif ((dst_net_external == 1)); then # destination network is external
				new_target_chain="${str_src_netname}_PRE"
			else # both networks are internal
				new_target_chain="${str_src_netname}_${str_dst_netname}_PRE"
			fi
		;;
		INPUT) new_target_chain="${str_dst_netname}_INPUT" ;;
		OUTPUT) new_target_chain="${str_src_netname}_OUTPUT" ;;
		FORWARD)
			[[ ${str_src_netname} = ${str_dst_netname} ]] && {
				log -W "Source network \`${str_src_netname}' is equal to destination network \`${str_dst_netname}', \
					cannot set chain for \`${str_target_chain}'."
				return 0
			}
			if [[ ${src_net_dev} = ${dst_net_dev} ]]; then
				log -W "Source network interface \`${src_net_dev}' is equal to destination network interface \`${dst_net_dev}', \
					cannot set chain for \`${str_target_chain}'."
				return 0
			fi
			if ((src_net_external == 1 && dst_net_external == 1)); then # source and destination network are external
				log -W "Source and destination network are known, but external, cannot set chain for \`${str_target_chain}'."
				return 0
			elif ((src_net_external == 1)); then # source network is external
				new_target_chain="${str_dst_netname}_FWD_IN"
			elif ((dst_net_external == 1)); then # destination network is external
				new_target_chain="${str_src_netname}_FWD_OUT"
			else # both networks are internal
				new_target_chain="${str_src_netname}_${str_dst_netname}"
			fi
		;;
		POSTROUTING)
			if [[ ${str_src_netname} = ${str_dst_netname} ]]; then
				new_target_chain="${str_dst_netname}_POST"
			elif ((src_net_external == 1 && dst_net_external == 1)); then # source and destination network are external
				log -W "Source and destination network are known, but external, cannot set chain for \`${str_target_chain}'."
				return 0
			elif ((src_net_external == 1)); then # source network is external
				new_target_chain="${str_dst_netname}_POST"
			elif ((dst_net_external == 1)); then # destination network is external
				new_target_chain="${str_src_netname}_POST"
			else
				new_target_chain="${str_src_netname}_${str_dst_netname}_POST"
			fi
		;;
	esac
elif [[ ${str_src_netname} ]]; then # only source network is known
	case "${str_target_chain}" in
		INPUT) new_target_chain="${str_src_netname}_INPUT" ;;
		OUTPUT) new_target_chain="${str_src_netname}_OUTPUT" ;;
		FORWARD)
			if ((src_net_external == 1)); then # source network is external
				if [[ ${str_in_dev} || ${str_out_dev} ]]; then # there are interfaces defined
					if [[ ${str_in_dev} && ${str_in_dev} = ${src_net_dev} ]]; then
						new_target_chain="${str_src_netname}_FWD_IN"
					elif [[ ${str_out_dev} && ${str_out_dev} = ${src_net_dev} ]]; then
						new_target_chain="${str_src_netname}_FWD_OUT"
					else
						if [[ ${str_in_dev} ]]; then
							new_target_chain="${str_src_netname}_FWD_OUT"
						elif [[ ${str_out_dev} ]]; then
							new_target_chain="${str_src_netname}_FWD_IN"
						fi
					fi
				else
					new_target_chain="${str_src_netname}_FWD_IN"
				fi
			else # source network is internal
				new_target_chain="${str_src_netname}_FWD_OUT"
			fi
		;;
		PREROUTING) new_target_chain="${str_src_netname}_PRE" ;;
		POSTROUTING) new_target_chain="${str_src_netname}_POST" ;;
	esac
elif [[ ${str_dst_netname} ]]; then # only destination network is known
	case "${str_target_chain}" in
		INPUT) new_target_chain="${str_dst_netname}_INPUT" ;;
		OUTPUT) new_target_chain="${str_dst_netname}_OUTPUT" ;;
		FORWARD)
			if ((dst_net_external == 1)); then # destination network is external
				if [[ ${str_in_dev} || ${str_out_dev} ]]; then # there are interfaces defined
					if [[ ${str_in_dev} && ${str_in_dev} = ${dst_net_dev} ]]; then
						new_target_chain="${str_dst_netname}_FWD_IN"
					elif [[ ${str_out_dev} && ${str_out_dev} = ${dst_net_dev} ]]; then
						new_target_chain="${str_dst_netname}_FWD_OUT"
					else
						if [[ ${str_in_dev} ]]; then
							new_target_chain="${str_dst_netname}_FWD_OUT"
						elif [[ ${str_out_dev} ]]; then
							new_target_chain="${str_dst_netname}_FWD_IN"
						fi
					fi
				else
					new_target_chain="${str_dst_netname}_FWD_OUT"
				fi
			else # destination network is internal
				new_target_chain="${str_dst_netname}_FWD_IN"
			fi
		;;
		PREROUTING) new_target_chain="${str_dst_netname}_PRE" ;;
		POSTROUTING) new_target_chain="${str_dst_netname}_POST" ;;
	esac
else  # no matching network, looking for matching interfaces
	[[ $DEBUG_INFO ]] && pr_str "${FUNCNAME}(): input interface: '${str_in_dev}' output interface: '${str_out_dev}'"
	[[ ${str_in_dev} || ${str_out_dev} ]] || {
		log -W "No matching network or interface found, cannot set chain for \`${str_target_chain}'."
		return 0
	}
	[[ ${str_in_dev} = ${str_out_dev} ]] && {
		log -W "Input interface \`${str_in_dev}' is equal to output interface \`${str_out_dev}', cannot set chain."
		return 0
	}
	for str_netname in ${NET_NAME_LIST}; do
		str_net_iface=$(get_net_iface ${str_netname})
		[[ ${str_net_iface} = ${str_in_dev} ]] && str_src_netname="${str_netname}"
		[[ ${str_net_iface} = ${str_out_dev} ]] && str_dst_netname="${str_netname}"
		if [[ ${str_src_netname} && ${str_dst_netname} ]]; then # both interfaces are known networks
			break
		fi
	done
	if [[ ${str_in_dev} && ${str_out_dev} ]]; then # idev & odev are defined - only FORWARD chain is valid
		case "${str_target_chain}" in
			FORWARD)
				if ((idev_external == 1 && odev_external == 1)); then # input and output device are external
					log -W "Input and output interface are external, cannot set chain for \`${str_target_chain}'."
					return 0
				fi
				if ((idev_members == 1 && odev_members == 1)); then # no alias interfaces present
					if ((odev_external == 1)); then # output device is external
						new_target_chain="${str_dst_netname}_FWD_OUT"
					elif ((idev_external == 1)); then # input device is external
						new_target_chain="${str_src_netname}_FWD_IN"
					else # both are internal
						if ((JUMP_TREE[3] == 0)); then # use interface+netname
							new_target_chain="${str_in_dev}${IF_CON}${str_out_dev}" # as alias are present, if_to_if chain matches
						else
							log -W "Input device \`${str_in_dev}' and output device \`${str_out_dev}' are known, 
								but no address is not matching a known network, cannot set chain for \`${str_target_chain}'."
							return 0
						fi
					fi
				elif ((idev_members > 1)); then # input device has alias interfaces
					if ((odev_external == 1)); then # output device is external
						if ((JUMP_TREE[3] == 0)); then # use interface+netname
							new_target_chain="${str_in_dev}${IF_CON}${str_out_dev}" # if_to_if chain matches
						else
							new_target_chain="${str_dst_netname}_FWD_OUT"
						fi
					elif ((idev_external == 1)); then # input device is external must not be if aliases present
						log -W "Both interfaces are known, but external input interface has aliases defined, cannot set chain for \`${str_target_chain}'."
						return 0
					else # both are internal
						if ((JUMP_TREE[3] == 0)); then # use interface+netname
							new_target_chain="${str_in_dev}${IF_CON}${str_out_dev}" # if_to_if chain matches
						else
							log -W "Both interfaces are internal, but input interface has aliases defined, cannot set chain for \`${str_target_chain}'."
							return 0
						fi
					fi
				elif ((odev_members > 1)); then # output device has alias interfaces
					if ((idev_external == 1)); then # input device is external
						if ((JUMP_TREE[3] == 0)); then # use interface+netname
							new_target_chain="FWD_OUT_${str_out_dev}" # as alias are present, FWD_OUT_odev chain matches
						else
							new_target_chain="${str_src_netname}_FWD_IN"
						fi
					elif ((odev_external == 1)); then # output device is external must not be if aliases present
						log -W "Both interfaces are known, but external output interface has aliases defined, cannot set chain for \`${str_target_chain}'."
						return 0
					else # both are internal
						if ((JUMP_TREE[3] == 0)); then # use interface+netname
							new_target_chain="${str_in_dev}${IF_CON}${str_out_dev}" # if_to_if chain matches
						else
							log -W "Both interfaces are internal, but input interface has aliases defined, cannot set chain for \`${str_target_chain}'."
							return 0
						fi
					fi
				else
					log -W "Unable to find a match to set chain for \`${str_target_chain}'."
				fi
			;;
		esac
	elif [[ ${str_in_dev} ]]; then # only input device is known, scr and dst are not part of known networks
		case "${str_target_chain}" in
			PREROUTING)
				log -W "Input device \`${str_in_dev}' is known, but no address \
					is matching a known network, cannot set chain for \`${str_target_chain}'."
				return 0
			;;
			INPUT)
				if ((idev_external == 1)); then # input device is external
					log -W "Input device \`${str_in_dev}' is known, but destination address \
						is not matching a known network, cannot set chain for \`${str_target_chain}'."
					return 0
				else
					if ((JUMP_TREE[3] == 1)); then
						log -W "Input device \`${str_in_dev}' is known, but no address \
							is matching a known network, cannot set chain for \`${str_target_chain}'."
						return 0
					else
						if ((idev_members > 1)); then
							new_target_chain="INPUT_${str_in_dev}"
						else
							log -W "Input device \`${str_in_dev}' is known, but no address \
								is matching a known network, cannot set chain for \`${str_target_chain}'."
							return 0
						fi
					fi
				fi
			;;
			FORWARD)
				if ((idev_external == 1)); then # input device is external
					new_target_chain="${str_src_netname}_FWD_IN"
				else
					if ((JUMP_TREE[3] == 1)); then
						log -W "Input device \`${str_in_dev}' is known, but no address \
							is matching a known network, cannot set chain for \`${str_target_chain}'."
						return 0
					else
						if ((idev_members > 1)); then
							new_target_chain="FWD_IN_${str_in_dev}"
						else
							log -W "Input device \`${str_in_dev}' is known, but no address \
								is matching a known network, cannot set chain for \`${str_target_chain}'."
							return 0
						fi
					fi
				fi
			;;
		esac
	elif [[ ${str_out_dev} ]]; then # only output device is known, scr and dst are not part of known networks
		case "${str_target_chain}" in
			POSTROUTING)
				log -W "Output device \`${str_out_dev}' is known, but no address \
					is matching a known network, cannot set chain for \`${str_target_chain}'."
				return 0
			;;
			OUTPUT)
				if ((odev_external == 1)); then # output device is external
					log -W "Output device \`${str_out_dev}' is known, but source address \
						is not matching a known network, cannot set chain for \`${str_target_chain}'."
					return 0
				else
					if ((JUMP_TREE[3] == 1)); then
						log -W "Output device \`${str_out_dev}' is known, but no address \
							is matching a known network, cannot set chain for \`${str_target_chain}'."
						return 0
					else
						if ((odev_members > 1)); then
							new_target_chain="OUTPUT_${str_out_dev}"
						else
							log -W "Output device \`${str_out_dev}' is known, but source address \
								is not matching a known network, cannot set chain for \`${str_target_chain}'."
							return 0
						fi
					fi
				fi
			;;
			FORWARD)
				if ((odev_external == 1)); then # output device is external
					new_target_chain="${str_dst_netname}_FWD_OUT"
				else
					if ((JUMP_TREE[3] == 1)); then
						log -W "Output device \`${str_out_dev}' is known, but source address \
							is not matching a known network, cannot set chain for \`${str_target_chain}'."
						return 0
					else
						if ((odev_members > 1)); then
							new_target_chain="FWD_OUT_${str_out_dev}"
						else
							log -W "Output device \`${str_out_dev}' is known, but source address \
								is not matching a known network, cannot set chain for \`${str_target_chain}'."
							return 0
						fi
					fi
				fi
			;;
		esac
	fi
fi

if [[ ${new_target_chain} ]]; then
	[[ $DEBUG_INFO ]] && pr_str "${FUNCNAME}(): new chain: '${new_target_chain}'"
	if ((JUMP_TREE_CHAINS_CREATE_ALL == 0)); then
		create_chain "$table" "${new_target_chain}" --silent
	fi
	RULELIST_CHAIN[RULE_LIST_IDX]="${new_target_chain}"
	MSG_LIST_CHAIN[RULE_LIST_IDX]="chain=${new_target_chain} "
else
	if [[ $DEBUG_INFO ]]; then pr_str "${FUNCNAME}(): Chain was not modified"; fi
fi
} # -------------------------------------------------------------------------

_set_chain_by_interface() { # set the target chain classified by interfaces
[[ ${str_target_chain} = @(INPUT|OUTPUT|FORWARD|PREROUTING|POSTROUTING) ]] || {
	[[ $DEBUG_INFO ]] && pr_str "${FUNCNAME}(): chain is not a builtin quitting."
	return 0
}
local str_idev="${arg_list_idev[ARG_LIST_IDX]}" str_odev="${arg_list_odev[ARG_LIST_IDX]}"
[[ ${str_idev} || ${str_odev} ]] || {
	log -W "No interface specified, cannot set chain for \`${str_target_chain}'."
	return 0
}
local new_target_chain=""
local -i iface_count=iface_neg_count=iface_wildcard_count=0
if [[ ${str_idev} ]]; then
	let iface_count+=1
	if string_negated "${str_idev}"; then
		let iface_neg_count+=1
	elif is_ifname_wcard "${str_idev}"; then
		let iface_wildcard_count+=1
	fi
fi
if [[ ${str_odev} ]]; then
	let iface_count+=1
	if string_negated "${str_odev}"; then
		let iface_neg_count+=1
	elif is_ifname_wcard "${str_odev}"; then
		let iface_wildcard_count+=1
	fi
fi
if ((iface_count == 1)); then # one interface in rule
	if ((iface_neg_count > 0 || iface_wildcard_count > 0)); then # if interface string is negated or a wildcard
		# if target chain is matching an IP-Array built chain, set target chain to INPUT / OUTPUT
		case "${str_target_chain}" in
			(INPUT_@(${NET_IFLIST_CHECK_STRING}))
				log -W "Cannot place a rule for multiple interfaces into a \
					single interface chain, setting chain to: INPUT"
				new_target_chain="INPUT"
			;;
			(OUTPUT_@(${NET_IFLIST_CHECK_STRING}))
				log -W "Cannot place a rule for multiple interfaces into a \
					single interface chain, setting chain to: OUTPUT"
				new_target_chain="OUTPUT"
			;;
			INPUT|OUTPUT|FORWARD|PREROUTING|POSTROUTING)
				log -W "Cannot set chain for negated or wildcard interface descriptors"
				return 0
		esac
	else
		# if target chain is matching an iptables builtin chain,
		# set target chain to $target_chain_$idev / OUTPUT_$odev
		case "${str_target_chain}" in
			(INPUT|PREROUTING)
				if [[ ${str_idev} ]]; then
					new_target_chain="${str_target_chain}_${str_idev}"
					unset RULELIST_IDEV[RULE_LIST_IDX] MSG_LIST_IDEV[RULE_LIST_IDX]
				else
					log -E "Configuration caused an empty idev string."
					return 1
				fi
			;;
			(OUTPUT|POSTROUTING)
				if [[ ${str_odev} ]]; then
					new_target_chain="${str_target_chain}_${str_odev}"
					unset RULELIST_ODEV[RULE_LIST_IDX] MSG_LIST_ODEV[RULE_LIST_IDX]
				else
					log -E "Configuration caused an empty odev string."
					return 1
				fi
			;;
			(FORWARD)
				if [[ ${str_idev} ]]; then
					new_target_chain="FWD_IN_${str_idev}"
				elif [[ ${str_odev} ]]; then
					new_target_chain="FWD_OUT_${str_odev}"
				fi
			;;
		esac
	fi
elif ((iface_count == 2)); then # two interfaces in rule
	case "${str_target_chain}" in
		# if target chain is matching an IP-Array built chain
		(@(${NET_IFLIST_CHECK_STRING})${IF_CON}@(${NET_IFLIST_CHECK_STRING}))
			# Check if any interface in the rule is an iptables wildcard,
			# or negated and, if we use two interfaces, set target chain to FORWARD
			if ((iface_wildcard_count > 0 || iface_neg_count > 0)); then
				log -W "Cannot place a rule for multiple interfaces into a \
					two interface chain, setting chain to: FORWARD"
				new_target_chain="FORWARD"
			fi
			# Check if we try to forward between two equal interfaces
			if [[ ${str_idev} = ${str_odev} ]]; then
				log -W "Forwarding between two equal interfaces. Setting chain to: FORWARD."
				new_target_chain="FORWARD"
			fi
		;;
		FORWARD) # target chain is matching iptables builtin FORWARD chain
			# none of the interfaces is negated or an iptables wildcard
			if ((iface_wildcard_count == 0 && iface_neg_count == 0)); then
				if [[ ${str_idev} != ${str_odev} ]]; then
					# set it to ${idev}${IF_CON}${odev}
					new_target_chain="${str_idev}${IF_CON}${str_odev}"
					unset RULELIST_IDEV[RULE_LIST_IDX] MSG_LIST_IDEV[RULE_LIST_IDX]
					unset RULELIST_ODEV[RULE_LIST_IDX] MSG_LIST_ODEV[RULE_LIST_IDX]
				else
					log -W "Forwarding between two equal interfaces - keeping FORWARD chain."
					return 0
				fi
			else
				log -W "Cannot set chain for negated or wildcard interface descriptors"
				return 0
			fi
		;;
	esac
fi
if [[ ${new_target_chain} ]]; then
	[[ $DEBUG_INFO ]] && pr_str "${FUNCNAME}(): new chain: '${new_target_chain}'"
	if ((JUMP_TREE_CHAINS_CREATE_ALL == 0)); then
		create_chain "$table" "${new_target_chain}" --silent
	fi
	RULELIST_CHAIN[RULE_LIST_IDX]="${new_target_chain}"
	MSG_LIST_CHAIN[RULE_LIST_IDX]="chain=${new_target_chain} "
else
	if [[ $DEBUG_INFO ]]; then pr_str "${FUNCNAME}(): Chain was not modified"; fi
fi
} # -------------------------------------------------------------------------

_fill_rule_lists() {
# fill the rulelist and msg_list arrays according to the given
# template and rule parameters.
local str_target str_target_chain
local -i target_idx chain_idx opt_idx tmp_opt_idx multi_idx ARG_LIST_IDX
local -i RULE_LIST_IDX=0
local -a tmp_opt_array

# if rule multiplicator is greater 0, decrease it by one, otherwise keep its value
RULE_MULTIPLICATOR=$((RULE_MULTIPLICATOR > 0 ? RULE_MULTIPLICATOR - 1 : RULE_MULTIPLICATOR))

# for every target in the list, do...
# there always must be a target definition, otherwise the whole thing will fail
# if no target is what we want, the user has to specify it as 'empty'
for target_idx in ${!arg_list_target[@]}; do
	ARG_LIST_IDX=0 # reset arg_list_$option counter on each loop
	str_target="${arg_list_target[target_idx]}"
	# if rules were multiplied, there's more than one rule...
	for ((multi_idx=0; multi_idx<=RULE_MULTIPLICATOR; ++multi_idx)); do
		opt_idx=0
		# for every chain in the list, do...
		for ((chain_idx=0; chain_idx<${#arg_list_chain[@]} && chain_idx<=chain_max; chain_idx++)); do
			ARG_LIST_IDX=$((ARG_LIST_IDX < $(($((second_optionlist + 1)) * $((multi_idx + 1)))) ? ARG_LIST_IDX : 0))
			str_target_chain="${arg_list_chain[chain_idx]}"

			# post rule multiplication checks
			_post_multiply_checks || return $ER_CONF

			# set message string for iptables table
			_process_table
			# if target or chain is defined in the template, their values are not in the tmp_opt_array.
			_process_target
			_process_chain

			if [[ $str_target = goto:* ]]; then # remove goto: prefix for the _process_$option functions 
				str_target="${str_target#goto:}"
			fi
			# copy the option list array to a temp array, so 'eval' is not needed
			$($copy_array arr_tmp_rule_opt_${opt_idx} tmp_opt_array) || return 1

			# fill RULELIST and MSG_LIST arrays
			for tmp_opt_idx in ${!tmp_opt_array[@]}; do
				# processing is name based: _process_${option_name}
				[[ ${tmp_opt_array[tmp_opt_idx]} = @(target|chain) ]] && continue
				if var_defined_silent "arg_list_${tmp_opt_array[tmp_opt_idx]}[${ARG_LIST_IDX}]"; then
					_process_"${tmp_opt_array[tmp_opt_idx]}" || return $ER_FAIL
				fi
			done

			# evaluate the chain to place the rule into
			if ((JUMP_TREE[0] == 1)); then
				if [[ ${JUMP_TREE[2]} ]] && lsearch "$table" ${JUMP_TREE[2]}; then
					case "${JUMP_TREE[1]}" in
						interface) _set_chain_by_interface || return $ER_CONF ;;
						netname|netname+interface) _set_chain_by_netname || return $ER_CONF ;;
					esac
				fi
			fi

			opt_idx=$((opt_idx == 0 && second_optionlist > 0 ? opt_idx + 1 : 0)) # calc option list counter
			let RULE_LIST_IDX+=1 ARG_LIST_IDX+=1
		done
	done
done
} # -------------------------------------------------------------------------

__compose_ipt_cmdstring() {
# construct the iptables command string, conditions are taken from various builtin arrays
# MSG_LIST_${NAME-OF-OPTION} and RULELIST_${NAME-OF-OPTION} arrays are queried for the data
# after a match is found, we exit the function
local -i xidx
local str_m str_opt str_t str_tables str_tlist
for xidx in ${!GLOBAL_MATCH_LIST[@]}; do # options/matches usable in all tables
	eval 'str_log+="${MSG_LIST_'${GLOBAL_MATCH_LIST[xidx]}'[ridx]}" str_cmd+="${RULELIST_'${GLOBAL_MATCH_LIST[xidx]}'[ridx]}"'
done
for xidx in ${!TABLE_DEPEND_MATCH_LIST[@]}; do # options/matches usable only in specific tables
	set -- ${TABLE_DEPEND_MATCH_LIST[xidx]}
	for str_t in ${1//,/ }; do
		if [[ ${str_t} = $table ]]; then
			for str_m in ${2//,/ }; do
				eval 'str_log+="${MSG_LIST_'${str_m}'[ridx]}" str_cmd+="${RULELIST_'${str_m}'[ridx]}"'
			done
		fi
	done
done
[[ $str_target ]] || return 0 # empty target -> job done
for xidx in ${!GLOBAL_TARGET_LIST[@]}; do # targets usable in all tables
	set -- ${GLOBAL_TARGET_LIST[xidx]}
	if [[ $1 = $str_target ]]; then
		shift
		str_cmd+="-j $str_target "
		for str_opt in "$@"; do
			eval 'str_log+="${MSG_LIST_'$str_opt'[ridx]}" str_cmd+="${RULELIST_'$str_opt'[ridx]}"'
		done
		return 0
	fi
done
for xidx in ${!TABLE_DEPEND_TARGET_LIST[@]}; do # targets usable only in specific tables
	set -- ${TABLE_DEPEND_TARGET_LIST[xidx]}
	str_tables="${1//,/ }"
	shift
	str_tlist="$@"
	for str_t in ${str_tables}; do
		if [[ ${str_t} = $table ]]; then
			for str_opt in ${str_tlist}; do
				if [[ ${str_opt%:*} = $str_target ]]; then
					str_cmd+="-j $str_target "
					str_opt="${str_opt#*:}"
					set -- ${str_opt//,/ }
					for str_opt in "$@"; do
						eval 'str_log+="${MSG_LIST_'$str_opt'[ridx]}" str_cmd+="${RULELIST_'$str_opt'[ridx]}"'
					done
					return 0
				fi
			done
		fi
	done
done
str_cmd+="$str_action $str_target" # no matching target found
} # -------------------------------------------------------------------------

_compute_rules() {
# read the rulelist and msg_list arrays and construct the command
# and log strings, which are then passed to the add_rule function.
local str_target str_action="-j" str_log str_cmd
local -i ridx

for ridx in ${!RULELIST_TARGET[@]}; do
	str_target="${RULELIST_TARGET[ridx]}"
	if [[ $str_target = empty ]]; then # rules with no target have it set to `empty' by the user
		str_target=""
	elif [[ $str_target = goto:* ]]; then # goto:target changes default jump behaviour
		str_target="${str_target#goto:}"
		str_action="-g"
	elif [[ $str_target = ECN ]]; then # target without an option that could be set
		local RULELIST_REM_ECN[ridx]="--ecn-tcp-remove"
	elif [[ $str_target = CHECKSUM ]]; then # target without an option that could be set
		local RULELIST_CHECKSUM[ridx]="--checksum-fill"
	fi
	str_log="${PF}${MSG_LIST_TARGET[ridx]} ${MSG_LIST_TABLE[ridx]}${MSG_LIST_CHAIN[ridx]}"
	str_cmd=""
	
	__compose_ipt_cmdstring

	# log the generated message
	log -e "${str_log}"
	# add the generated rule
	add_rule "$table" "${RULELIST_CHAIN[ridx]}" "${str_cmd}" || return
	let RULES_GENERATED_COUNT+=1
done
} # -------------------------------------------------------------------------

process_ipt_quickrule() {
local -i qidx=0
local str_rb
local -a TEMPLATE_TEMP_QUICKRULE RULEBLOCK_TEMP_QUICKRULE
Q_RULE="$@"
while (($#)); do
	[[ $1 = +([[:word:]])=* ]] || {
		log -E "\`$1' is not a valid quickrule assignment."
		raise_cfg_err_count
		return 0
	}
	TEMPLATE_TEMP_QUICKRULE[qidx]="option_list_0[${qidx}]=${1%%=*}"
	if [[ ${1#+([[:word:]])=} = *+([[:space:]])* ]]; then
		str_rb+="\"${1#+([[:word:]])=}\" "
	else
		str_rb+="${1#+([[:word:]])=} "
	fi
	let qidx+=1
	shift
done
RULEBLOCK_TEMP_QUICKRULE[0]="${str_rb%[[:blank:]]}"
let QUICK_RULES_COUNT+=1
process_ipt_ruleblock TEMPLATE_TEMP_QUICKRULE RULEBLOCK_TEMP_QUICKRULE
} # -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# MAIN IPTABLES RULE PROCESSING FUNCTION
# -------------------------------------------------------------------------
process_ipt_ruleblock() {
# read and interpret a user given iptables ruleblock according to the definitions
# provided in the referencing rule template.
# Processing of the rule is done in various sub functions, which validate the input
# and compute the iptables commands and ip-array log messages.
# $1 = name of the ipt-template
# $2 = name of the ipt-ruleblock
# rest of parameters = commands to run. If command has arguments, they must be separated by comma

# reset possibly messed up environment
set_env

[[ $2 ]] || { reqparm $FUNCNAME 2; return 1; }
local target_template="$1" target_ruleblock="$2"

# check for valid template name
[[ ${target_template} = @(@(?(B|G)T|?(BASE|GLOBAL)_TEMPLATE_)+([[:word:]])) ]] || {
	log -E "Invalid Template name \`${target_template}'. \
		Template names must contain any of the following prefixes: \`T_ | BT_ | GT_ | TEMPLATE_ | BASE_TEMPLATE_ | GLOBAL_TEMPLATE_'"
	raise_cfg_err_count
	return 0
}
# check for valid ruleblock name
[[ ${target_ruleblock} = @(@(RB|RULEBLOCK)_+([[:word:]])) ]] || {
	log -E "Invalid Ruleblock name \`${target_ruleblock}'. \
		Ruleblock names must contain any of the following prefixes: \`RB_ | RULEBLOCK_'"
	raise_cfg_err_count
	return 0
}
# check if template array contains members
arr_populated "${target_template}" || {
	log -E "Template \`${target_template}' is not defined."
	raise_cfg_err_count
	return 0
}
# quit if target ruleblock is not defined
arr_populated "${target_ruleblock}" || {
	log -N "Ruleblock \`${target_ruleblock}' is empty"
	return 0
}

# if template is in the list of blacklisted templates, quit...
if lsearch "${target_template}" "${BLACKLISTED_TEMPLATES[@]}"; then
	log -E "Template \`${target_template}' is blacklisted, as it was causing errors in a previous call."
	return 0
fi

shift 2
# the remaining parameters define commands to be executed (no spaces for parameters used - comma as separator)
local commands_to_run="$@"
local strERR rev_condition_name rev_condition_var reference_command_array cmd_to_run check_array str_multi_input_devices str_multi_output_devices \
	str_multi_protocols str_icmp_types str_source_ports str_destination_ports str_entry
local -a arr_tmp_ruleblock arr_tmp_targets arr_tmp_chains arr_tmp_rule_opt_0 arr_tmp_rule_opt_1 arr_alw_use_pos_p arr_user_pos_p
local -i multi_input_devices multi_output_devices multi_protocols multi_icmp_types multi_source_ports multi_destination_ports
local -i tmp_arr_idx opt_idx OPTION_LIST_IDX chain_max=-1
local -i reverse_rule=second_optionlist=table_in_template=target_in_template=chain_in_template=target_in_rule=chain_in_rule=state_in_template=state_in_rule=0

# variables which will be set by referencing the template
local table="" template_msg="" reverse_mode="" reverse_condition=""
local -a target=() chain=() mandatory_vars=() state_match_arg=() option_list_0=() option_list_1=() always_use_0=() always_use_1=() load_template=()

# indirect reference to the ruleblock template
log -w "Referencing template: ${target_template} using ruleblock: ${target_ruleblock}"
local reference_catalog_data="${target_template}[@]"
eval local "${!reference_catalog_data}" &>/dev/null || {
#local "${!reference_catalog_data}" &>/dev/null || {
	log -E "Failed referencing template: \`${target_template}'."
	blacklist_template "${target_template}"
	raise_gen_err_count
	return 0
}
[[ $DEBUG_INFO ]] && {
	pr_sbanner "DEBUG: TEMPLATE"
	declare -p "${target_template}"
	pr_sbanner "DEBUG: RULEBLOCK"
	declare -p "${target_ruleblock}"
	pr_sepstr
}

# display message defined in template
[[ ${template_msg} ]] && log -I "${template_msg}"

# run the commands given as parameters
for cmd_to_run in ${commands_to_run}; do
	log -w "Running template invocation command: ${cmd_to_run//,/ }"
	${cmd_to_run//,/ } || {
		log -E "Failed running template invocation command \`${cmd_to_run}'."
		cmd_err_count 'misc' "${cmd_to_run}"
		return 0
	}
done

# if template provides the reverse_mode option, see if reverse mode is 'reverse' or 'mirror'
if [[ ${reverse_mode} ]]; then
	case "$(string_tolower "${reverse_mode}")" in
		reverse) # option is reverse
			# now we know we have a second option list, and the rules have to be reversed
			second_optionlist=1
			reverse_rule=1
			chain_max=1
		;;
		mirror) # option is mirror, use values of option_list_0 for option_list_1
			$($copy_array option_list_0 option_list_1) || {
				raise_gen_err_count
				log -U $FUNCNAME
				return 0
			}
			# now we know we have a second option list, but we're not in reverse mode
			second_optionlist=1
			chain_max=1
		;;
		*)	log -i "${reverse_mode}" 'reverse_mode'
			raise_cfg_err_count
			return 0
	esac
	[[ $DEBUG_INFO ]] && pr_str "Reverse mode is set to: ${reverse_mode}"
	# check if there is a 'reverse condition' defined in the template
	# if it evaluates to true, the second iptables chain provided will not be included in rule generation
	if [[ ${reverse_condition} ]]; then
		[[ ${reverse_condition} = +([[:word:]]):* ]] || {
			log -E "Invalid \`reverse_condition' descriptor"
			blacklist_template "${target_template}"
			raise_cfg_err_count
			return 0
		}
		rev_condition_name="${reverse_condition%%:*}"
		rev_condition_var="${reverse_condition#*:}"
		[[ ${!rev_condition_name} = ${rev_condition_var} ]] && {
			reverse_rule=0
			second_optionlist=0
			chain_max=0
			[[ $DEBUG_INFO ]] && pr_str "Reverse mode disabled by reverse condition: ${reverse_condition}"
		}
	fi

fi

# look for table definitions in the template.
# now we know there is a target definition in the template
if [[ $table ]]; then
	table_in_template=1
	[[ $DEBUG_INFO ]] && pr_str "Table set in template: $table"
fi

# look for target definitions in the template.
# now we know there is a target definition in the template
if ((${#target[@]})); then
	$($copy_array target arr_tmp_targets) || {
		raise_gen_err_count
		log -U $FUNCNAME
		return 0
	}
	target_in_template=1
	[[ $DEBUG_INFO ]] && for opt_idx in ${!target[@]}; do pr_str "Target set in template: ${target[opt_idx]}"; done
fi

# look for chain defintions in the template.
# a maximum of two chains are allowed with reverse_mode.
if ((${#chain[@]})); then
	chain_max=$((chain_max == -1 ? ${#chain[@]} - 1 : chain_max))
	for ((opt_idx=0; opt_idx<${#chain[@]} && opt_idx<=chain_max; opt_idx++)); do
		arr_tmp_chains[opt_idx]="${chain[opt_idx]}"
	done
	# now we know there is a chain defined in the template.
	chain_in_template=1
	[[ $DEBUG_INFO ]] && for opt_idx in ${!chain[@]}; do pr_str "Chain set in template: ${chain[opt_idx]}"; done
fi
# look for state match definitions in the template.
# index [0] refers to chain[0] and index [1] to chain[1].
# now we know there is a state definition in the template
if ((${#state_match_arg[@]})); then
	state_in_template=1
	[[ $DEBUG_INFO ]] && for opt_idx in ${!state_match_arg[@]}; do pr_str "State set in template: ${state_match_arg[opt_idx]}"; done
fi

# always use certain options
if ((${#always_use_0[@]})); then
	for opt_idx in ${!always_use_0[@]}; do
		if [[ ${always_use_0[opt_idx]#+([[:word:]])=} = emtpy ]]; then
			if ((second_optionlist == 0)); then
				log -E "Configuration error in template \`${target_template}'. \`always_use_0[${opt_idx}]' is set to \`empty', \
					but the template is not configured to use a second option list."
				blacklist_template "${target_template}"
				raise_cfg_err_count
				return 0
			fi
			if [[ ${always_use_1[opt_idx]} ]]; then
				if [[ ${always_use_1[opt_idx]#+([[:word:]])=} != emtpy ]]; then
					arr_alw_use_pos_p[${#arr_alw_use_pos_p[@]}]="${always_use_1[opt_idx]#+([[:word:]])=}"
				else
					log -E "Configuration error in template \`${target_template}'. 
						\`always_use_0[${opt_idx}]' and \`always_use_1[${opt_idx}]' are set to \`empty'."
					blacklist_template "${target_template}"
					raise_cfg_err_count
					return 0
				fi
			else
				log -E "Configuration error in template \`${target_template}'. \`always_use_0[${opt_idx}]' is set to \`empty', \
					but \`always_use_1[${opt_idx}]' is not defined."
				blacklist_template "${target_template}"
				raise_cfg_err_count
				return 0
			fi
		else
			arr_alw_use_pos_p[${#arr_alw_use_pos_p[@]}]="${always_use_0[opt_idx]#+([[:word:]])=}"
		fi
	done
	[[ $DEBUG_INFO ]] && dbg_arr "arr_alw_use_pos_p"
	insert_array 'always_use_0' 'option_list_0'	
	if ((second_optionlist == 1)); then
		if ((${#always_use_1[@]})); then
			insert_array 'always_use_1' 'option_list_1'	
		fi
	fi
fi

# copy it to a temporary array, so we don't need to use 'eval' all the time
$($copy_array "${target_ruleblock}" arr_tmp_ruleblock) || {
	raise_gen_err_count
	log -U $FUNCNAME
	return 0
}
#unset arr_tmp_ruleblock[0]

# now cycle through each array entry and process the rule string
for tmp_arr_idx in ${!arr_tmp_ruleblock[@]}; do
	let RULES_PROCESSED_COUNT+=1
	local -i RULE_MULTIPLICATOR=RULE_COUNT=0
	# save the rule string into a variable used in the sub functions
	# the rule string is composed of the entries collected through ALWAYS_USE options
	# and the options of the ruleblock
	arr_user_pos_p=()
	arr_populated 'arr_alw_use_pos_p' && $($copy_array arr_alw_use_pos_p arr_user_pos_p)
	eval set -- "${arr_tmp_ruleblock[tmp_arr_idx]}"
	for str_entry in "$@"; do
		arr_user_pos_p[${#arr_user_pos_p[@]}]="${str_entry}"
	done
	if [[ ${Q_RULE} ]]; then
		strERR="quick-rule 0 ${Q_RULE}"
		Q_RULE=""
	else
		strERR="${target_ruleblock} ${tmp_arr_idx} ${arr_tmp_ruleblock[tmp_arr_idx]}"
	fi
	# if first column of user entry in ruleblock (whithout the ALWAYS_USE positional params)
	# is a name found in the list of inline functions, run the command and continue with next rule
	[[ ${arr_tmp_ruleblock[tmp_arr_idx]%% *} = *([[:blank:]])@(${INLINE_FUNCTION_LIST}) ]] && {
		log -e "Running inline command: \`${arr_tmp_ruleblock[tmp_arr_idx]}'"
		eval "${arr_tmp_ruleblock[tmp_arr_idx]}" || {
			cmd_err_count 'inline' ${arr_tmp_ruleblock[tmp_arr_idx]}
			continue
		}
		let INLINE_RULES_GENERATED_COUNT+=1
		continue
	}
	# on each loop, the generated rule holding variables need to be reset.
	tmp_pos_par_val_array=()
	unset ${RULELIST_ARRAYS} ${ARG_LIST_ARRAYS}
	local -a ${ARG_LIST_ARRAYS} ${RULELIST_ARRAYS}

	# if the target(s) are defined in the template, copy the info to the arg_list_X array
	if ((target_in_template == 1)); then
		$($copy_array arr_tmp_targets arg_list_target)
	fi
	# if the chain(s) are defined in the template, copy the info to the arg_list_X array
	if ((chain_in_template == 1)); then
		$($copy_array arr_tmp_chains arg_list_chain)
	fi

	# now reference the option lists provided in the template.
	# there can a maximum of two option lists.
	# according to previously evaluated conditions, $second_optionlist is either 0 or 1.
	for ((OPTION_LIST_IDX=0; OPTION_LIST_IDX<=second_optionlist; ++OPTION_LIST_IDX)); do
		# on each loop, the generated rule holding variables need to be reset.
		unset arr_tmp_rule_opt_${OPTION_LIST_IDX} ${ARG_NAMES_LIST[*]/table/}
		local ${ARG_NAMES_LIST[@]}
		local -a arr_tmp_rule_opt_${OPTION_LIST_IDX}
		# indirect reference to the option list.
		local reference_command_array="option_list_${OPTION_LIST_IDX}[@]"
		eval local "${!reference_command_array}" &>/dev/null || {
#		local "${!reference_command_array}" &>/dev/null || {
			log -E "Failed referencing \`option_list_${OPTION_LIST_IDX}'."
			blacklist_template "${target_template}"
			raise_gen_err_count
			return 0
		}
		[[ $DEBUG_INFO ]] && {
			printf "referenced option list: \n"
			opt_idx=0; for rvar in ${!reference_command_array}; do printf "%s " "[${opt_idx}]: $rvar"; let opt_idx+=1; done; echo
		}
		# now check for mandatory variables
		# these are defined as comma separated list in the template,
		# where index [0] of mandatory_vars refers to option_list_0
		# and index [1] to option_list_1.
		[[ ${mandatory_vars[OPTION_LIST_IDX]} ]] && {
			_check_mandatory_vars "${arr_user_pos_p[@]}" || {
				case "${?}" in
					${ER_NODEF})
						cfg_err ${strERR}
						continue 2
					;;
					${ER_CONF})
						blacklist_template "${target_template}"
						return 0
					;;
					*) log -U "_check_mandatory_vars"
						raise_gen_err_count
						return 0
					;;
				esac
			}
		}
		# as referenced above, the option list values can now be read.
		# the gathered information is saved into arrays for later processing.
		_read_option_list "${arr_user_pos_p[@]}" || { 
			log -E "Configuration error in template: \`${target_template}'."
			blacklist_template "${target_template}"
			raise_cfg_err_count
			return 0
		}
		# option name variables will be reused, unset them
		# !!! without unsetting the table variable
		unset ${ARG_NAMES_LIST[*]/table/}

		# do sanity checks on the rule before filling the rulelist arrays.
		# these checks do not require the target or the chain to be known.
		_pre_process_checks || {
			cfg_err ${strERR}
			continue 2
		}
	done

	# if we have two option lists, but there is only one chain in the list, dublicate that entry.
	# this is useful, if the same rule should match different targets i.e. first MARK, then RETURN.
	if ((second_optionlist == 1 && ${#arg_list_chain[@]} == 1)); then
		arg_list_chain[1]="${arg_list_chain[0]}"
	fi

	# validate the option values for sane entries.
	# this is done now, because 'empty' options could have been provided in option_list_0.
	_validate_option_values || {
		cfg_err ${strERR}
		continue
	}
	# perform sanity checks on the template configuration.
	_template_logic_checks || {
		log -E "Ruleblock \`${target_ruleblock}' used with \`${target_template}' template caused template logic violation."
		cfg_err ${strERR}
		return 0
	}
	# after all data is collected (including target + chain), perform tests for sane rules
	_post_data_collection_checks || {
		cfg_err ${strERR}
		continue
	}
	# perform rule multiplication for all available multi-value entries
	_multiply_rules || {
		log -U "_multiply_rules"
		raise_gen_err_count
		continue
	}
	# finally as all information is gathered, the rulelist arrays can be filled.
	_fill_rule_lists || {
		case ${?} in
			${ER_CONF}) cfg_err ${strERR} ;;
			${ER_FAIL}) raise_gen_err_count ;;
			*) log -U "_fill_rule_lists"
				raise_gen_err_count
			;;
		esac
		continue
	}
	# rulelist arrays are filled, now compose log strings and iptables commands
	# and send the generated rules to the add_rule function.
	_compute_rules || {
		case ${?} in
			${ER_CONF}) cfg_err ${strERR} ;;
			*) log -U "_compute_rules"
				raise_gen_err_count
		esac
		return 0
	}
done
} # -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# AUTOMATIC RULE CREATION
# -------------------------------------------------------------------------

allow_loopback() { # LOOPBACK ALLOW
((ENABLE_FILTER)) || return 0
if [[ -z ${LOOPBACK_IF} ]]; then
	log -u 'LOOPBACK_IF'
	return $ER_NODEF
fi
case "${ALLOW_LOOPBACK}" in
	0) log -w "Not allowing loopback communication" ;;
	1)
		log -S "Allowing loopback communication"
		check_iface "${LOOPBACK_IF}" || return $ER_FAIL
		log -e "${PF}accept chain=INPUT idev=${LOOPBACK_IF}"
		add_rule filter INPUT -i "${LOOPBACK_IF}" -j ACCEPT
		log -e "${PF}accept chain=OUTPUT odev=${LOOPBACK_IF}"
		add_rule filter OUTPUT -o "${LOOPBACK_IF}" -j ACCEPT
	;;
	*) log -i "${ALLOW_LOOPBACK}" 'ALLOW_LOOPBACK'
		raise_cfg_err_count
		return 0
esac
} # -------------------------------------------------------------------------

allow_loopback_immediate() { # immediately allow loopback
if [[ -z ${LOOPBACK_IF} ]]; then
	log -u 'LOOPBACK_IF'
	return 0
fi
case "${ALLOW_LOOPBACK}" in
	0) log -w "Not allowing loopback communication" ;;
	1)
		log -I "Immediately allowing loopback communication"
		check_iface "${LOOPBACK_IF}" || return $ER_FAIL
		run_ipt -t filter -A INPUT -i "${LOOPBACK_IF}" -j ACCEPT
		run_ipt -t filter -A OUTPUT -o "${LOOPBACK_IF}" -j ACCEPT
	;;
	*) log -i "${ALLOW_LOOPBACK}" 'ALLOW_LOOPBACK'
		return 0
esac
} # -------------------------------------------------------------------------

allow_admin_connection() { # allow adminstrators connection
local str_addr
if [[ ${SSH_CONNECTION} ]]; then
	set -- ${SSH_CONNECTION}
	local admin_src=$1 admin_dst=$3 admin_dst_port=$4
elif [[ ${ADMIN_CONNECTION} ]]; then
	set -- ${ADMIN_CONNECTION}
	local admin_src=$1 admin_dst=$2 admin_dst_port=$3
	for str_addr in "${admin_src}" "${admin_dst}"; do
		val_ip4_addr "${str_addr}" || { 
			log -E "Unable to allow administrative connection."
			return 0
		}
	done
	val_port "${admin_dst_port}" || { 
		log -E "Unable to allow administrative connection."
		return 0
	}
else
	log -W " \`SSH_CONNECTION' and \`ADMIN_CONNECTION' are unset, unable to create admin connection rules."
	return 0
fi
run_ipt -I INPUT -s ${admin_src} -d ${admin_dst} -p tcp --dport ${admin_dst_port} -j ACCEPT
run_ipt -I OUTPUT -d ${admin_src} -s ${admin_dst} -p tcp --sport ${admin_dst_port} -j ACCEPT
} # -------------------------------------------------------------------------

# ------------------------------------------------------------------------- #
# BAD PACKETS
# ------------------------------------------------------------------------- #

log_drop_scans() { # log/drop portscans
((ENABLE_FILTER)) || return 0
local -i idx
local str_chain str_chainlist str_lpfix
if ! ((${#PORTSCAN_ARRRAY[@]})); then
	log -r PORTSCAN_ARRRAY
	return 1
fi
local TEMPLATE_BUILTIN_LOG_DROP_SCANS=(
"table=filter"
"option_list_0[0]=chain"
"option_list_0[1]=target"
"option_list_0[2]=tcp_flags"
"option_list_0[3]=log_prefix"
"option_list_0[4]=log_level=${GLOBAL_LOGLEVL}"
"option_list_0[5]=limit=${GLOBAL_LOGLIMIT}"
"option_list_0[6]=limit_burst=${GLOBAL_BURSTLIMIT}"
"always_use_0[0]=proto=tcp"
"template_msg='Adding TCP scan rules'"
)
local -a RULEBLOCK_BUILTIN_LOG_DROP_SCANS
for idx in ${!PORTSCAN_ARRRAY[@]}; do
	set -- ${PORTSCAN_ARRRAY[idx]}
	local sname=$1 print_name=${1//_/ }
	shift
	local stcpf=$(build_list ':' "$*") # tcp-flags
	local logscan=$(subst_var LOG_${sname}) # substitute each scan name with the according LOG variable.
	local dropscan=$(subst_var DROP_${sname}) # substitute each scan name with the according DROP variable.
	if ((logscan == 1)); then # LOG scan
		if ((dropscan == 1)); then
			str_lpfix="${LOG_PREFIX}DROP"
		else
			str_lpfix="${LOG_PREFIX}"
		fi
		RULEBLOCK_BUILTIN_LOG_DROP_SCANS[${#RULEBLOCK_BUILTIN_LOG_DROP_SCANS[@]}]="${BIC_SCANS_CHAIN} LOG ${stcpf} ${str_lpfix}${sname/Stealth/}_SCAN: $RULE_SEP $RULE_SEP ${RULE_SEP}"
	fi
	if ((dropscan == 1)); then # DROP scan
		RULEBLOCK_BUILTIN_LOG_DROP_SCANS[${#RULEBLOCK_BUILTIN_LOG_DROP_SCANS[@]}]="${BIC_SCANS_CHAIN} DROP ${stcpf}"
	fi
done
if ((${#RULEBLOCK_BUILTIN_LOG_DROP_SCANS[@]})); then
	if ((PROC_IP_FORWARD == 1)); then
		str_chainlist="INPUT FORWARD"
	else
		str_chainlist="INPUT"
	fi
	for str_chain in ${str_chainlist}; do
		RULEBLOCK_BUILTIN_LOG_DROP_SCANS[${#RULEBLOCK_BUILTIN_LOG_DROP_SCANS[@]}]="${str_chain} ${BIC_SCANS_CHAIN}"
	done
	create_chain filter ${BIC_SCANS_CHAIN}
	process_ipt_ruleblock TEMPLATE_BUILTIN_LOG_DROP_SCANS RULEBLOCK_BUILTIN_LOG_DROP_SCANS
else
	log -w "No TCP scan rules have been collected."
fi
} # -------------------------------------------------------------------------

global_invalid_chain() {
((ENABLE_FILTER)) || return 0
local -i jt_mode=${JUMP_TREE[0]}
local str_chain str_chainlist
local TEMPLATE_BUILTIN_GLOBAL_INVALID_CHAIN=(
"table=filter"
"target[0]=${BIC_GLOBAL_INVALID_STATE}"
"option_list_0[0]=chain"
"always_use_0[0]=state=INVALID"
)
local -a RULEBLOCK_BUILTIN_GLOBAL_INVALID_CHAIN
if ((LOG_INVALID && BLOCK_INVALID)); then
	log -e "Creating global INVALID state chain: ${BIC_GLOBAL_INVALID_STATE}"
	create_chain filter "${BIC_GLOBAL_INVALID_STATE}"
	if ((PROC_IP_FORWARD == 1)); then
		str_chainlist="INPUT OUTPUT FORWARD"
	else
		str_chainlist="INPUT OUTPUT"
	fi
	for str_chain in ${str_chainlist}; do
		RULEBLOCK_BUILTIN_GLOBAL_INVALID_CHAIN[${#RULEBLOCK_BUILTIN_GLOBAL_INVALID_CHAIN[@]}]="${str_chain}"
	done
	((jt_mode == 1)) && jump_tree_off
	process_ipt_ruleblock TEMPLATE_BUILTIN_GLOBAL_INVALID_CHAIN RULEBLOCK_BUILTIN_GLOBAL_INVALID_CHAIN
	((jt_mode == 0)) || jump_tree_on
fi
} # -------------------------------------------------------------------------

log_invalid_state() { # log packets in INVALID state
((ENABLE_FILTER)) || return 0
((LOG_INVALID)) || {
	log -w "Not logging packets in INVALID state"
	return 0
}
local -i jt_mode=${JUMP_TREE[0]}
local str_chain str_chainlist str_lpfix="${LOG_PREFIX}"
local TEMPLATE_BUILTIN_LOG_INVALID_STATE=(
"table=filter"
"target[0]=LOG"
"template_msg='Logging packets in INVALID state'"
"option_list_0[0]=chain"
"option_list_0[1]=log_prefix"
"always_use_0[0]=state=INVALID"
"always_use_0[1]=limit=${GLOBAL_LOGLIMIT}"
"always_use_0[2]=limit_burst=${GLOBAL_BURSTLIMIT}"
"always_use_0[3]=log_level=${GLOBAL_LOGLEVL}"
)
local -a RULEBLOCK_BUILTIN_LOG_INVALID_STATE
if ((LOG_INVALID && BLOCK_INVALID)); then
	str_chainlist="${BIC_GLOBAL_INVALID_STATE}"
	str_lpfix="${str_lpfix}DROP_"
else
	if ((PROC_IP_FORWARD == 1)); then
		str_chainlist="INPUT OUTPUT FORWARD"
	else
		str_chainlist="INPUT OUTPUT"
	fi
fi
for str_chain in ${str_chainlist}; do
	RULEBLOCK_BUILTIN_LOG_INVALID_STATE[${#RULEBLOCK_BUILTIN_LOG_INVALID_STATE[@]}]="${str_chain} ${str_lpfix}INVALID-STATE:"
done
((jt_mode == 1)) && jump_tree_off
process_ipt_ruleblock TEMPLATE_BUILTIN_LOG_INVALID_STATE RULEBLOCK_BUILTIN_LOG_INVALID_STATE
((jt_mode == 0)) || jump_tree_on
} # -------------------------------------------------------------------------

drop_invalid_state() { # drop packets in INVALID state
((ENABLE_FILTER)) || return 0
((BLOCK_INVALID)) || {
	log -w "Not dropping packets in INVALID state"
	return 0
}
local -i jt_mode=${JUMP_TREE[0]}
local str_chain str_chainlist
local TEMPLATE_BUILTIN_DROP_INVALID_STATE=(
"table=filter"
"target[0]=DROP"
"template_msg='Blocking packets in INVALID state'"
"option_list_0[0]=chain"
"always_use_0[0]=state=INVALID"
)
local -a RULEBLOCK_BUILTIN_DROP_INVALID_STATE
if ((LOG_INVALID && BLOCK_INVALID)); then
	str_chainlist="${BIC_GLOBAL_INVALID_STATE}"
else
	if ((PROC_IP_FORWARD == 1)); then
		str_chainlist="INPUT OUTPUT FORWARD"
	else
		str_chainlist="INPUT OUTPUT"
	fi
fi
for str_chain in ${str_chainlist}; do
	RULEBLOCK_BUILTIN_DROP_INVALID_STATE[${#RULEBLOCK_BUILTIN_DROP_INVALID_STATE[@]}]="${str_chain}"
done
((jt_mode == 1)) && jump_tree_off
process_ipt_ruleblock TEMPLATE_BUILTIN_DROP_INVALID_STATE RULEBLOCK_BUILTIN_DROP_INVALID_STATE
((jt_mode == 0)) || jump_tree_on
} # -------------------------------------------------------------------------

log_drop_invalid_state() {
((ENABLE_FILTER)) || return 0
if ((LOG_INVALID && BLOCK_INVALID)); then
	log_invalid_state
	drop_invalid_state
elif ((LOG_INVALID)); then
	log_invalid_state
elif ((BLOCK_INVALID)); then
	drop_invalid_state
fi
} # -------------------------------------------------------------------------

log_illegal_tcp() { # log illegal packets
((ENABLE_FILTER)) || return 0
((LOG_ILLEGAL)) || {
	log -w "Not logging illegal TCP packets"
	return 0
}
local -i jt_mode=${JUMP_TREE[0]}
local str_lpfix="${LOG_PREFIX}"
((BLOCK_ILLEGAL)) && str_lpfix="${str_lpfix}DROP_"
local TEMPLATE_BUILTIN_LOG_ILLEGAL_TCP=(
"table=filter"
"target[0]=LOG"
"chain[0]=${BIC_BAD_TCP_PACKETS}"
"template_msg='Logging illegal TCP packets'"
"option_list_0[0]=tcp_flags"
"option_list_0[1]=tcp_syn"
"option_list_0[2]=log_prefix"
"always_use_0[0]=proto=tcp"
"always_use_0[1]=state=NEW"
"always_use_0[2]=limit=${GLOBAL_LOGLIMIT}"
"always_use_0[3]=limit_burst=${GLOBAL_BURSTLIMIT}"
"always_use_0[4]=log_level=${GLOBAL_LOGLEVL}"
)
local -a RULEBLOCK_BUILTIN_LOG_ILLEGAL_TCP
# first syn ack
RULEBLOCK_BUILTIN_LOG_ILLEGAL_TCP[${#RULEBLOCK_BUILTIN_LOG_ILLEGAL_TCP[@]}]="SYN,ACK:SYN,ACK $RULE_SEP ${str_lpfix}SYNACK:"
# then state new !syn
RULEBLOCK_BUILTIN_LOG_ILLEGAL_TCP[${#RULEBLOCK_BUILTIN_LOG_ILLEGAL_TCP[@]}]="$RULE_SEP !syn ${str_lpfix}NEW-not-SYN:"
((jt_mode == 1)) && jump_tree_off
process_ipt_ruleblock TEMPLATE_BUILTIN_LOG_ILLEGAL_TCP RULEBLOCK_BUILTIN_LOG_ILLEGAL_TCP
((jt_mode == 0)) || jump_tree_on
} # -------------------------------------------------------------------------

drop_illegal_tcp() { # drop illegal packets
((ENABLE_FILTER)) || return 0
((BLOCK_ILLEGAL)) || {
	log -w "Not dropping illegal TCP packets"
	return 0
}
local -i jt_mode=${JUMP_TREE[0]}
local TEMPLATE_BUILTIN_DROP_ILLEGAL_TCP=(
"table=filter"
"chain[0]=${BIC_BAD_TCP_PACKETS}"
"template_msg='Blocking illegal TCP packets'"
"option_list_0[0]=target"
"option_list_0[1]=tcp_flags"
"option_list_0[2]=tcp_syn"
"option_list_0[3]=reject_type"
"always_use_0[0]=proto=tcp"
"always_use_0[1]=state=NEW"
)
local -a RULEBLOCK_BUILTIN_DROP_ILLEGAL_TCP
# first syn ack
#  TO DO: use drop or reject?
RULEBLOCK_BUILTIN_DROP_ILLEGAL_TCP[${#RULEBLOCK_BUILTIN_DROP_ILLEGAL_TCP[@]}]="REJECT SYN,ACK:SYN,ACK $RULE_SEP tcp-reset"
# then state new !syn
RULEBLOCK_BUILTIN_DROP_ILLEGAL_TCP[${#RULEBLOCK_BUILTIN_DROP_ILLEGAL_TCP[@]}]="DROP $RULE_SEP !syn"
((jt_mode == 1)) && jump_tree_off
process_ipt_ruleblock TEMPLATE_BUILTIN_DROP_ILLEGAL_TCP RULEBLOCK_BUILTIN_DROP_ILLEGAL_TCP
((jt_mode == 0)) || jump_tree_on
} # -------------------------------------------------------------------------

log_drop_illegal_tcp() {
((ENABLE_FILTER)) || return 0
local c str_cl="INPUT OUTPUT"
((PROC_IP_FORWARD)) && str_cl=" FORWARD"
log_illegal_tcp
drop_illegal_tcp
# We send all tcp packets through the bad_tcp_packets chain
if ((BLOCK_ILLEGAL || LOG_ILLEGAL)); then
	for c in ${str_cl}; do
		add_rule filter "$c" -p tcp -j "${BIC_BAD_TCP_PACKETS}"
	done
fi
} # -------------------------------------------------------------------------

anti_spoof_rules() { # Anti-Spoofing rules in raw table
((ENABLE_RAW && RAW_TABLE_PRESENT)) || return 0
[[ $PROC_RP_FILTER && $PROC_RP_FILTER != 0 ]] && {
	log -E "\`PROC_RP_FILTER' is set - Anti-Spoofing rules will not be created."
	raise_cfg_err_count
	return 0
}
[[ $EXT_NETNAME_LIST && $LOC_NETNAME_LIST ]] || {
	log -E "Anti-Spoofing rules need external and local networks to be defined."
	raise_cfg_err_count
	return 0
}

local -i idx=0
local str_xnet str_lnet
local -a RULEBLOCK_BUILTIN_ANTI_SPOOF
local TEMPLATE_BUILTIN_ANTI_SPOOF=(
"table=raw"
"template_msg='Creating Anti-Spoofing rules'"
)

if ((USE_IPSET)); then
	if [[ $IPSET_SYNTAX = old ]]; then
		TEMPLATE_BUILTIN_ANTI_SPOOF[${#TEMPLATE_BUILTIN_ANTI_SPOOF[@]}]="option_list_0[0]=chain"
		TEMPLATE_BUILTIN_ANTI_SPOOF[${#TEMPLATE_BUILTIN_ANTI_SPOOF[@]}]="option_list_0[1]=target"
		TEMPLATE_BUILTIN_ANTI_SPOOF[${#TEMPLATE_BUILTIN_ANTI_SPOOF[@]}]="option_list_0[2]=idev"
		TEMPLATE_BUILTIN_ANTI_SPOOF[${#TEMPLATE_BUILTIN_ANTI_SPOOF[@]}]="option_list_0[3]=m_set"
		create_chain raw ANTI_SPOOF
		ipset_create ANTI_SPOOF nethash || return 0
		for str_xnet in $EXT_NETNAME_LIST; do
			str_xnet=$(get_net_iface $str_xnet)
			for str_lnet in $LOC_NETNAME_LIST; do
				ipset_add ANTI_SPOOF "$(get_net_addr $str_lnet)"
			done
			RULEBLOCK_BUILTIN_ANTI_SPOOF[idx++]="ANTI_SPOOF DROP $str_xnet ANTI_SPOOF:src"
		done
		RULEBLOCK_BUILTIN_ANTI_SPOOF[idx]="PREROUTING ANTI_SPOOF"
	else
		TEMPLATE_BUILTIN_ANTI_SPOOF[${#TEMPLATE_BUILTIN_ANTI_SPOOF[@]}]="chain[0]=PREROUTING"
		TEMPLATE_BUILTIN_ANTI_SPOOF[${#TEMPLATE_BUILTIN_ANTI_SPOOF[@]}]="target[0]=DROP"
		TEMPLATE_BUILTIN_ANTI_SPOOF[${#TEMPLATE_BUILTIN_ANTI_SPOOF[@]}]="option_list_0[0]=m_set"
		ipset_create ANTI_SPOOF "hash:net,iface" || return 0
		for str_xnet in $EXT_NETNAME_LIST; do
			str_xnet=$(get_net_iface $str_xnet)
			for str_lnet in $LOC_NETNAME_LIST; do
				ipset_add ANTI_SPOOF "$(get_net_addr $str_lnet),$str_xnet"
			done
		done
		RULEBLOCK_BUILTIN_ANTI_SPOOF[idx]="ANTI_SPOOF:src,dst"
	fi
else
	TEMPLATE_BUILTIN_ANTI_SPOOF[${#TEMPLATE_BUILTIN_ANTI_SPOOF[@]}]="option_list_0[0]=chain"
	TEMPLATE_BUILTIN_ANTI_SPOOF[${#TEMPLATE_BUILTIN_ANTI_SPOOF[@]}]="option_list_0[1]=target"
	TEMPLATE_BUILTIN_ANTI_SPOOF[${#TEMPLATE_BUILTIN_ANTI_SPOOF[@]}]="option_list_0[2]=idev"
	TEMPLATE_BUILTIN_ANTI_SPOOF[${#TEMPLATE_BUILTIN_ANTI_SPOOF[@]}]="option_list_0[3]=src"
	create_chain raw ANTI_SPOOF
	for str_xnet in $EXT_NETNAME_LIST; do
		str_xnet=$(get_net_iface $str_xnet)
		for str_lnet in $LOC_NETNAME_LIST; do
			RULEBLOCK_BUILTIN_ANTI_SPOOF[idx++]="ANTI_SPOOF DROP $str_xnet $(get_net_addr $str_lnet)"
		done
	done
	RULEBLOCK_BUILTIN_ANTI_SPOOF[idx]="PREROUTING ANTI_SPOOF"
fi
process_ipt_ruleblock TEMPLATE_BUILTIN_ANTI_SPOOF RULEBLOCK_BUILTIN_ANTI_SPOOF
} # -------------------------------------------------------------------------

# ------------------------------------------------------------------------- #
# INPUT
# ------------------------------------------------------------------------- #

reject_auth() { # reject auth (ident) on certain interfaces
((ENABLE_FILTER)) || return 0
[[ ${REJECT_AUTH} ]] || {
	log -w "Not applying AUTH reject rules"
	return 0
}
local str str_iflist str_netlist str_net_if
local -a RULEBLOCK_BUILTIN_REJECT_AUTH
local TEMPLATE_BUILTIN_REJECT_AUTH=(
"table=filter"
"target[0]=REJECT"
"chain[0]=INPUT"
"template_msg='Rejecting IDENT (auth) on certain interfaces or networks'"
"option_list_0[0]=idev"
"option_list_0[1]=dst"
"always_use_0[0]=proto=tcp"
"always_use_0[1]=dport=113"
"always_use_0[2]=state=NEW"
"always_use_0[3]=reject_type=tcp-reset"
)
for str in ${REJECT_AUTH}; do
	if lsearch "${str}" ${NET_IFLIST}; then
		str_iflist+=" ${str}"
	elif lsearch "${str}" ${NET_NAME_LIST}; then
		str_netlist+=" ${str}"
	else
		log -E "Unable to find a matching interface or netname for \`${str}' in \`REJECT_AUTH'."
		raise_cfg_err_count
	fi
done
[[ -z ${str_iflist} && -z ${str_netlist} ]] && {
	log -E "Unable to find a matching interface or netname in \`REJECT_AUTH'."
	raise_cfg_err_count
	return 0
}
[[ ${str_iflist} ]] && RULEBLOCK_BUILTIN_REJECT_AUTH[${#RULEBLOCK_BUILTIN_REJECT_AUTH[@]}]=$(build_list ',' "${str_iflist}")
[[ ${str_netlist} ]] && {
	for str in ${str_netlist}; do
		str_net_if=$(get_net_iface "${str}")
		[[ ${str_net_if} ]] || {
			log -d "${str}"
			raise_gen_err_count
			continue
		}
		RULEBLOCK_BUILTIN_REJECT_AUTH[${#RULEBLOCK_BUILTIN_REJECT_AUTH[@]}]="${str_net_if} ${str}"
	done
}
process_ipt_ruleblock TEMPLATE_BUILTIN_REJECT_AUTH RULEBLOCK_BUILTIN_REJECT_AUTH
} # -------------------------------------------------------------------------

drop_netbios() { # drop NetBios broadcasts on certain interfaces (prevent log spamming)
((ENABLE_FILTER)) || return 0
[[ ${DROP_NETBIOS} ]] || {
	log -w "Not applying NETBIOS broadcasts drop rules"
	return 0
}
local iface_ip iface_mask iface_brd str str_iflist str_netlist str_net_data str_iface
local TEMPLATE_BUILTIN_DROP_NETBIOS_BCAST=(
"table=filter"
"target[0]=DROP"
"chain[0]=INPUT"
"template_msg='Dropping NETBIOS broadcasts on certain interfaces or networks'"
"option_list_0[0]=idev"
"option_list_0[1]=src"
"option_list_0[2]=dst"
"always_use_0[0]=proto=udp"
"always_use_0[1]=dport=137,138"
"always_use_0[2]=state=NEW"
)
local -a RULEBLOCK_BUILTIN_DROP_NETBIOS_BCAST
for str in ${DROP_NETBIOS}; do
	if lsearch "${str}" ${NET_IFLIST}; then
		str_iflist+=" ${str}"
	elif lsearch "${str}" ${NET_NAME_LIST}; then
		str_netlist+=" ${str}"
	else
		log -E "Unable to find a matching interface or netname for \`${str}' in \`DROP_NETBIOS'."
		raise_cfg_err_count
	fi
done

[[ -z ${str_iflist} && -z ${str_netlist} ]] && {
	log -E "Unable to find a matching interface or netname in \`DROP_NETBIOS'."
	raise_cfg_err_count
	return 0
}
for str in ${str_iflist}; do
	while read iface_ip iface_mask iface_brd; do
		if [[ -z ${iface_brd} ]]; then
			log -E "Unable to retrieve broadcast address for interface \`${str}'."
			raise_gen_err_count
			continue
		fi
		RULEBLOCK_BUILTIN_DROP_NETBIOS_BCAST[${#RULEBLOCK_BUILTIN_DROP_NETBIOS_BCAST[@]}]="$str $(ip_network "${iface_ip}/${iface_mask}")/${iface_mask} ${iface_brd}"
	done < <(get_if_ipv4_data "${str}" -i -m -b)
done
for str in ${str_netlist}; do
	str_net_data=$(get_net_data "${str}") || continue
	set -- ${str_net_data}
	str_iface="$1" iface_ip=$(ip_network "${3}/${4}") iface_mask="$4" iface_brd="${6}"
	if [[ -z ${iface_brd} ]]; then
		log -E "Unable to retrieve broadcast address for interface \`${str}'."
		raise_gen_err_count
		continue
	fi
	RULEBLOCK_BUILTIN_DROP_NETBIOS_BCAST[${#RULEBLOCK_BUILTIN_DROP_NETBIOS_BCAST[@]}]="${str_iface} ${iface_ip}/${iface_mask} ${iface_brd}"
done
process_ipt_ruleblock TEMPLATE_BUILTIN_DROP_NETBIOS_BCAST RULEBLOCK_BUILTIN_DROP_NETBIOS_BCAST
} # -------------------------------------------------------------------------

global_broadcasts_chain() {
((ENABLE_FILTER)) || return 0
if [[ ${DROP_DHCP} || ${DROP_UPNP} ]]; then
	log -N "Creating global broadcasts chain: $BIC_GLOBAL_BROADCASTS_CHAIN"
	create_chain filter "$BIC_GLOBAL_BROADCASTS_CHAIN"
	log -e "${PF}chain=INPUT dst=${BCAST_DEST} target=$BIC_GLOBAL_BROADCASTS_CHAIN"
	add_rule filter INPUT -d ${BCAST_DEST} -j "$BIC_GLOBAL_BROADCASTS_CHAIN"
fi
} # -------------------------------------------------------------------------

drop_dhcp() { # drop DHCP broadcasts on certain interfaces (prevent log spamming)
((ENABLE_FILTER)) || return 0
[[ ${DROP_DHCP} ]] || {
	log -w "Not applying DHCP broadcasts drop rules"
	return 0
}
local TEMPLATE_BUILTIN_DROP_DHCP=(
"table=filter"
"target[0]=DROP"
"chain[0]=$BIC_GLOBAL_BROADCASTS_CHAIN"
"template_msg='Dropping DHCP broadcasts on certain interfaces'"
"option_list_0[0]=idev"
"always_use_0[0]=proto=udp"
"always_use_0[1]=sport=67,68"
"always_use_0[2]=dport=67,68"
"always_use_0[3]=state=NEW"
)
local -a RULEBLOCK_BUILTIN_DROP_DHCP[${#RULEBLOCK_BUILTIN_DROP_DHCP[@]}]=$(build_list ',' "${DROP_DHCP}")
process_ipt_ruleblock TEMPLATE_BUILTIN_DROP_DHCP RULEBLOCK_BUILTIN_DROP_DHCP
} # -------------------------------------------------------------------------

drop_upnp() { # drop (Microsoft) UPNP broadcasts on certain interfaces (prevent log spamming)
((ENABLE_FILTER)) || return 0
[[ ${DROP_UPNP} ]] || {
	log -w "Not applying UPNP broadcasts drop rules"
	return 0
}
local TEMPLATE_BUILTIN_DROP_UPNP=(
"table=filter"
"target[0]=DROP"
"chain[0]=$BIC_GLOBAL_BROADCASTS_CHAIN"
"template_msg='Dropping UPNP broadcasts on certain interfaces'"
"option_list_0[0]=idev"
"always_use_0[0]=proto=udp"
"always_use_0[1]=dport=1900"
"always_use_0[2]=state=NEW"
)
local -a RULEBLOCK_BUILTIN_DROP_UPNP[${#RULEBLOCK_BUILTIN_DROP_UPNP[@]}]=$(build_list ',' "${DROP_UPNP}")
process_ipt_ruleblock TEMPLATE_BUILTIN_DROP_UPNP RULEBLOCK_BUILTIN_DROP_UPNP
} # -------------------------------------------------------------------------

# ------------------------------------------------------------------------- #
# OUTPUT
# ------------------------------------------------------------------------- #

restrict_output() { # restrict OUTPUT chain
((ENABLE_FILTER)) || return 0
[[ ${RESTRICT_OUTPUT} ]] || { log -v 'RESTRICT_OUTPUT'; return 0; }
local -i idx in_rule_exist in_estab_found in_related_found
local str_state_in_msg str_state_out_msg str_iface str_iface_ip str_existing_in_chain
local TEMPLATE_BUILTIN_RESTRICT_OUTPUT=(
"table=filter"
"target[0]=ACCEPT"
"chain[0]=OUTPUT"
"chain[1]=INPUT"
"reverse_mode=reverse"
"reverse_condition=in_rule_exist:1"
"option_list_0[0]=odev"
"option_list_0[1]=src"
"option_list_1[0]=idev"
"option_list_1[1]=dst"
)
local -a RULEBLOCK_BUILTIN_RESTRICT_OUTPUT
if [[ ${NO_OUTPUT_MSG} ]]; then log -N "${NO_OUTPUT_MSG}"; fi
case "${RESTRICT_OUTPUT}" in
	IPBOUND | IFBOUND) # rules bound to IP or interface
		case "${REST_ALLOW_RELATED:=1}" in # set state for back in traffic
			0) str_state_in_msg=${stE} str_state_out_msg=${stNE} ;;
			1) str_state_in_msg=${stER} str_state_out_msg=${stNER} ;;
			*) log -i "${REST_ALLOW_RELATED}" 'REST_ALLOW_RELATED'
				raise_cfg_err_count
				return 0
			;;
		esac
		TEMPLATE_BUILTIN_RESTRICT_OUTPUT[${#TEMPLATE_BUILTIN_RESTRICT_OUTPUT[@]}]="state_match_arg[0]=${str_state_out_msg}"
		TEMPLATE_BUILTIN_RESTRICT_OUTPUT[${#TEMPLATE_BUILTIN_RESTRICT_OUTPUT[@]}]="state_match_arg[1]=${str_state_in_msg}"
		log -S "Setting ${RESTRICT_OUTPUT} rules in OUTPUT chain"
		for str_iface in ${NET_IFLIST}; do # for every interface used
			local -i in_rule_exist=0 in_estab_found=0 in_related_found=0
			RULEBLOCK_BUILTIN_RESTRICT_OUTPUT=()
			for idx in ${!KNOWN_TRAFFIC_MAP[@]}; do
				set -- ${KNOWN_TRAFFIC_MAP[idx]}
				case "$1" in
					INPUT|INPUT_${str_iface})
						case "${2:-ER}" in
							e|E)
								if ((REST_ALLOW_RELATED == 0)); then
									in_rule_exist=1 str_existing_in_chain="$1"
									break
								else
									if ((in_related_found == 0)); then
										in_estab_found=1
									else
										in_rule_exist=1 str_existing_in_chain="$1"
										break
									fi
								fi
							;;
							er|ER|_)
								in_rule_exist=1 str_existing_in_chain="$1"
								break
							;;
							r|R)
								if ((REST_ALLOW_RELATED == 1)); then
									if ((in_estab_found == 0)); then
										in_related_found=1
									else
										in_rule_exist=1 str_existing_in_chain="$1"
										break
									fi
								fi
							;;
						esac
					;;
				esac
			done
			if ((in_rule_exist == 1)); then
				log -N "Found shadowing rule(s) in \`KNOWN_TRAFFIC_MAP' for chain \`${str_existing_in_chain}', \
					skipping established/related rule for interface: \`${str_iface}'"
			fi
			case "${RESTRICT_OUTPUT}" in
				IFBOUND) # rules bound to interface
					RULEBLOCK_BUILTIN_RESTRICT_OUTPUT[${#RULEBLOCK_BUILTIN_RESTRICT_OUTPUT[@]}]="${str_iface}"
				;;
				IPBOUND) # rules bound to IP address
					while read str_iface_ip; do
						RULEBLOCK_BUILTIN_RESTRICT_OUTPUT[${#RULEBLOCK_BUILTIN_RESTRICT_OUTPUT[@]}]="${str_iface} ${str_iface_ip}"
					done < <(get_if_ipv4_data "${str_iface}" -i)
				;;
			esac
			process_ipt_ruleblock TEMPLATE_BUILTIN_RESTRICT_OUTPUT RULEBLOCK_BUILTIN_RESTRICT_OUTPUT
		done
	;;
esac
if ((OUTPUT_RULES_REQUIRED == 1)); then
	log -S "OUTPUT chain is restricted, applying additional local allow rules"
	allow_out_dns
	allow_out_ntp
	allow_out_lan
fi
return 0
} # -------------------------------------------------------------------------

allow_out_dns() { # allow local (host itself) to remote DNS server traffic
((REST_OUT_DNS_ALLOW == 0)) && {
	log -w "Not allowing local host to ISP nameservers traffic"
	return 0
}
if ! ((${#LOCAL_NS[@]})); then
	log -u 'LOCAL_NS'
	return 0
fi
local -i idx
local strERR str_nslist str_ext_net str_ext_netif str_ns_host str_ns_if_list
local -a RULEBLOCK_BUILTIN_LOCAL_HOST_DNS_SERVERS_ALLOW RULEBLOCK_BUILTIN_LOCAL_HOST_DNS_SERVERS_JUMPS
local TEMPLATE_BUILTIN_LOCAL_HOST_DNS_SERVERS_ALLOW=(
"table=filter"
"target[0]=ACCEPT"
"chain[0]=$BIC_LOCAL_NAMESERVERS"
"option_list_0[0]=odev"
"option_list_0[1]=src"
"option_list_0[2]=dst"
"option_list_0[3]=state"
)
local -i idx=0 i=0
local TEMPLATE_BUILTIN_LOCAL_HOST_DNS_SERVERS_JUMPS=(
"table=filter"
"target[0]=$BIC_LOCAL_NAMESERVERS"
"chain[0]=OUTPUT"
"chain[1]=INPUT"
"reverse_mode=reverse"
"reverse_condition=REVERSE_INPUT_RULES_REQUIRED:0"
"option_list_0[1]=odev"
"option_list_1[1]=idev"
"always_use_0[0]=proto=udp,tcp"
"always_use_0[1]=dport=53"
"always_use_1[0]=proto=udp,tcp"
"always_use_1[1]=sport=53"
)
local RULEBLOCK_BUILTIN_LOCAL_HOST_DNS_SERVERS_ALLOW[i++]="$RULE_SEP $RULE_SEP $RULE_SEP ESTABLISHED"
log -I "Allowing local host to ISP nameservers traffic"
for idx in ${!LOCAL_NS[@]}; do
	set -- ${LOCAL_NS[idx]}
	str_nslist=${1//,/ } str_ext_net=$2
	strERR="LOCAL_NS ${idx} ${LOCAL_NS[idx]}"
	if [[ ${str_ext_net} ]]; then # get external interface
		str_ext_netif=$(get_net_iface "${str_ext_net}")
		[[ $str_ext_netif ]] || {
			log -d "${str_ext_net}"
			cfg_err ${strERR}
			continue
		}
	fi
	for str_ns_host in $str_nslist; do
		if [[ -z $str_ext_net ]]; then
			str_ext_netif=$(get_route_iface "$str_ns_host")
			[[ $str_ext_netif ]] || {
				log -E "Unable to retrieve interface to route $str_ns_host over."
				raise_gen_err_count
				continue
			}
		fi
		if ! lsearch "$str_ext_netif" $str_ns_if_list; then
		   	str_ns_if_list+="$str_ext_netif "
			if ((USE_IPSET)); then
				if [[ $IPSET_SYNTAX = old ]]; then
					ipset_create "${BIC_LOCAL_NAMESERVERS}_$str_ext_netif" "iphash" || return 0
				else
					ipset_create "${BIC_LOCAL_NAMESERVERS}_$str_ext_netif" "hash:ip" || return 0
				fi
			fi
		fi
		if ((USE_IPSET)); then
			ipset_add "${BIC_LOCAL_NAMESERVERS}_$str_ext_netif" "$str_ns_host"
		else
			while read iface_ip; do
				RULEBLOCK_BUILTIN_LOCAL_HOST_DNS_SERVERS_ALLOW[i++]="$str_ext_netif ${iface_ip} $str_ns_host NEW,ESTABLISHED"
			done < <(get_if_ipv4_data "$str_ext_netif" -i)
		fi
	done
done
if ((USE_IPSET)); then
	if [[ $str_ns_if_list ]]; then
		TEMPLATE_BUILTIN_LOCAL_HOST_DNS_SERVERS_ALLOW[${#TEMPLATE_BUILTIN_LOCAL_HOST_DNS_SERVERS_ALLOW[@]}]="option_list_0[4]=m_set"
	fi
	for str_ext_netif in $str_ns_if_list; do
		RULEBLOCK_BUILTIN_LOCAL_HOST_DNS_SERVERS_ALLOW[i++]="$str_ext_netif $RULE_SEP $RULE_SEP NEW,ESTABLISHED ${BIC_LOCAL_NAMESERVERS}_$str_ext_netif:dst"
	done
fi
if [[ $str_ns_if_list ]] && ((${#RULEBLOCK_BUILTIN_LOCAL_HOST_DNS_SERVERS_ALLOW[@]} > 1)); then
	((REVERSE_INPUT_RULES_REQUIRED == 0)) && unset RULEBLOCK_BUILTIN_LOCAL_HOST_DNS_SERVERS_ALLOW[0]
	create_chain filter "$BIC_LOCAL_NAMESERVERS"
	RULEBLOCK_BUILTIN_LOCAL_HOST_DNS_SERVERS_JUMPS[${#RULEBLOCK_BUILTIN_LOCAL_HOST_DNS_SERVERS_JUMPS[@]}]=$(build_list ',' "$str_ns_if_list")
	process_ipt_ruleblock TEMPLATE_BUILTIN_LOCAL_HOST_DNS_SERVERS_ALLOW RULEBLOCK_BUILTIN_LOCAL_HOST_DNS_SERVERS_ALLOW 
	process_ipt_ruleblock TEMPLATE_BUILTIN_LOCAL_HOST_DNS_SERVERS_JUMPS RULEBLOCK_BUILTIN_LOCAL_HOST_DNS_SERVERS_JUMPS 
else
	log -W "No local host to ISP nameserver rules have been collected"
fi
} # -------------------------------------------------------------------------

allow_out_ntp() { # allow local (host itself) to remote NTP server traffic
((REST_OUT_NTP_ALLOW)) || {
	log -w "Not allowing local host to NTP server(s) traffic"
	return 0
}
if ! ((${#TIME_SERVERS[@]})); then
	log -u 'TIME_SERVERS'
	return 0
fi
local -i idx i=0
local -a RULEBLOCK_BUILTIN_LOCAL_USE_NTP_ALLOW RULEBLOCK_BUILTIN_LOCAL_USE_NTP_JUMPS
local strERR str_ntp_servers str_ext_net str_ext_netif str_iface_ip str_ntp_host str_ntp_if_list str_setname
local TEMPLATE_BUILTIN_LOCAL_USE_NTP_SERVICE_ALLOW=(
"table=filter"
"target[0]=ACCEPT"
"chain[0]=$BIC_NTP_SVR_CHAIN"
"option_list_0[0]=odev"
"option_list_0[1]=src"
"option_list_0[2]=dst"
"option_list_0[3]=state"
)
local TEMPLATE_BUILTIN_LOCAL_USE_NTP_SERVICE_JUMPS=(
"table=filter"
"target[0]=$BIC_NTP_SVR_CHAIN"
"chain[0]=OUTPUT"
"chain[1]=INPUT"
"reverse_mode=reverse"
"reverse_condition=REVERSE_INPUT_RULES_REQUIRED:0"
"option_list_0[0]=odev"
"option_list_1[0]=idev"
"always_use_0[0]=proto=udp"
"always_use_0[1]=sport=123"
"always_use_0[2]=dport=123"
"always_use_1[0]=proto=udp"
"always_use_1[1]=dport=123"
"always_use_1[2]=sport=123"
)
local RULEBLOCK_BUILTIN_LOCAL_USE_NTP_ALLOW[i++]="$RULE_SEP $RULE_SEP $RULE_SEP ESTABLISHED"
if ((USE_IPSET)); then
	TEMPLATE_BUILTIN_LOCAL_USE_NTP_SERVICE_ALLOW[${#TEMPLATE_BUILTIN_LOCAL_USE_NTP_SERVICE_ALLOW[@]}]="option_list_0[4]=m_set"
fi
log -I "Allowing local host to NTP server(s) traffic"
for idx in ${!TIME_SERVERS[@]}; do
	set -- ${TIME_SERVERS[idx]}
	str_ntp_servers=${1//,/ } str_ext_net=$2
	strERR="TIME_SERVERS $idx ${TIME_SERVERS[idx]}"
	if [[ $str_ext_net ]]; then # get external interface
		str_ext_netif=$(get_net_iface $ext_net)
		str_iface_ip=$(get_net_ipaddr $ext_net)
		[[ $str_ext_netif && $str_iface_ip ]] || {
			log -d "$str_ext_net"
			cfg_err $strERR
			continue
		}
		if ((USE_IPSET)); then
			str_setname="${BIC_NTP_SVR_CHAIN}_${str_ext_net}"
			if [[ $IPSET_SYNTAX = old ]]; then
				ipset_create "$str_setname" "iphash" || return 0
			else
				ipset_create "$str_setname" "hash:ip" || return 0
			fi
			for ntp_host in $str_ntp_servers; do
				ipset_add "$str_setname" "$str_ntp_host"
			done
			RULEBLOCK_BUILTIN_LOCAL_USE_NTP_ALLOW[i++]="$str_ext_netif $str_iface_ip $RULE_SEP NEW,ESTABLISHED $str_setname:dst"
		else
			for ntp_host in $str_ntp_servers; do
				RULEBLOCK_BUILTIN_LOCAL_USE_NTP_ALLOW[i++]="$str_ext_netif $str_iface_ip $str_ntp_host NEW,ESTABLISHED"
			done
		fi
	else # no external network specified
		for str_ntp_host in $str_ntp_servers; do
			str_ext_netif=$(get_route_iface "$str_ntp_host") # retrieve external interface for each host
			[[ $str_ext_netif ]] || {
				log -E "Unable to retrieve interface to route $str_ntp_host over."
				raise_gen_err_count
				continue
			}
			if ! lsearch "$str_ext_netif" $str_ntp_if_list; then # register interface
				str_ntp_if_list+="$str_ext_netif "
				if ((USE_IPSET)); then
					str_setname="${BIC_NTP_SVR_CHAIN}_${str_ext_netif}"
					if [[ $IPSET_SYNTAX = old ]]; then
						ipset_create "$str_setname" "iphash" || return 0
					else
						ipset_create "$str_setname" "hash:ip" || return 0
					fi
				fi
			fi
			if ((USE_IPSET)); then
				ipset_add "$str_setname" "$str_ntp_host"
			else
				while read str_iface_ip; do
					RULEBLOCK_BUILTIN_LOCAL_USE_NTP_ALLOW[i++]="$str_ext_netif $str_iface_ip $str_ntp_host NEW,ESTABLISHED"
				done < <(get_if_ipv4_data "$str_ext_netif" -i)
			fi
		done
	fi
done
if ((USE_IPSET)); then
	for str_ext_netif in $str_ntp_if_list; do
		while read str_iface_ip; do
			RULEBLOCK_BUILTIN_LOCAL_USE_NTP_ALLOW[i++]="$str_ext_netif $str_iface_ip $RULE_SEP NEW,ESTABLISHED ${BIC_NTP_SVR_CHAIN}_${str_ext_netif}:dst"
		done < <(get_if_ipv4_data "$str_ext_netif" -i)
	done
fi
if ((${#RULEBLOCK_BUILTIN_LOCAL_USE_NTP_ALLOW[@]} > 1 )); then
	((REVERSE_INPUT_RULES_REQUIRED == 0)) && unset RULEBLOCK_BUILTIN_LOCAL_USE_NTP_ALLOW[0]
	RULEBLOCK_BUILTIN_LOCAL_USE_NTP_JUMPS[${#RULEBLOCK_BUILTIN_LOCAL_USE_NTP_JUMPS[@]}]=$(build_list ',' "$str_ntp_if_list")
	create_chain filter "$BIC_NTP_SVR_CHAIN"
	process_ipt_ruleblock TEMPLATE_BUILTIN_LOCAL_USE_NTP_SERVICE_ALLOW RULEBLOCK_BUILTIN_LOCAL_USE_NTP_ALLOW
	process_ipt_ruleblock TEMPLATE_BUILTIN_LOCAL_USE_NTP_SERVICE_JUMPS RULEBLOCK_BUILTIN_LOCAL_USE_NTP_JUMPS
else
	log -W "No local host to NTP server rules have been collected"
fi
} # -------------------------------------------------------------------------

allow_out_lan() { # allow OUTPUT to certain LAN(s)
[[ ${REST_OUT_LAN_ALLOW} ]] || {
	log -w "Not allowing OUTPUT to certain LAN(s)"
	return 0
}
local -i idx
local str_iface str_iface_ip str_iface_mask str_existing_in_chain
local TEMPLATE_BUILTIN_ALLOW_OUT_LAN=(
"table=filter"
"target[0]=ACCEPT"
"chain[0]=OUTPUT"
"chain[1]=INPUT"
"reverse_mode=reverse"
"reverse_condition=in_rule_exist:1"
"option_list_0[0]=odev"
"option_list_0[1]=src"
"option_list_0[2]=dst"
"option_list_1[0]=idev"
"option_list_1[1]=dst"
"option_list_1[2]=src"
"state_match_arg[0]=NEW,ESTABLISHED,RELATED"
"state_match_arg[1]=ESTABLISHED,RELATED"
)
local -a RULEBLOCK_BUILTIN_ALLOW_OUT_LAN
log -I "Allowing OUTPUT from certain interfaces"
for str_iface in ${REST_OUT_LAN_ALLOW}; do
	local -i in_rule_exist=0 in_estab_found=0 in_related_found=0
	RULEBLOCK_BUILTIN_ALLOW_OUT_LAN=()
	lsearch "${str_iface}" ${EXT_IFLIST} && {
		log -E "\`REST_OUT_LAN_ALLOW' does not allow external interfaces in the list."
		raise_cfg_err_count
		continue
	}
	for idx in ${!KNOWN_TRAFFIC_MAP[@]}; do
		set -- ${KNOWN_TRAFFIC_MAP[idx]}
		case "$1" in
			INPUT|INPUT_${str_iface})
				case "${2:-ER}" in
					e|E)
						if ((in_related_found == 0)); then
							in_estab_found=1
						else
							in_rule_exist=1 str_existing_in_chain="$1"
							break
						fi
					;;
					er|ER|_)
						in_rule_exist=1 str_existing_in_chain="$1"
						break
					;;
					r|R)
						if ((in_estab_found == 0)); then
							in_related_found=1
						else
							in_rule_exist=1 str_existing_in_chain="$1"
							break
						fi
					;;
				esac
			;;
		esac
	done
	if ((in_rule_exist == 1)); then
		log -N "Found shadowing rule(s) in \`KNOWN_TRAFFIC_MAP' for chain \`${str_existing_in_chain}', \
			skipping established/related rule for interface: \`${str_iface}'"
	fi
	while read str_iface_ip str_iface_mask; do
	RULEBLOCK_BUILTIN_ALLOW_OUT_LAN[${#RULEBLOCK_BUILTIN_ALLOW_OUT_LAN[@]}]="$str_iface $str_iface_ip $(ip_network "${str_iface_ip}/$str_iface_mask")/$str_iface_mask"
	done < <(get_if_ipv4_data "${str_iface}" -i -m)
	process_ipt_ruleblock TEMPLATE_BUILTIN_ALLOW_OUT_LAN RULEBLOCK_BUILTIN_ALLOW_OUT_LAN
done
} # -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# FORWARD
# -------------------------------------------------------------------------

lan_isp_smtp() { # allow subnets to use certain SMTP servers
((ENABLE_FILTER)) || return 0
((AUTO_ISP_SMTP)) || {
	log -w "Not using automatic ISP SMTP server configuration"
	return 0
}
if ! ((${#ISP_SMTP[@]})); then
	log -u 'ISP_SMTP'
	return 0
fi
local -i idx i=0
local -a SMTP_IF_LIST RULEBLOCK_BUILTIN_LAN_USE_SMTP_ALLOW
local str_loc_net str_smtp_ips str_ext_net str_ext_netif str_loc_netif str_netaddr str_smtp_host str_smtp_net_list

local TEMPLATE_BUILTIN_LAN_USE_SMTP_ALLOW=(
"table=filter"
"target[0]=ACCEPT"
"chain[0]=$BIC_SMTP_SRV_CHAIN"
"option_list_0[0]=idev"
"option_list_0[1]=odev"
"option_list_0[2]=src"
"option_list_0[3]=dst"
"option_list_0[4]=state"
)
local TEMPLATE_BUILTIN_LAN_USE_SMTP_JUMPS=(
"table=filter"
"target[0]=$BIC_SMTP_SRV_CHAIN"
"chain[0]=FORWARD"
"reverse_mode=reverse"
"reverse_condition=REVERSE_FOWARD_RULES_REQUIRED:0"
"option_list_0[0]=idev"
"option_list_0[1]=odev"
"option_list_0[2]=src"
"option_list_1[0]=odev"
"option_list_1[1]=idev"
"option_list_1[2]=dst"
"always_use_0[0]=proto=tcp"
"always_use_0[1]=dport=25"
"always_use_1[0]=proto=tcp"
"always_use_1[1]=sport=25"
)
RULEBLOCK_BUILTIN_LAN_USE_SMTP_ALLOW[i++]="$RULE_SEP $RULE_SEP $RULE_SEP $RULE_SEP ESTABLISHED"
if ((USE_IPSET)); then
	TEMPLATE_BUILTIN_LAN_USE_SMTP_ALLOW[${#TEMPLATE_BUILTIN_LAN_USE_SMTP_ALLOW[@]}]="option_list_0[5]=m_set"
fi
log -I "Allowing subnet(s) to ISP SMTP server(s)"
for idx in ${!ISP_SMTP[@]}; do
	set -- ${ISP_SMTP[idx]}
	strERR="ISP_SMTP $idx ${ISP_SMTP[idx]}"
	str_loc_net="$1" str_smtp_ips="${2//,/ }" str_ext_net="$3"
	check_vars_no_sep str_loc_net str_smtp_ips || {
		cfg_err $strERR
		continue
	}
	if [[ $str_ext_net ]]; then
		str_ext_netif=$(get_net_iface "$str_ext_net")
		[[ $str_ext_netif ]] || {
			log -d "$str_ext_net"
			raise_gen_err_count
			continue
		}
	fi
	str_loc_netif=$(get_net_iface $str_loc_net) str_netaddr=$(get_net_addr $str_loc_net)
	[[ $str_loc_netif && $str_netaddr ]] || {
		log -d "$str_loc_net"
		raise_gen_err_count
		continue
	}
	if ! lsearch "$str_loc_net" $str_smtp_net_list; then
		str_smtp_net_list+="$str_loc_net "
		if ((USE_IPSET)); then
			if [[ $IPSET_SYNTAX = old ]]; then
				ipset_create "${BIC_SMTP_SRV_CHAIN}_$str_loc_net" "iphash" || return 0
			else
				ipset_create "${BIC_SMTP_SRV_CHAIN}_$str_loc_net" "hash:ip" || return 0
			fi
			RULEBLOCK_BUILTIN_LAN_USE_SMTP_ALLOW[i++]="$str_loc_netif $RULE_SEP $str_netaddr $RULE_SEP NEW,ESTABLISHED ${BIC_SMTP_SRV_CHAIN}_$str_loc_net:dst"
		fi
	fi
	for str_smtp_host in ${str_smtp_ips}; do
		[[ $str_ext_net ]] || {
			str_ext_netif=$(get_route_iface "$str_smtp_host")
			[[ $str_ext_netif ]] || {
				log -E "Unable to retrieve interface to route $str_smtp_host over."
				raise_gen_err_count
				continue
			}
		}
		[[ $str_loc_netif != $str_ext_netif ]] || {
			log -E "SMTP input and output interfaces are the same."
			cfg_err $strERR
			continue
		}
		if ((USE_IPSET)); then
			ipset_add "${BIC_SMTP_SRV_CHAIN}_$str_loc_net" "$str_smtp_host"
		else
			RULEBLOCK_BUILTIN_LAN_USE_SMTP_ALLOW[i++]="$str_loc_netif $str_ext_netif $str_netaddr $str_smtp_host NEW,ESTABLISHED"
		fi
		lsearch "${str_loc_netif}_to_$str_ext_netif" $(show_array_column SMTP_IF_LIST) || \
			SMTP_IF_LIST[${#SMTP_IF_LIST[@]}]="${str_loc_netif}_to_$str_ext_netif $str_netaddr"
	done
done
if ((${#SMTP_IF_LIST[@]} > 0 && ${#RULEBLOCK_BUILTIN_LAN_USE_SMTP_ALLOW[@]} > 1)); then
	((REVERSE_FOWARD_RULES_REQUIRED == 0)) && unset RULEBLOCK_BUILTIN_LAN_USE_SMTP_ALLOW[0]
	create_chain filter $BIC_SMTP_SRV_CHAIN
	for idx in ${!SMTP_IF_LIST[@]}; do
		RULEBLOCK_BUILTIN_LAN_USE_SMTP_JUMPS[${#RULEBLOCK_BUILTIN_LAN_USE_SMTP_JUMPS[@]}]="${SMTP_IF_LIST[idx]/_to_/ }"
	done
	process_ipt_ruleblock TEMPLATE_BUILTIN_LAN_USE_SMTP_ALLOW RULEBLOCK_BUILTIN_LAN_USE_SMTP_ALLOW
	process_ipt_ruleblock TEMPLATE_BUILTIN_LAN_USE_SMTP_JUMPS RULEBLOCK_BUILTIN_LAN_USE_SMTP_JUMPS
else
	log -W "No LAN to SMTP server rules have been collected"
fi
} # -------------------------------------------------------------------------

intns_to_extns() { # allow internal DNS servers udp traffic to providers name servers.
((ENABLE_FILTER)) || return 0
((AUTO_PROV_DNS)) || {
	log -w "Not using automated provider DNS configuration"
	return 0
}
((${#ISP_NS[@]})) || {
	log -u 'ISP_NS'
	return 0
}
((${#LAN_NS[@]})) || {
	log -u 'LAN_NS'
	return 0
}
local -i ns_idx isp_idx i=0
local -a arr_ns_iflist RULEBLOCK_BUILTIN_LAN_DNS_SERVERS_ALLOW RULEBLOCK_BUILTIN_LAN_DNS_SERVERS_JUMPS
local str_netname str_net_addr str_intNS str_intNSmac str_nsiface str_isp_nslist str_ext_net str_ext_if
local str_ns str_loc_net_list str_isp_net_list str_isp_ns_list str_set_list str_loc_ns_list
local TEMPLATE_BUILTIN_LAN_DNS_SERVERS_ALLOW=(
"table=filter"
"target[0]=ACCEPT"
"chain[0]=$BIC_NAMESERVER_CHAIN"
"option_list_0[0]=idev"
"option_list_0[1]=odev"
"option_list_0[2]=src"
"option_list_0[3]=mac"
"option_list_0[4]=dst"
"option_list_0[5]=state"
)
local TEMPLATE_BUILTIN_LAN_DNS_SERVERS_JUMPS=(
"table=filter"
"target[0]=$BIC_NAMESERVER_CHAIN"
"chain[0]=FORWARD"
"reverse_mode=reverse"
"reverse_condition=REVERSE_FOWARD_RULES_REQUIRED:0"
"option_list_0[0]=idev"
"option_list_0[1]=odev"
"option_list_1[0]=odev"
"option_list_1[1]=idev"
"always_use_0[0]=proto=udp,tcp"
"always_use_0[1]=dport=53"
"always_use_1[0]=proto=udp,tcp"
"always_use_1[1]=sport=53"
)

log -I "Allowing LAN DNS server to ISP nameserver traffic"
if ((USE_IPSET)); then
	TEMPLATE_BUILTIN_LAN_DNS_SERVERS_ALLOW[5]="option_list_0[2]=m_set"
	TEMPLATE_BUILTIN_LAN_DNS_SERVERS_ALLOW[7]="option_list_0[4]=m_set"
else
	if ((REVERSE_FOWARD_RULES_REQUIRED == 1)); then
		RULEBLOCK_BUILTIN_LAN_DNS_SERVERS_ALLOW[i++]="$RULE_SEP $RULE_SEP $RULE_SEP $RULE_SEP $RULE_SEP ESTABLISHED"
	fi
fi
for ns_idx in ${!LAN_NS[@]}; do # for every entry in the LAN_NS array do...
	set -- ${LAN_NS[ns_idx]}
	strERR="LAN_NS $ns_idx ${LAN_NS[ns_idx]}" pass_idx=0
	[[ $2 ]] || { cfg_err $strERR; continue; }
	str_netname=$1 str_intNS=$2 str_intNSmac=$3
	[[ $str_intNSmac ]] || str_intNSmac="$RULE_SEP" # is mac address specified?
	str_nsiface=$(get_net_iface "$str_netname") # retrieve interface for network of nameserver
	str_net_addr=$(get_net_addr "$str_netname") # retrieve network address
	[[ $str_nsiface  && $str_net_addr ]] || {
		log -d "$str_netname"
		raise_gen_err_count
		continue
	}
	if ((USE_IPSET)); then
		if [[ $str_intNSmac != $RULE_SEP ]]; then # if a mac address is used create set of type that includs mac
			if ! lsearch "${str_netname}_MAC" $str_loc_net_list; then
				str_loc_net_list+="${str_netname}_MAC "
				if [[ $IPSET_SYNTAX = old ]]; then
					ipset_create "NAMESERVERS_${str_netname}_MAC" "macipmap" network "$str_net_addr" || continue
				else
					ipset_create "NAMESERVERS_${str_netname}_MAC" "bitmap:ip,mac" range "$str_net_addr" || continue
				fi
			fi
			if ! lsearch "NAMESERVERS_${str_netname}_MAC" $str_set_list; then
				str_set_list+="NAMESERVERS_${str_netname}_MAC " # remember created sets
			fi
		elif ! lsearch "$str_netname" $str_loc_net_list; then # otherwise only ip type of set
			str_loc_net_list+="$str_netname "
			if [[ $IPSET_SYNTAX = old ]]; then
				ipset_create "NAMESERVERS_$str_netname" "iphash" || continue
			else
				ipset_create "NAMESERVERS_$str_netname" "hash:ip" || continue
			fi
			if ! lsearch "NAMESERVERS_$str_netname" $str_set_list; then
				str_set_list+="NAMESERVERS_$str_netname " # remember created sets
			fi
		fi
		if ! lsearch "$str_netname:$str_intNS" $str_loc_ns_list; then # don't add dupes
			str_loc_ns_list+="$str_netname:$str_intNS "
			if [[ $str_intNSmac != $RULE_SEP ]]; then
				ipset_add "NAMESERVERS_${str_netname}_MAC" "$str_intNS,$str_intNSmac"
			else
				ipset_add "NAMESERVERS_$str_netname" "$str_intNS"
			fi
		fi
	fi
	for isp_idx in ${!ISP_NS[@]}; do # cycle through isp nameserver array
		set -- ${ISP_NS[isp_idx]}
		[[ $1 != $str_netname ]] && continue # get requested subnet
		str_isp_nslist=${2//,/ } str_ext_net=$3
		[[ $str_ext_net ]] && { # retrieve external interface for external network
			str_ext_if=$(get_net_iface $str_ext_net)
			[[ $str_ext_if ]] || {
				log -d "$str_ext_net"
				cfg_err $strERR
				continue
			}
		}
		if ! lsearch "$str_netname" $str_isp_net_list; then
			str_isp_net_list+="$str_netname "
			if ((USE_IPSET)); then
				if [[ $IPSET_SYNTAX = old ]]; then
					ipset_create "ISP_NAMESERVERS_$str_netname" "iphash" || continue
				else
					ipset_create "ISP_NAMESERVERS_$str_netname" "hash:ip" || continue
				fi
				RULEBLOCK_BUILTIN_LAN_DNS_SERVERS_ALLOW[i++]="$str_nsiface $RULE_SEP SETLIST_NAMESERVERS:src,src $RULE_SEP ISP_NAMESERVERS_$str_netname:dst NEW,ESTABLISHED"
				if ((REVERSE_FOWARD_RULES_REQUIRED == 1)); then
					RULEBLOCK_BUILTIN_LAN_DNS_SERVERS_ALLOW[i++]="$RULE_SEP $str_nsiface ISP_NAMESERVERS_$str_netname:src $RULE_SEP SETLIST_NAMESERVERS:dst,dst ESTABLISHED"
				fi
			fi
		fi
		for str_ns in $str_isp_nslist; do # handle ISP nameservers
			[[ $str_ext_net ]] || {
				str_ext_if=$(get_route_iface $str_ns) # no external interface specified
				[[ $str_ext_if ]] || {
					log -E "Unable to retrieve interface to route $str_ns over."
					raise_gen_err_count
					continue
				}
			}
			[[ $str_nsiface != $str_ext_if ]] || {
				log -E "DNS input and output interfaces are the same."
				cfg_err $strERR
				continue
			}
			if ((USE_IPSET)); then
				if ! lsearch $str_netname:$str_ns $str_isp_ns_list; then # don't add dupes
					str_isp_ns_list+="$str_netname:$str_ns "
					ipset_add "ISP_NAMESERVERS_$str_netname" "$str_ns"
				fi
			else
				RULEBLOCK_BUILTIN_LAN_DNS_SERVERS_ALLOW[i++]="$str_nsiface $str_ext_if $str_intNS $str_intNSmac $str_ns NEW,ESTABLISHED"
			fi
			lsearch "${str_nsiface}_to_$str_ext_if" "${arr_ns_iflist[@]}" || arr_ns_iflist[${#arr_ns_iflist[@]}]="${str_nsiface}_to_$str_ext_if"
		done
	done
done
if ((${#arr_ns_iflist[@]} > 0 && ${#RULEBLOCK_BUILTIN_LAN_DNS_SERVERS_ALLOW[@]} > 1)); then
	((USE_IPSET == 0 && REVERSE_FOWARD_RULES_REQUIRED == 0)) && unset RULEBLOCK_BUILTIN_LAN_DNS_SERVERS_ALLOW[0]
	for ns_idx in ${!arr_ns_iflist[@]}; do
		RULEBLOCK_BUILTIN_LAN_DNS_SERVERS_JUMPS[${#RULEBLOCK_BUILTIN_LAN_DNS_SERVERS_JUMPS[@]}]="${arr_ns_iflist[ns_idx]/_to_/ }"
	done
	if ((USE_IPSET)); then # create the setlist late, because of mergin other sets are not available before
		if [[ $IPSET_SYNTAX = old ]]; then
			ipset_create "SETLIST_NAMESERVERS" "setlist" || return 0
		else
			ipset_create "SETLIST_NAMESERVERS" "list:set" || return 0
		fi
		for str_ns in $str_set_list; do
				ipset_add SETLIST_NAMESERVERS "$str_ns"
		done
	fi
	create_chain filter $BIC_NAMESERVER_CHAIN # create the chain to put the nameserver rules into
	process_ipt_ruleblock TEMPLATE_BUILTIN_LAN_DNS_SERVERS_ALLOW RULEBLOCK_BUILTIN_LAN_DNS_SERVERS_ALLOW
	process_ipt_ruleblock TEMPLATE_BUILTIN_LAN_DNS_SERVERS_JUMPS RULEBLOCK_BUILTIN_LAN_DNS_SERVERS_JUMPS
else
	log -W "No LAN to ISP nameserver rules have been collected"
fi
} # -------------------------------------------------------------------------

lan_ftp() { # handle LAN(s) to Internet FTP traffic
((ENABLE_FILTER)) || return 0
[[ ${LAN_FTP} ]] || {
	log -w "Not applying LAN ftp rules"
	return 0
}
local -i idx
local TEMPLATE_BUILTIN_FWD_FTP_ALLOW=(
"table=filter"
"chain[0]=FORWARD"
"target[0]=ACCEPT"
"option_list_0[0]=idev"
"option_list_0[1]=odev"
"option_list_0[2]=src"
"option_list_0[3]=dst"
"option_list_0[4]=proto"
"option_list_0[5]=sport"
"option_list_0[6]=dport"
"option_list_0[7]=state"
"option_list_0[8]=helper"
)
local -a RULEBLOCK_BUILTIN_FWD_FTP_ALLOW
local oIFS="$IFS"
for rvar in ${LAN_FTP}; do
	local IFS=":"
	set -- $rvar
	local str_in="$1" str_out="$2" str_ftpmode="${3:-all}"
	local IFS="${oIFS}"
	if [[ -z ${str_out} ]]; then
		if [[ ${DEF_ROUTE_IF} ]]; then
			str_odev=${DEF_ROUTE_IF}
		else
			log -E "No external interface specified with \`$rvar' and no default route is set"
			raise_cfg_err_count
			continue
		fi
	else
		if lsearch "${str_out}" ${NET_IFLIST}; then
			str_odev="${str_out}"
		elif lsearch "${str_out}" ${NET_NAME_LIST}; then
			str_odev=$(get_net_iface "${str_out}")
			[[ ${str_odev} ]] || {
				log -d "${str_out}"
				raise_gen_err_count
				continue
			}
		else
			log -E "Unable to find a matching interface or netname for \`${str_out}' in \`$rvar'."
			raise_cfg_err_count
			continue
		fi
	fi
	if lsearch "${str_in}" ${NET_IFLIST}; then
		str_iface="${str_in}" str_net_addr="${RULE_SEP}"
	elif lsearch "${str_in}" ${NET_NAME_LIST}; then
		str_iface=$(get_net_iface "${str_in}") str_net_addr=$(get_net_addr "${str_in}")
		[[ ${str_iface} && ${str_net_addr} ]] || {
			log -E "Unable to retrieve data for network \`${str_in}'"
			raise_gen_err_count
			continue
		}
	else
		log -E "Unable to find a matching interface or netname for \`${str_in}' in \`$rvar'."
		raise_cfg_err_count
		continue
	fi
	[[ ${str_iface} != ${str_odev} ]] || {
		log -E "FTP input and output interfaces are the same in \`$rvar'."
		raise_cfg_err_count
		continue
	}
	str_ftpmode=$(string_tolower "${str_ftpmode}")
	[[ ${str_ftpmode} = @(all|active|passive|none) ]] || {
		log -i "${str_ftpmode}" "FTP mode descriptor"
		raise_cfg_err_count
		continue
	}
	idx=0
	RULEBLOCK_BUILTIN_FWD_FTP_ALLOW=()
	log -I "Allowing FTP from ${str_in} over ${str_out:-${str_odev}}"
	RULEBLOCK_BUILTIN_FWD_FTP_ALLOW[idx++]="${str_iface} ${str_odev} ${str_net_addr} $RULE_SEP tcp $UNPRIV_PORTS 21 ${stNE}"
	if ((REVERSE_FOWARD_RULES_REQUIRED == 1)); then
		RULEBLOCK_BUILTIN_FWD_FTP_ALLOW[idx++]="${str_odev} ${str_iface} $RULE_SEP ${str_net_addr} tcp 21 $UNPRIV_PORTS ${stE}"
	fi
	case "${str_ftpmode}" in
		all) log -N "Allowing active and passive mode FTP on: \`${str_in}'"
			RULEBLOCK_BUILTIN_FWD_FTP_ALLOW[idx++]="${str_iface} ${str_odev} ${str_net_addr} $RULE_SEP $RULE_SEP $RULE_SEP $RULE_SEP $RULE_SEP ftp"
			if ((REVERSE_FOWARD_RULES_REQUIRED == 1)); then
				RULEBLOCK_BUILTIN_FWD_FTP_ALLOW[idx++]="${str_odev} ${str_iface} $RULE_SEP ${str_net_addr} $RULE_SEP $RULE_SEP $RULE_SEP $RULE_SEP ftp"
			fi
		;;
		active) log -N "Allowing active mode FTP on: \`${str_in}'"
			RULEBLOCK_BUILTIN_FWD_FTP_ALLOW[idx++]="${str_odev} ${str_iface} $RULE_SEP ${str_net_addr} tcp 20 $UNPRIV_PORTS ${stER} ftp"
			if ((REVERSE_FOWARD_RULES_REQUIRED == 1)); then
				RULEBLOCK_BUILTIN_FWD_FTP_ALLOW[idx++]="${str_iface} ${str_odev} ${str_net_addr} $RULE_SEP tcp $UNPRIV_PORTS 20 ${stE} ftp"
			fi
		;;
		passive) log -N "Allowing passive mode FTP on: \`${str_in}'"
			RULEBLOCK_BUILTIN_FWD_FTP_ALLOW[idx++]="${str_iface} ${str_odev} ${str_net_addr} $RULE_SEP tcp $UNPRIV_PORTS $UNPRIV_PORTS ${stER} ftp"
			if ((REVERSE_FOWARD_RULES_REQUIRED == 1)); then
				RULEBLOCK_BUILTIN_FWD_FTP_ALLOW[idx++]="${str_odev} ${str_iface} $RULE_SEP ${str_net_addr} tcp $UNPRIV_PORTS $UNPRIV_PORTS ${stE} ftp"
			fi
		;;
	esac
	process_ipt_ruleblock TEMPLATE_BUILTIN_FWD_FTP_ALLOW RULEBLOCK_BUILTIN_FWD_FTP_ALLOW
done
} # -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# VPN
# -------------------------------------------------------------------------

vpn_all_branch_allow() { # ALLOW ALL Branch to Branch traffic
((ALLOW_ALL_BRANCH)) || {
	log -w "Not applying all branch allow rules"
	return 0
}
local -i idx
local strERR local_vpn_branch local_vpn_extIP local_vpn_subnet local_vpn_intIP
local branch extIP subnet intIP remote_branches src_extIP src_subnet src_intIP
local rbranch src_extIP other_branches rb rb_extIP rb_subnet rb_intIP
local TEMPLATE_BUILTIN_VPN_ALLOW_ALL_BRANCH=(
"table=filter"
"template_msg='Permitting ALL VPN BRANCH traffic'"
"target[0]=ACCEPT"
"chain[0]=${ipsec_chain}"
"reverse_mode=reverse"
"option_list_0[0]=src"
"option_list_0[1]=dst"
"option_list_1[0]=dst"
"option_list_1[1]=src"
)
local -a RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH
# get local data
((${#VPN_MAP[@]})) || {
	log -r 'VPN_MAP'
	raise_cfg_err_count
	return 0
}
# at least 2 entries needed
((${#VPN_MAP[@]} >= 2)) || {
	log -N "Only one vpn entry found. NO rules to apply"
	return 0
}
# check for unique branch names
check_str_unique $(show_array_column 'VPN_MAP') || {
	log -E "Duplicate branch name in \`VPN_MAP'."
	raise_cfg_err_count
	return 0
}
for idx in ${!VPN_MAP[@]}; do # find local branch
	set -- ${VPN_MAP[idx]}
	(($# < 4)) && {
		log -E "Entry missing in \`VPN_MAP'."
		cfg_err VPN_MAP ${idx} ${VPN_MAP[idx]}
		return 0
	}
	[[ $1 != ${LOCAL_BRANCH} ]] && continue
	local_vpn_branch=$1 local_vpn_extIP=$2 local_vpn_subnet=$3 local_vpn_intIP=$4
	break
done
if [[ -z ${local_vpn_branch} ]]; then
	log -E "Unable to find Local Branch in VPN_MAP"
	raise_cfg_err_count
	return 0
fi
for idx in ${!VPN_MAP[@]}; do # local to remote branches
	set -- ${VPN_MAP[idx]}
	branch=$1 extIP=$2 subnet=$3 intIP=$4
	[[ ${branch} = ${local_vpn_branch} ]] && continue # not apply to itself
	remote_branches+=" ${branch}" # collect remote branch names
	RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH[${#RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH[@]}]="$local_vpn_extIP $extIP"
	RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH[${#RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH[@]}]="$local_vpn_extIP $subnet"
	RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH[${#RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH[@]}]="$local_vpn_subnet $extIP"
	RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH[${#RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH[@]}]="$local_vpn_subnet $subnet"
done
for rbranch in ${remote_branches}; do # remote to remote branches
	for idx in ${!VPN_MAP[@]}; do # collect data about current branch
		set -- ${VPN_MAP[idx]}
		[[ $1 != ${rbranch} ]] && continue # not a remote branch
		branch=$1 src_extIP=$2 src_subnet=$3 src_intIP=$4
		break
	done
	other_branches="${remote_branches/${branch}/}" # set other branches
	# iterate through the other branches and apply rules to/from current branch
	for rb in ${other_branches}; do
		for idx in ${!VPN_MAP[@]}; do # get branch data
			set -- ${VPN_MAP[idx]}
			[[ $1 != ${rb} ]] && continue
			branch=$1 rb_extIP=$2 rb_subnet=$3 rb_intIP=$4
			break # this is the right remote branch
		done
		RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH[${#RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH[@]}]="$src_extIP $rb_extIP"
		RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH[${#RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH[@]}]="$src_subnet $rb_subnet"
		RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH[${#RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH[@]}]="$src_extIP $rb_subnet"
	done
done
process_ipt_ruleblock TEMPLATE_BUILTIN_VPN_ALLOW_ALL_BRANCH RULEBLOCK_BUILTIN_VPN_ALLOW_ALL_BRANCH
} # -------------------------------------------------------------------------

enable_ipsec() { # enable VPN settings
((ENABLE_FILTER)) || return 0
((ENABLE_IPSEC)) || {
	log -w "Not applying IPSEC rules"
	return 0
}
local str_iface_ip
local TEMPLATE_BUILTIN_IPSEC_JUMPS=(
"table=filter"
"target[0]=${ipsec_chain}"
"reverse_mode=reverse"
"template_msg='Sending ipsec related packets to ipsec chain'"
"option_list_0[0]=chain"
"option_list_0[1]=idev"
"option_list_0[2]=odev"
"option_list_0[3]=src"
"option_list_0[4]=dst"
"option_list_0[5]=proto"
"option_list_0[6]=sport"
"option_list_0[7]=dport"
"option_list_1[0]=chain"
"option_list_1[1]=odev"
"option_list_1[2]=idev"
"option_list_1[3]=dst"
"option_list_1[4]=src"
"option_list_1[5]=proto"
"option_list_1[6]=dport"
"option_list_1[7]=sport"
)
local -a RULEBLOCK_BUILTIN_IPSEC_JUMPS
log -S "${ADDMSG} VPN rules"
create_chain filter "${ipsec_chain}"
if [[ ${IPSEC_RULES} ]]; then
	for rvar in ${IPSEC_RULES}; do
		load_rule_file "$rvar" || return 0
	done
else
	log -v 'IPSEC_RULES'
fi

vpn_all_branch_allow

#NO_IFACE_CHECK=1
# Seed out all the ipsec related packets and push them into the ipsec chain
for rvar in ${IPSEC_IFLIST}; do
	while read str_iface_ip; do
		RULEBLOCK_BUILTIN_IPSEC_JUMPS[${#RULEBLOCK_BUILTIN_IPSEC_JUMPS[@]}]="OUTPUT,INPUT $RULE_SEP $rvar $str_iface_ip $RULE_SEP udp 500 500"
		RULEBLOCK_BUILTIN_IPSEC_JUMPS[${#RULEBLOCK_BUILTIN_IPSEC_JUMPS[@]}]="OUTPUT,INPUT $RULE_SEP $rvar $str_iface_ip $RULE_SEP 50"
	done < <(get_if_ipv4_data "$rvar" -i)
done
for rvar in ${IPSEC_INTERFACES}; do
	RULEBLOCK_BUILTIN_IPSEC_JUMPS[${#RULEBLOCK_BUILTIN_IPSEC_JUMPS[@]}]="INPUT,OUTPUT $rvar"
	if ((PROC_IP_FORWARD == 1)); then
		RULEBLOCK_BUILTIN_IPSEC_JUMPS[${#RULEBLOCK_BUILTIN_IPSEC_JUMPS[@]}]="FORWARD $rvar"
	fi
done
process_ipt_ruleblock TEMPLATE_BUILTIN_IPSEC_JUMPS RULEBLOCK_BUILTIN_IPSEC_JUMPS
#NO_IFACE_CHECK=0
} # -------------------------------------------------------------------------

# -------------------------------------------------------------------------
state_allow_chains() {
((ENABLE_FILTER)) || return 0
[[ $KNOWN_TRAFFIC_MAP ]] || {
	log -w "Not applying known traffic rules"
	return 0
}
local -i idx
if ((USE_M_CONNTRACK == 1)); then
	str_state_arg="-m conntrack --ctstate"
else
	str_state_arg="-m state --state"
fi
log -I "Allowing established/related traffic in certain chains"
for idx in ${!KNOWN_TRAFFIC_MAP[@]}; do
	set -- ${KNOWN_TRAFFIC_MAP[idx]}
	local str_chain="$1" str_state="$2" str_place="$3"
	if [[ $str_state && $str_state != $RULE_SEP ]]; then
		case "$str_state" in
			e|E) local str_state_cmd="$str_state_arg ESTABLISHED" str_state=ESTABLISHED ;;
			r|R) local str_state_cmd="$str_state_arg RELATED" str_state=RELATED ;;
			er|ER) local str_state_cmd="$str_state_arg ESTABLISHED,RELATED" str_state=ESTABLISHED,RELATED ;;
			*) log -E "Invalid value \`$str_state' for state descriptor in variable \`KNOWN_TRAFFIC_MAP'."
				raise_cfg_err_count
				continue
		esac
	else
		local str_state=ESTABLISHED,RELATED str_state_cmd="$str_state_arg ESTABLISHED,RELATED"
	fi
	if [[ $str_place && $str_place != $RULE_SEP ]]; then
		local str_place=$(string_tolower "$str_place")
		[[ $str_place = @(top|bottom) ]] || {
			log -E "Invalid value \`$str_place' for rule placement descriptor in variable \`KNOWN_TRAFFIC_MAP'."
			raise_cfg_err_count
			continue
		}
	else
		local str_place=top
	fi
	case "$str_place" in
		bottom) local str_add='add_rule' ;;
		top) local str_add='insert_ipt_rule' ;;
	esac
	log -e "${PF}accept table=filter chain=$str_chain state=$str_state placement=$str_place"
	$str_add filter "$str_chain" $str_state_cmd -j ACCEPT
done
} # -------------------------------------------------------------------------

apply_final_rule() {
((ENABLE_FILTER)) || return 0
((${#FINAL_RULE_MAP[@]})) || {
	log -w "Not applying final rules"
	return 0
}
local -i idx jt_mode=${JUMP_TREE[0]}
local str_tmp_act
local TEMPLATE_BUILTIN_FINAL_RULE=(
"table=filter"
"option_list_0[0]=target"
"option_list_0[1]=chain"
"option_list_0[2]=limit"
"option_list_0[3]=limit_burst"
"option_list_0[4]=log_level"
"option_list_0[5]=log_prefix"
"option_list_0[6]=log_options"
"template_msg='Creating final rule entries'"
)
local -a RULEBLOCK_BUILTIN_FINAL_RULE
for idx in ${!FINAL_RULE_MAP[@]}; do
	set -- ${FINAL_RULE_MAP[idx]}
	local str_chain="$1" str_action="$2" str_limit="${3:-${GLOBAL_LOGLIMIT}}" str_burst="${4:-${GLOBAL_BURSTLIMIT}}" \
		str_loglevel="${5:-${GLOBAL_LOGLEVL}}" str_log_options="${6}" str_pol=""
	if [[ ${str_chain} = @(INPUT|OUTPUT|FORWARD) ]]; then
			str_pol="$(get_policy filter ${str_chain})_" || return
	fi
	case "${str_action}" in
		log)
			RULEBLOCK_BUILTIN_FINAL_RULE[${#RULEBLOCK_BUILTIN_FINAL_RULE[@]}]="LOG ${str_chain} ${str_limit} ${str_burst} ${str_loglevel} ${LOG_PREFIX}${str_pol}${str_chain}: ${str_log_options}"
			
		;;
		drop|reject)
			RULEBLOCK_BUILTIN_FINAL_RULE[${#RULEBLOCK_BUILTIN_FINAL_RULE[@]}]="$(string_toupper ${str_action}) ${str_chain}"
		;;
		logdrop|logreject)
			str_tmp_act=$(string_toupper ${str_action/log/})
			RULEBLOCK_BUILTIN_FINAL_RULE[${#RULEBLOCK_BUILTIN_FINAL_RULE[@]}]="LOG ${str_chain} ${str_limit} ${str_burst} ${str_loglevel} ${LOG_PREFIX}${str_tmp_act}_${str_chain}: ${str_log_options}"
			if [[ ${str_action} = logdrop && ${str_pol} = DROP_ ]]; then
				log -N "Policy for ${str_chain} already is set to DROP, not applying additional final drop rule."
			else
				RULEBLOCK_BUILTIN_FINAL_RULE[${#RULEBLOCK_BUILTIN_FINAL_RULE[@]}]="${str_tmp_act} ${str_chain}"
			fi
		;;
		*) log -E "Invalid value for final action: \`${str_action}'."
			raise_cfg_err_count
			continue
	esac
done
((jt_mode == 1)) && jump_tree_off
process_ipt_ruleblock TEMPLATE_BUILTIN_FINAL_RULE RULEBLOCK_BUILTIN_FINAL_RULE
((jt_mode == 0)) || jump_tree_on
} # -------------------------------------------------------------------------

# compute multiple rules, if a multiple option type was provided
# as comma separated input in the rule.
#_multiply_rules()
#{
#[[ ${5} ]] || { reqparm $FUNCNAME 5; return 1; }
#local rule_array
#local -a tmp_multi_type_array
#local -i multi_type_idx=0
## the amount of targets determinates the rule count
#local -i rule_count_before=${#RULELIST_TARGET[@]}
#local -i rule_count=$((${#RULELIST_TARGET[@]}-1))
#local -i rule_idx rule_count_after new_rule_count range_idx
#
#local str_multi_types="${1}"		# the multi option type string
#local str_rulelist_array="$2"		# the according rulelist array name(s)
#local str_msg_list_array="$3"		# the according msg_list array name(s)
#local str_cmd_arg="$4"			# the according command argument
#local str_msg_arg="$5"			# the according log message
#
## load the multi types into an array
#read -a tmp_multi_type_array < <(echo ${str_multi_types//,/ })
## the amount of rules after multiplication
#rule_count_after=$((${rule_count_before} * ${#tmp_multi_type_array[@]}))
## for every rulelist and msg_list array, check if it contains data.
## if yes, duplicate the entries
#for rule_array in ${RULELIST_ARRAYS}; do
#	if [ $(arr_members_sum ${rule_array}) -gt 0 ]; then
#		new_rule_count=${rule_count_before}
#		for multi_type_idx in $(seq 1 $((${#tmp_multi_type_array[@]}-1))); do
#			for rule_idx in $(seq 0 ${rule_count}); do
#				eval ${rule_array}[new_rule_count++]=\"\${${rule_array}[rule_idx]}\"
#			done
#		done
#	fi
#done
#
#multi_type_idx=0
#local tmp_str_rulelist_array tmp_str_msg_list_array tmp_str_cmd_arg tmp_str_msg_arg
#local -i rev_idx=0
#
## now place the multi types into the according type rulelist and msg_list array
#for rule_idx in $(seq 0 ${rule_count_before} $((${rule_count_after}-1))); do
#	for range_idx in $(seq ${rule_idx} $((rule_idx + ${rule_count}))); do
#		tmp_str_rulelist_array="${str_rulelist_array%,*}"
#		tmp_str_msg_list_array="${str_msg_list_array%,*}"
#		tmp_str_cmd_arg="${str_cmd_arg%,*}"
#		tmp_str_msg_arg="${str_msg_arg%,*}"
#		if [ ${reverse_rule} -eq 1 ]; then # this is a rule to reverse
#			if [ ${rev_idx} -eq 0 ]; then # first pass
#				rev_idx=1
#			else # second pass
#				# reverse option data
#				tmp_str_rulelist_array="${str_rulelist_array#*,}"
#				tmp_str_msg_list_array="${str_msg_list_array#*,}"
#				tmp_str_cmd_arg="${str_cmd_arg#*,}"
#				tmp_str_msg_arg="${str_msg_arg#*,}"
#				rev_idx=0
#			fi
#		fi
#		if (eval [ \"\${${tmp_str_rulelist_array}[rule_idx]}\" ]); then
#			eval ${tmp_str_rulelist_array}[range_idx]=\"${tmp_str_cmd_arg} ${tmp_multi_type_array[multi_type_idx]/!/! } \"
#			eval ${tmp_str_msg_list_array}[range_idx]=\"${tmp_str_msg_arg}=${tmp_multi_type_array[multi_type_idx]} \"
#		fi
#	done
#	((multi_type_idx++))
#done
#return 0
#}
# -------------------------------------------------------------------------

# remove a rule from the rulelist and msg_list arrays.
# This is needed, when a sanity check fails, but previously successfully
# checked values may already be written into the according arrays.
#_remove_rule()
#{
#local array_name
#for array_name in ${RULELIST_ARRAYS}; do
#	unset ${array_name}[RULE_LIST_IDX]
#done
#}
# -------------------------------------------------------------------------

