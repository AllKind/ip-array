#!/bin/bash

#-------------------------------------------------------------------------------
# IP-ARRAY MAIN CONFIGURATION FILE
#-------------------------------------------------------------------------------

#---------------------------------------
# CONFIGURATION FILES
#---------------------------------------

# List of configuration files to load.
# This is the only variable that must be in this file. All other can be
# outsourced to different files, as long as their names are put here.
CONFIG_FILES="aliases.conf global.conf"

# Names of the base template files
BASE_TEMPLATES="base_templates.xml global_templates.xml"

#---------------------------------------
# FILTER table
#---------------------------------------

# Disable / Enable filter table rules | Format: 0/1
ENABLE_FILTER=0

# FILTER rules file
IPT_FILTER_TEMPLATES="filter_base_templates.xml filter_ipsec_templates.xml filter_templates.xml"
FILTER_RULEBLOCKS="filter_ruleblocks.xml filter_ipsec_ruleblocks.xml"
FILTER_RULES="filter_rules.xml"

#---------------------------------------
# MANGLE table
#---------------------------------------

# Disable / Enable mangle table rules | Format: 0/1
ENABLE_MANGLE=0

# MANGLE rules file
IPT_MANGLE_TEMPLATES="mangle_base_templates.xml mangle_templates.xml"
MANGLE_RULEBLOCKS="mangle_ruleblocks.xml"
MANGLE_RULES="mangle_rules.xml"

#---------------------------------------
# NAT table
#---------------------------------------

# Disable / Enable nat table rules | Format: 0/1
ENABLE_NAT=0

# NAT rules file
IPT_NAT_TEMPLATES="nat_base_templates.xml nat_templates.xml"
NAT_RULEBLOCKS="nat_ruleblocks.xml"
NAT_RULES="nat_rules.xml"

#---------------------------------------
# RAW table
#---------------------------------------

# Disable / Enable raw table rules | Format: 0/1
ENABLE_RAW=0

# RAW rules file
IPT_RAW_TEMPLATES="raw_base_templates.xml raw_templates.xml"
RAW_RULEBLOCKS="raw_ruleblocks.xml"
RAW_RULES="raw_rules.xml"

#---------------------------------------
# RAWPOST table
#---------------------------------------

# Disable / Enable rawpost table rules | Format: 0/1
#ENABLE_RAWPOST=0

# RAWPOST rules file
#IPT_RAWPOST_TEMPLATES="rawpost_base_templates.xml rawpost_templates.xml"
#RAWPOST_RULEBLOCKS="rawpost_ruleblocks.xml"
#RAWPOST_RULES="rawpost_rules.xml"

#---------------------------------------
# SECURITY table
#---------------------------------------

# Disable / Enable security table rules | Format: 0/1
ENABLE_SECURITY=0

# SECURITY rules file
IPT_SECURITY_TEMPLATES="security_base_templates.xml security_templates.xml"
SECURITY_RULEBLOCKS="security_ruleblocks.xml"
SECURITY_RULES="security_rules.xml"

#---------------------------------------
# IPSET
#---------------------------------------

# ipset rules will not be loaded for tc-start, save-shaping-commands
IPSET_RULES="ipset_rules.xml"

#---------------------------------------
# KERNEL MODULES
#---------------------------------------

# Modules directory
#MODULE_DIR="/lib/modules/$("$UNAME" -r)"

# Modules to load
# Format (IFS=newline): module-name [parameters]
MODULES_TO_LOAD='
'

# Modules to remove
MODS_TO_RM='
'

#---------------------------------------
# INTERFACES
#---------------------------------------

# Loopback Interface - defaults to `lo' if unset
#LOOPBACK_IF="lo"

# List of all network interfaces (not lo)
# newline separates entries
# Format: iface-name | iface-alias | ext/local/ipsec | network-name
NET_INTERFACES="
"

#---------------------------------------
# PROLOG and EPILOG scripts
#---------------------------------------

# Format:
# startup-parameter[,...] {prolog|epilog} script-name {prolog|epilog} script-name
# newline separates entries
# i.e. start,stop prolog my_prolog_script epilog my_epilog_script
SCRIPT_MAP="
"

#---------------------------------------
# GLOBAL POLICY MAP
#---------------------------------------

# Format: table chain policy
POLICY_MAP="
filter INPUT DROP
filter OUTPUT DROP
filter FORWARD DROP
nat OUTPUT ACCEPT
nat PREROUTING ACCEPT
nat POSTROUTING ACCEPT
mangle INPUT ACCEPT
mangle OUTPUT ACCEPT
mangle FORWARD ACCEPT
mangle PREROUTING ACCEPT
mangle POSTROUTING ACCEPT
raw PREROUTING ACCEPT
raw OUTPUT ACCEPT
#rawpost POSTROUTING ACCEPT
security INPUT ACCEPT
security OUTPUT ACCEPT
security FORWARD ACCEPT
"

#---------------------------------------
# LOOPBACK
#---------------------------------------

# Allow loopback communiction (packets leaving/entering the loopback interface)
# Format: 0/1
ALLOW_LOOPBACK=1


#---------------------------------------
# Administrator remote connection
#---------------------------------------

# Format: admin_source-address local_destination-address local_destination-port
ADMIN_CONNECTION=""


#---------------------------------------
# CHAINS
#---------------------------------------

# Chains to create
# Format: table chain-name [...]
CHAIN_MAP="
"

# Automated jump tree creation
# Format: { none | interface | netname | netname+interface } { table [...] | all }
JUMP_TREE="none"

# Should all the jump tree chains created automatically
JUMP_TREE_CHAINS_CREATE_ALL=0

# After applying the ruleset should empty chains be removed?
# Format: 0/1
REMOVE_EMPTY_CHAINS=0

# After applying the ruleset should unreferenced chains be removed?
# Format: 0/1
REMOVE_UNREF_CHAINS=0

#---------------------------------------
# KNOWN RETURN TRAFFIC (STATE)
#---------------------------------------

# chain | state: [E,R,ER] default: ER | [top,bottom] default: top
KNOWN_TRAFFIC_MAP="
"

# When templates with reverse traffic definitions are in use
# should the reverse (return) rules be generated.
# Format: 0/1
REVERSE_INPUT_RULES_REQUIRED=0
REVERSE_FOWARD_RULES_REQUIRED=0

#---------------------------------------
# CHAIN TERMINATION - FINAL RULE
#---------------------------------------

# chain | final-action | [ limit[:burst:value ]] | [ log-level ] | [ log-options ]
FINAL_RULE_MAP="
"

#---------------------------------------
# INVALID / ILLEGAL / FRAGMENTED  PACKETS
#---------------------------------------

# Log packets in invalid state | Format: 0/1
LOG_INVALID=0

# Drop packets in invalid state | Format: 0/1
BLOCK_INVALID=1

# Log illegal packets | Format: 0/1
LOG_ILLEGAL=0

# Drop illegal packets | Format: 0/1
BLOCK_ILLEGAL=1

#---------------------------------------
# LOCAL NETWORK MAPS
#---------------------------------------

# Select LAN interfaces from where FTP is permitted
# Format: lan-interface[:external-interface][:active|passive] [...]
# (i.e. "eth1:eth0:active eth2 eth3::passive")
LAN_FTP=""

# Automatically configure LAN nameserver to IPS nameserver(s) rules
# Internet Service Provider nameservers
# Format: subnet-name | nameserver-ip-address[,...] | [ external-net-name ]
ISP_NS="
"

# LAN nameservers
# Format: subnet-name | nameserver-IP | [ nameserver-MAC-addr ]
LAN_NS="
"

# Internet Service Provider SMTP servers
# Format: subnet-name | ip-address[,...] | [ external-net-name ]
ISP_SMTP="
"

#---------------------------------------
# OUTPUT CHAIN HANDLING
#---------------------------------------

# Restrict or open OUTPUT chain | Format: 0 / 1 / IFBOUND / IPBOUND
RESTRICT_OUTPUT="0"

# If RESTRICT_OUTPUT is '1' and the policy of the OUTPUT chain is DROP,
# allow output (external interface) to nameservers from 'LOCAL_NS' (use /etc/resolv.conf entries)
# Format: 0/1
REST_OUT_DNS_ALLOW=0

# Local nameservers (on the firewall itself)
# used to allow dns traffic if OUTPUT chain is restricted 'RESTRICT_OUTPUT=1'
# Format: auto (read from /etc/resolv.conf) or:
# nameserver ip-address[,...] | [ external-net-name ]
LOCAL_NS="
"

# If RESTRICT_OUTPUT is '1' and the policy of the OUTPUT chain is DROP,
# allow all OUTPUT (external interface) to TIMESERVERS from variable 'NTP_SERVERS'
# Format: 0/1
REST_OUT_NTP_ALLOW=0

# Timeservers
# used to allow ntp traffic if OUTPUT chain is restricted 'RESTRICT_OUTPUT=1'
# Format: auto (read from /etc/ntp.conf !only IP addresses are valid!) or:
# Format: timeserver-ip-address[,...] | [ external-net-name ]
TIME_SERVERS="
"

# If RESTRICT_OUTPUT is '1', allow all OUTPUT to LAN(s) attached to certain interfaces
# Format: lan-interface [...]
REST_OUT_LAN_ALLOW=""

# If RESTRICT_OUTPUT is IFBOUND or IPBOUND, allow only ESTABLISHED (0), or ESTABLISHED and RELATED (1) traffic
# Format: 0/1
REST_ALLOW_RELATED=0

#---------------------------------------
# DROP / REJECT SETTINGS
#---------------------------------------

# Block DHCP broadcasts to listed interfaces (keep from spamming logs)
# Format: interface [...]
DROP_DHCP=""

# Block (Microsoft) UPNP broadcasts to listed interfaces (keep from spamming logs)
# Format: interface [...]
DROP_UPNP=""

#---------------------------------------
# LOGGING
#---------------------------------------

# Log prefix
LOG_PREFIX="IPT_"

# Global Log Limit
GLOBAL_LOGLIMIT="1/s"

# Global Burst Limit
GLOBAL_BURSTLIMIT=3

# Global Log Level
GLOBAL_LOGLEVL="INFO"

#---------------------------------------
# VPN
#---------------------------------------

# Disable / Enable IPSEC rules | Format: 0/1
ENABLE_IPSEC=0

# Allow ALL Branch to Branch traffic | Format: 0/1
ALLOW_ALL_BRANCH=0

# IPSEC rules file
IPSEC_RULES="ipsec_rules.xml"

# Local VPN Branch name
LOCAL_BRANCH=""

# VPN MAP
# Format: name | external IP | LAN range | LAN iface IP
VPN_MAP="
"
#---------------------------------------
# TRAFFIC SHAPING
#---------------------------------------

# Disable / Enable traffic shaping | Format: 0/1
ENABLE_TC_SHAPING=0

# Packet marking rules for traffic shaping
TC_RULEBLOCKS="tc_ruleblocks.xml"
TC_MANGLE_RULEBLOCKS="tc_mangle_ruleblocks.xml"
TC_MARK_RULES="tc_mark.rule.xml"

# Output Bulk Mark
# Format: device:mark [...] (i.e. eth0:6)
OUTPUT_BULK=""

# Forward Bulk Mark
# Format: input-device,output-device:mark [...] (i.e. eth1,eth0:6)
FORWARD_BULK=""

# Priorize SYN packets
# Format: output-device:mark [...] (i.e. eth0:1 eth1:2)
PRIORITIZE_SYN=""

#---------------------------------------
# MISC SETTINGS
#---------------------------------------

# Exit on configuration and command apply errors
EXIT_ON_ERROR=1

# Rule placeholder character.
# Used as a placeholder for unused values in the rule configuration file.
# Valid values are: `_' `-' `.' `,' (defaults to `_')
#RULE_PLACEHOLDER='_'

# Always use the conntrack match extension instead of the state match
# Format: 0/1
USE_M_CONNTRACK=0

# nfacct map - Netfilter accounting objects
# Format: name ...
NFACCT_OBJ_MAP="
"

#-------------------------------------------------------------------------------
# SYSCTL SETTINGS
#-------------------------------------------------------------------------------

#---------------------------------------
#--- CERTAIN OR ALL INTERFACES
#---------------------------------------

#---------------------------------------
#--- NETWORK CONF/ SETTINGS
#
# Format: '0' / '1' or 'ethX:0' / 'ethX:1' or undefined
# i.e. '1', or 'eth0:1', or 'eth0:0 eth1:1 eth2:0'
#---------------------------------------

# Disable / Enable spoof protection
# rp_filter - INTEGER
# 0 - No source validation.
# 1 - Strict mode as defined in RFC3704 Strict Reverse Path
#     Each incoming packet is tested against the FIB and if the interface
#     is not the best reverse path the packet check will fail.
#     By default failed packets are discarded.
# 2 - Loose mode as defined in RFC3704 Loose Reverse Path
#     Each incoming packet's source address is also tested against the FIB
#     and if the source address is not reachable via any interface
#     the packet check will fail.
# Current recommended practice in RFC3704 is to enable strict mode
# to prevent IP spoofing from DDos attacks. If using asymmetric routing
# or other complicated routing, then loose mode is recommended.
# The max value from conf/{all,interface}/rp_filter is used
# when doing source validation on the {interface}.
# Default value is 0. Note that some distributions enable it in startup scripts.
PROC_RP_FILTER=1

# Disable / Enable ICMP-Redirects for all interfaces
# accept_redirects - BOOLEAN
# Accept ICMP redirect messages.
# accept_redirects for the interface will be enabled if:
# - both conf/{all,interface}/accept_redirects are TRUE in the case
#   forwarding for the interface is enabled or
# - at least one of conf/{all,interface}/accept_redirects is TRUE in the
# case forwarding for the interface is disabled
# accept_redirects for the interface will be disabled otherwise
# default TRUE (host)	FALSE (router)
PROC_ICMP_REDIRECTS=0

# Disable / Enable free route (source routed packets)
# accept_source_route - BOOLEAN
# Accept packets with SRR option.
# conf/all/accept_source_route must also be set to TRUE to accept packets
# with SRR option on the interface
# default TRUE (router)	FALSE (host)
#PROC_SOURCE_ROUTE=0

# Disable / Enable Logging of martians
# log_martians - BOOLEAN
# Log packets with impossible addresses to kernel log.
# log_martians for the interface will be enabled if at least one of
# conf/{all,interface}/log_martians is set to TRUE, it will be disabled otherwise
PROC_LOG_MARTIANS=""

# send_redirects - BOOLEAN Default: TRUE
# Send redirects, if router.
# send_redirects for the interface will be enabled if at least one of
# conf/{all,interface}/send_redirects is set to TRUE,
# it will be disabled otherwise
#PROC_SEND_REDIRECTS=0

# secure_redirects - BOOLEAN default TRUE
# Accept ICMP redirect messages only for gateways, listed in default gateway list.
# secure_redirects for the interface will be enabled if at least one of
# conf/{all,interface}/secure_redirects is set to TRUE, it will be disabled otherwise
#PROC_SECURE_REDIRECTS=0

# shared_media - BOOLEAN default TRUE
# Send(router) or accept(host) RFC1620 shared media redirects.
# Overrides ip_secure_redirects.
# shared_media for the interface will be enabled if at least one of
# conf/{all,interface}/shared_media is set to TRUE, it will be disabled otherwise
#PROC_SHARED_MEDIA=0

# proxy_arp - BOOLEAN
# Do proxy arp.
# proxy_arp for the interface will be enabled if at least one of
# conf/{all,interface}/proxy_arp is set to TRUE, it will be disabled otherwise
#PROC_PROXY_ARP=0

# mc_forwarding - BOOLEAN
# Do multicast routing. The kernel needs to be compiled with CONFIG_MROUTE
# and a multicast routing daemon is required.
# conf/all/mc_forwarding must also be set to TRUE to enable multicast
# routing for the interface
#PROC_MC_FORWARDING=0

# arp_filter - BOOLEAN
# 1 - Allows you to have multiple network interfaces on the same
# subnet, and have the ARPs for each interface be answered
# based on whether or not the kernel would route a packet from
# the ARP'd IP out that interface (therefore you must use source
# based routing for this to work). In other words it allows control
# of which cards (usually 1) will respond to an arp request.
# 0 - (default) The kernel can respond to arp requests with addresses
# from other interfaces. This may seem wrong but it usually makes
# sense, because it increases the chance of successful communication.
# IP addresses are owned by the complete host on Linux, not by
# particular interfaces. Only for more complex setups like load-
# balancing, does this behaviour cause problems.
# arp_filter for the interface will be enabled if at least one of
# conf/{all,interface}/arp_filter is set to TRUE, it will be disabled otherwise
#PROC_ARP_FILTER=0

#---------------------------------------
#--- GLOBAL SETTINGS
#---------------------------------------

#---------------------------------------
#--- IP SETTINGS
#---------------------------------------

# Disable / Enable IP DynAddr | Format: 0/1/2 or undefined Default: 0
# ip_dynaddr - BOOLEAN
# If set non-zero, enables support for dynamic addresses.
# If set to 2, a kernel log message will be printed when dynamic
# address rewriting occurs.
#PROC_IPDYNADDR=0

# Disable / Enable IP forwarding | Format: 0/1 or undefined
# ip_forward - BOOLEAN
# Forward Packets between interfaces.
# This variable is special, its change resets all configuration
# parameters to their default state (RFC1122 for hosts, RFC1812
# for routers)
PROC_IP_FORWARD=0

# ipfrag_time - INTEGER
# Time in seconds to keep an IP fragment in memory.
#PROC_IPFRAG_TIME=30

# ipfrag_high_thresh - INTEGER
# Maximum memory used to reassemble IP fragments. When
# ipfrag_high_thresh bytes of memory is allocated for this purpose,
# the fragment handler will toss packets until ipfrag_low_thresh
# is reached.
#PROC_IPFRAG_HIGH_THRESH=262144

# ipfrag_low_thresh - INTEGER
# See ipfrag_high_thresh
#PROC_IPFRAG_LOW_THRESH=196608

# ip_default_ttl - INTEGER Default: 64 (as recommended by RFC1700)
# Default value of TTL field (Time To Live) for outgoing (but not
# forwarded) IP packets. Should be between 1 and 255 inclusive.
#PROC_IP_DEFAULT_TTL=64

# ip_nonlocal_bind - BOOLEAN Default: 0
# If set, allows processes to bind() to non-local IP addresses,
# which can be quite useful - but may break some applications.
#PROC_IP_NONLOCAL_BIND=0

# ip_no_pmtu_disc - INTEGER Default: FALSE
# Disable Path MTU Discovery. If enabled in mode 1 and a
# fragmentation-required ICMP is received, the PMTU to this
# destination will be set to min_pmtu (see below). You will need
# to raise min_pmtu to the smallest interface MTU on your system
# manually if you want to avoid locally generated fragments.
# In mode 2 incoming Path MTU Discovery messages will be
# discarded. Outgoing frames are handled the same as in mode 1,
# implicitly setting IP_PMTUDISC_DONT on every created socket.
# Mode 3 is a hardend pmtu discover mode. The kernel will only
# accept fragmentation-needed errors if the underlying protocol
# can verify them besides a plain socket lookup. Current
# protocols for which pmtu events will be honored are TCP, SCTP
# and DCCP as they verify e.g. the sequence number or the
# association. This mode should not be enabled globally but is
# only intended to secure e.g. name servers in namespaces where
# TCP path mtu must still work but path MTU information of other
# protocols should be discarded. If enabled globally this mode
# could break other protocols.
# Possible values: 0-3
#PROC_IP_NO_PMTO_DISC=0

#---------------------------------------
#--- TCP SETTINGS
#---------------------------------------

# tcp_abc (Integer; default: 0; since Linux 2.6.15)
# Control the Appropriate Byte Count (ABC), defined in RFC 3465.
# ABC is a way of increasing the congestion window (cwnd) more
# slowly in response to partial acknowledgments.  Possible values are:
# 0  increase cwnd once per acknowledgment (no ABC)
# 1  increase cwnd once per acknowledgment of full sized segment
# 2  allow increase cwnd by two if acknowledgment is of two
# segments to compensate for delayed acknowledgments.
#PROC_TCP_ABC=0

# tcp_abort_on_overflow - BOOLEAN
# If listening service is too slow to accept new connections,
# reset them. Default state is FALSE. It means that if overflow
# occurred due to a burst, connection will recover. Enable this
# option _only_ if you are really sure that listening daemon
# cannot be tuned to accept connections faster. Enabling this
# option can harm clients of your server.
#PROC_TCP_ABORT_ON_OVERFLOW=0

# tcp_adv_win_scale - INTEGER Default: 1
# Count buffering overhead as bytes/2^tcp_adv_win_scale
# (if tcp_adv_win_scale > 0) or bytes-bytes/2^(-tcp_adv_win_scale),
# if it is <= 0.
# Possible values are [-31, 31], inclusive.
#PROC_TCP_ADV_WIN_SCALE=2

# tcp_app_win - INTEGER Default: 31
# Reserve max(window/2^tcp_app_win, mss) of window for application
# buffer. Value 0 is special, it means that nothing is reserved.
#PROC_TCP_APP_WIN=31

# tcp_base_mss - INTEGER
# The initial value of search_low to be used by the packetization layer
# Path MTU discovery (MTU probing).  If MTU probing is enabled,
# this is the initial MSS used by the connection.
#PROC_TCP_BASE_MSS=512

# tcp_congestion_control - STRING
# Set the congestion control algorithm to be used for new
# connections. The algorithm "reno" is always available, but
# additional choices may be available based on kernel configuration.
# Default is set as part of kernel configuration.
# For passive connections, the listener congestion control choice
# is inherited.
#PROC_TCP_CONGESTION_CONTROL=""

# tcp_dsack - BOOLEAN
# Allows TCP to send "duplicate" SACKs.
#PROC_TCP_DSACK=1

# Disable / Enable ECN (Explicit Congestion Notification) | Format: 0/1
# Control use of Explicit Congestion Notification (ECN) by TCP.
# ECN is used only when both ends of the TCP connection indicate
# support for it.  This feature is useful in avoiding losses due
# to congestion by allowing supporting routers to signal
# congestion before having to drop packets.
# Possible values are:
# 	0 Disable ECN.  Neither initiate nor accept ECN.
# 	1 Enable ECN when requested by incoming connections and
# 	  also request ECN on outgoing connection attempts.
# 	2 Enable ECN when requested by incoming connections
# 	  but do not request ECN on outgoing connections.
# Default: 2
#PROC_TCP_ECN=0

# Disable / Enable tcp fack | Format: 0/1
# tcp_fack - BOOLEAN
# Enable FACK congestion avoidance and fast retransmission.
# The value is not used, if tcp_sack is not enabled.
#PROC_TCP_FACK=0

# Set FIN timeout - Default: 60 seconds
# tcp_fin_timeout - INTEGER
# The length of time an orphaned (no longer referenced by any
# application) connection will remain in the FIN_WAIT_2 state
# before it is aborted at the local end.  While a perfectly
# valid "receive only" state for an un-orphaned connection, an
# orphaned connection in FIN_WAIT_2 state could otherwise wait
# forever for the remote to close its end of the connection.
# Cf. tcp_max_orphans
#PROC_TCP_FIN_TIMEOUT=10

# tcp_frto - BOOLEAN | Format: 0/1
# Enables Forward RTO-Recovery (F-RTO) defined in RFC5682.
# F-RTO is an enhanced recovery algorithm for TCP retransmission
# timeouts.  It is particularly beneficial in networks where the
# RTT fluctuates (e.g., wireless). F-RTO is sender-side only
# modification. It does not require any support from the peer.
#PROC_TCP_FRTO=0

# Set tcp keepalive interval | Format: value (i.e. 1800)
# tcp_keepalive_intvl - INTEGER
# How frequently the probes are send out. Multiplied by
# tcp_keepalive_probes it is time to kill not responding connection,
# after probes started. Default value: 75sec i.e. connection
# will be aborted after ~11 minutes of retries.
#PROC_TCP_KEEPALIVE_INT=1800

# tcp_keepalive_probes - INTEGER
# How many keepalive probes TCP sends out, until it decides that the
# connection is broken. Default value: 9.
#PROC_TCP_KEEPALIVE_PROBES=9

# tcp_keepalive_time - INTEGER
# How often TCP sends out keepalive messages when keepalive is enabled.
# Default: 2hours.
#PROC_TCP_KEEPALIVE_TIME=7200

# tcp_low_latency - BOOLEAN Default: 0
# If set, the TCP stack makes decisions that prefer lower
# latency as opposed to higher throughput.  By default, this
# option is not set meaning that higher throughput is preferred.
# An example of an application where this default should be
# changed would be a Beowulf computer cluster.
#PROC_TCP_LOW_LATENCY=0

# tcp_max_orphans - INTEGER
# Maximal number of TCP sockets not attached to any user file handle,
# held by system. If this number is exceeded orphaned connections are
# reset immediately and warning is printed. This limit exists
# only to prevent simple DoS attacks, you _must_ not rely on this
# or lower the limit artificially, but rather increase it
# (probably, after increasing installed memory),
# if network conditions require more than default value,
# and tune network services to linger and kill such states
# more aggressively. Let me to remind again: each orphan eats
# up to ~64K of unswappable memory.
#PROC_TCP_MAX_ORPHANS=8192

# tcp_max_syn_backlog - INTEGER
# Maximal number of remembered connection requests, which have not
# received an acknowledgment from connecting client.
# The minimal value is 128 for low memory machines, and it will
# increase in proportion to the memory of machine.
# If server suffers from overload, try increasing this number.
#PROC_TCP_MAX_SYN_BACKLOG=256

# tcp_max_tw_buckets - INTEGER
# Maximal number of timewait sockets held by system simultaneously.
# If this number is exceeded time-wait socket is immediately destroyed
# and warning is printed. This limit exists only to prevent
# simple DoS attacks, you _must_ not lower the limit artificially,
# but rather increase it (probably, after increasing installed memory),
# if network conditions require more than default value.
#PROC_TCP_MAX_TW_BUCKETS=16384 # default 180000?

# tcp_mem - vector of 3 INTEGERs: min, pressure, max
# min: below this number of pages TCP is not bothered about its memory appetite.
# pressure: when amount of memory allocated by TCP exceeds this number
# of pages, TCP moderates its memory consumption and enters memory
# pressure mode, which is exited when memory consumption falls under "min".
# max: number of pages allowed for queueing by all TCP sockets.
# Defaults are calculated at boot time from amount of available memory.
#PROC_TCP_MEM="6144 8192 12288"

# tcp_moderate_rcvbuf - BOOLEAN
# If set, TCP performs receive buffer auto-tuning, attempting to
# automatically size the buffer (no greater than tcp_rmem[2]) to
# match the size required by the path for full throughput. Enabled by default.
#PROC_TCP_MODERATE_RCVBUF=1

# tcp_mtu_probing - INTEGER
# Controls TCP Packetization-Layer Path MTU Discovery. Takes three values:
#   0 - Disabled
#   1 - Disabled by default, enabled when an ICMP black hole detected
#   2 - Always enabled, use initial MSS of tcp_base_mss.
#PROC_TCP_MTU_PROBING=0

# tcp_no_metrics_save - BOOLEAN
# By default, TCP saves various connection metrics in the route cache
# when the connection closes, so that connections established in the
# near future can use these to set initial conditions. Usually, this
# increases overall performance, but may sometimes cause performance
# degradation. If set, TCP will not cache metrics on closing connections.
#PROC_TCP_NO_METRICS_SAVE=0

# tcp_orphan_retries - INTEGER
# This value influences the timeout of a locally closed TCP connection,
# when RTO retransmissions remain unacknowledged.
# See tcp_retries2 for more details.
# The default value is 8.
# If your machine is a loaded WEB server,
# you should think about lowering this value, such sockets
# may consume significant resources. Cf. tcp_max_orphans.
#PROC_TCP_ORPHAN_RETRIES=0

# tcp_reordering - INTEGER Default: 3
# Maximal reordering of packets in a TCP stream.
#PROC_TCP_REORDERING=3

# tcp_retrans_collapse - BOOLEAN
# Bug-to-bug compatibility with some broken printers.
# On retransmit try to send bigger packets to work around bugs in
# certain TCP stacks.
#PROC_TCP_RETRANS_COLLAPSE=0 # default is enabled

# tcp_retries1 - INTEGER
# This value influences the time, after which TCP decides, that
# something is wrong due to unacknowledged RTO retransmissions,
# and reports this suspicion to the network layer.
# See tcp_retries2 for more details.
# RFC 1122 recommends at least 3 retransmissions, which is the default.
#PROC_TCP_RETRIES1=3

# tcp_retries2 - INTEGER
# This value influences the timeout of an alive TCP connection,
# when RTO retransmissions remain unacknowledged.
# Given a value of N, a hypothetical TCP connection following
# exponential backoff with an initial RTO of TCP_RTO_MIN would
# retransmit N times before killing the connection at the (N+1)th RTO.
# The default value of 15 yields a hypothetical timeout of 924.6
# seconds and is a lower bound for the effective timeout.
# TCP will effectively time out at the first RTO which exceeds the
# hypothetical timeout.
# RFC 1122 recommends at least 100 seconds for the timeout,
# which corresponds to a value of at least 8.
#PROC_TCP_RETRIES2=8

# tcp_rfc1337 - BOOLEAN Default: 0
# If set, the TCP stack behaves conforming to RFC1337. If unset,
# we are not conforming to RFC, but prevent TCP TIME_WAIT
# assassination.
#PROC_TCP_RFC1337=0

# tcp_rmem - vector of 3 INTEGERs: min, default, max
# min: Minimal size of receive buffer used by TCP sockets.
# It is guaranteed to each TCP socket, even under moderate memory pressure.
# Default: 1 page
# default: initial size of receive buffer used by TCP sockets.
# This value overrides net.core.rmem_default used by other protocols.
# Default: 87380 bytes. This value results in window of 65535 with
# default setting of tcp_adv_win_scale and tcp_app_win:0 and a bit
# less for default tcp_app_win. See below about these variables.
# max: maximal size of receive buffer allowed for automatically
# selected receiver buffers for TCP socket. This value does not override
# net.core.rmem_max. Calling setsockopt() with SO_RCVBUF disables
# automatic tuning of that socket's receive buffer size, in which
# case this value is ignored.
# Default: between 87380B and 6MB, depending on RAM size.
#PROC_TCP_RMEM="4096 87380 262144"

# Disable / Enable tcp select acknowledgments (SACKS)| Format: 0/1
#PROC_TCP_SACK=0

# tcp_slow_start_after_idle - BOOLEAN Default: 1
# If set, provide RFC2861 behavior and time out the congestion
# window after an idle period. An idle period is defined at
# the current RTO. If unset, the congestion window will not
# be timed out after an idle period.
#PROC_TCP_SLOW_START_AFTER_IDLE=1

# tcp_stdurg - BOOLEAN Default: FALSE
# Use the Host requirements interpretation of the TCP urgent pointer field.
# Most hosts use the older BSD interpretation, so if you turn this on
# Linux might not communicate correctly with them.
#PROC_TCP_STDURG=0

# tcp_synack_retries - INTEGER
# Number of times SYNACKs for a passive TCP connection attempt will
# be retransmitted. Should not be higher than 255. Default value
# is 5, which corresponds to 31 seconds till the last retransmission
# with the current initial RTO of 1 second. With this the final timeout
# for a passive TCP connection will happen after 63 seconds.
#PROC_TCP_SYNACK_RETRIES=5

# Disable / Enable TCP-SYN-COOKIES (SYN-FLOOD PROTECTION) | Format: 0/1
# tcp_syncookies - BOOLEAN Default: 1
# Only valid when the kernel was compiled with CONFIG_SYN_COOKIES
# Send out syncookies when the syn backlog queue of a socket
# overflows. This is to prevent against the common 'SYN flood attack'
# Note, that syncookies is fallback facility.
# It MUST NOT be used to help highly loaded servers to stand
# against legal connection rate. If you see SYN flood warnings
# in your logs, but investigation shows that they occur
# because of overload with legal connections, you should tune
# another parameters until this warning disappear.
# See: tcp_max_syn_backlog, tcp_synack_retries, tcp_abort_on_overflow.
# syncookies seriously violate TCP protocol, do not allow
# to use TCP extensions, can result in serious degradation
# of some services (f.e. SMTP relaying), visible not by you,
# but your clients and relays, contacting you. While you see
# SYN flood warnings in logs not being really flooded, your server
# is seriously misconfigured.
# If you want to test which effects syncookies have to your
# network connections you can set this knob to 2 to enable
# unconditionally generation of syncookies.
#PROC_TCP_SYN_COOKIES=1

# tcp_syn_retries - INTEGER
# Number of times initial SYNs for an active TCP connection attempt
# will be retransmitted. Should not be higher than 255. Default value
# is 6, which corresponds to 63 seconds till the last retransmission
# with the current initial RTO of 1second. With this the final timeout
# for an active TCP connection attempt will happen after 127 seconds.
#PROC_TCP_SYN_RETRIES=6

# tcp_timestamps - BOOLEAN
# Enable timestamps as defined in RFC1323.
#PROC_TCP_TIMESTAMPS=1

# tcp_tso_win_divisor - INTEGER Default: 3
# This allows control over what percentage of the congestion window
# can be consumed by a single TSO frame.
# The setting of this parameter is a choice between burstiness and
# building larger TSO frames.
#PROC_TCP_TSO_WIN_DIVISOR=3

# tcp_tw_recycle - BOOLEAN
# Enable fast recycling TIME-WAIT sockets. Default value is 0.
# It should not be changed without advice/request of technical experts.
#PROC_TCP_TW_RECYCLE=0

# tcp_tw_reuse - BOOLEAN
# Allow to reuse TIME-WAIT sockets for new connections when it is
# safe from protocol viewpoint. Default value is 0.
# It should not be changed without advice/request of technical experts.
#PROC_TCP_TW_REUSE=0

# Disable / Enable TCP windows scaling as defined in RFC1323. | Format: 0/1
# tcp_window_scaling - BOOLEAN
#PROC_TCP_WINDOW_SCALING=1

# tcp_workaround_signed_windows - BOOLEAN Default: 0
# If set, assume no receipt of a window scaling option means the
# remote TCP is broken and treats the window as a signed quantity.
# If unset, assume the remote TCP is not broken even if we do
# not receive a window scaling option from them.
#PROC_TCP_WORKAROUND_SIGNED_WINDOWS=0

# tcp_wmem - vector of 3 INTEGERs: min, default, max
# min: Amount of memory reserved for send buffers for TCP sockets.
# Each TCP socket has rights to use it due to fact of its birth.
# Default: 1 page
# default: initial size of send buffer used by TCP sockets.  This
# value overrides net.core.wmem_default used by other protocols.
# It is usually lower than net.core.wmem_default.
# Default: 16K
# max: Maximal amount of memory allowed for automatically tuned
# send buffers for TCP sockets. This value does not override
# net.core.wmem_max.  Calling setsockopt() with SO_SNDBUF disables
# automatic tuning of that socket's send buffer size, in which case
# this value is ignored.
# Default: between 64K and 4MB, depending on RAM size.
#PROC_TCP_WMEM="4096 16384 262144"

#---------------------------------------
#--- ICMP SETTINGS
#---------------------------------------

# Disable / Enable Ignoring of bogus icmp messages | Format: 0/1
#PROC_IGNORE_BOGUS_ICMP=1

# Disable / Enable ICMP echo broadcasts | Format: 0/1
#PROC_ICMP_BROADCASTS=0

# icmp_echo_ignore_all - BOOLEAN Default: 0
# If set to 1, then the kernel will ignore all ICMP ECHO requests sent to it.
#PROC_ICMP_ECHO_IGNORE_ALL=0

# icmp_ratelimit - INTEGER Default: 1000
# Limit the maximal rates for sending ICMP packets whose type matches
# icmp_ratemask (see below) to specific targets.
# 0 to disable any limiting,
# otherwise the minimal space between responses in milliseconds.
#PROC_ICMP_RATELIMIT=250

# icmp_ratemask - INTEGER
# Mask made of ICMP types for which rates are being limited.
# Significant bits: IHGFEDCBA9876543210
# Default mask:     0000001100000011000 (6168)
#
# Bit definitions (see include/linux/icmp.h):
# 	0 Echo Reply
# 	3 Destination Unreachable *
# 	4 Source Quench *
# 	5 Redirect
# 	8 Echo Request
# 	B Time Exceeded *
# 	C Parameter Problem *
# 	D Timestamp Request
# 	E Timestamp Reply
# 	F Info Request
# 	G Info Reply
# 	H Address Mask Request
# 	I Address Mask Reply
#
# 	* These are rate limited by default (see default mask above)
#PROC_ICMP_RATEMASK=6168

#---------------------------------------
#--- NETFILTER SETTINGS
#---------------------------------------

# Increase the default queuelength. (Kernel Default: 1024)
#PROC_QUEUELEN=2048

# Set maximum number of connections to track
# (leave unconfigured if PROC_CONNTRACK_HASHSIZE is set to automatic calculation)
# Format: value (i.e. 8192) | [xX]factor (i.e. x2 to calculate the value automatically and multiply it with 2)
#PROC_CONNTRACK_MAX=12216

# Set conntrack module hashsize (leave unconfigured if PROC_CONNTRACK_MAX is set to automatic calculation)
# Format: value (i.e. 8192) | [xX]factor (i.e. x2 to calculate the value automatically and multiply it with 2)
#PROC_CONNTRACK_HASHSIZE=

# Deactivate automatic conntrack helper assignment (to all IP addresses) (available since kernel v3.5)
# instead use -t raw -j CT --helper xyz
# Format: 0 (default) | 1 (to deactivate)
#PROC_CT_HELPER=0

# nf_conntrack_acct - BOOLEAN
# 0 - disabled (default)
# 1 - enabled
# Enable connection tracking flow accounting. 64-bit byte and packet
# counters per flow are added.
#PROC_CT_ACCT=0

# nf_conntrack_events - BOOLEAN
# 0 - disabled
# 1 - enabled (default)
# If this option is enabled, the connection tracking code will
# provide userspace with connection tracking events via ctnetlink.
#PROC_CT_EVENTS=1

# nf_conntrack_events_retry_timeout - INTEGER (seconds) default 15
# This option is only relevant when "reliable connection tracking
# events" are used.  Normally, ctnetlink is "lossy", that is,
# events are normally dropped when userspace listeners can't keep up.
# Userspace can request "reliable event mode".  When this mode is
# active, the conntrack will only be destroyed after the event was
# delivered.  If event delivery fails, the kernel periodically
# re-tries to send the event to userspace.
# This is the maximum interval the kernel should use when re-trying
# to deliver the destroy event.
# A higher number means there will be fewer delivery retries and it
# will take longer for a backlog to be processed.
#PROC_CT_EVENTS_RETRY_TIMEOUT=15

# nf_conntrack_expect_max - INTEGER
# Maximum size of expectation table.  Default value is
# nf_conntrack_buckets / 256. Minimum is 1.
#PROC_CT_EXPECT_MAX=48

# nf_conntrack_generic_timeout - INTEGER (seconds) default 600
# Default for generic timeout. This refers to layer 4 unknown/unsupported protocols.
#PROC_CT_GENERIC_TIMEOUT=600

# nf_conntrack_icmp_timeout - INTEGER (seconds) default 30
# Default for ICMP timeout.
#PROC_CT_ICMP_TIMEOUT=30

# nf_conntrack_log_invalid - INTEGER
# Log invalid packets of a type specified by value.
# 0   - disable (default)
# 1   - log ICMP packets
# 6   - log TCP packets
# 17  - log UDP packets
# 33  - log DCCP packets
# 41  - log ICMPv6 packets
# 136 - log UDPLITE packets
# 255 - log packets of any protocol
#PROC_CT_LOG_INVALID=0

# nf_conntrack_tcp_be_liberal - BOOLEAN
# 0 - disabled (default)
# 1 - enabled
# Be conservative in what you do, be liberal in what you accept from others.
# If it's non-zero, we mark only out of window RST segments as INVALID.
#PROC_CT_TCP_BE_LIBERAL=0

# nf_conntrack_tcp_loose - BOOLEAN
# 0 - disabled
# 1 - enabled (default)
# If it is set to zero, we disable picking up already established
# connections.
#PROC_CT_TCP_LOOSE=0

# nf_conntrack_tcp_max_retrans - INTEGER default 3
# Maximum number of packets that can be retransmitted without
# received an (acceptable) ACK from the destination. If this number
# is reached, a shorter timer will be started.
#PROC_CT_TCP_MAX_RETRANS=3

# nf_conntrack_tcp_timeout_close - INTEGER (seconds) default 10
#PROC_CT_TCP_TIMEOUT_CLOSE=10

# nf_conntrack_tcp_timeout_close_wait - INTEGER (seconds) default 60
#PROC_CT_TCP_TIMEOUT_CLOSE_WAIT=60

# nf_conntrack_tcp_timeout_established - INTEGER (seconds) default 432000 (5 days)
#PROC_CT_TCP_TIMEOUT_ESTABLISHED=432000

# nf_conntrack_tcp_timeout_fin_wait - INTEGER (seconds) default 120
#PROC_CT_TCP_TIMEOUT_FIN_WAIT=120

# nf_conntrack_tcp_timeout_last_ack - INTEGER (seconds) default 30
#PROC_CT_TCP_TIMEOUT_LAST_ACK=30

# nf_conntrack_tcp_timeout_max_retrans - INTEGER (seconds) default 300
#PROC_CT_TCP_TIMEOUT_MAX_RETRANS=300

# nf_conntrack_tcp_timeout_syn_recv - INTEGER (seconds) default 60
#PROC_CT_TCP_TIMEOUT_SYN_RECV=60

# nf_conntrack_tcp_timeout_syn_sent - INTEGER (seconds) default 120
#PROC_CT_TCP_TIMEOUT_SYN_SENT=120

# nf_conntrack_tcp_timeout_time_wait - INTEGER (seconds) default 120
#PROC_CT_TCP_TIMEOUT_TIME_WAIT=120

# nf_conntrack_tcp_timeout_unacknowledged - INTEGER (seconds) default 300
#PROC_CT_TCP_TIMEOUT_UNACK=300

# nf_conntrack_udp_timeout - INTEGER (seconds) default 30
#PROC_CT_UDP_TIMEOUT=30

# nf_conntrack_udp_timeout_stream - INTEGER (seconds) # default 180
# This extended timeout will be used in case there is an UDP stream
# detected.
#PROC_CT_UDP_TIMEOUT_STREAM=180

#---------------------------------------
#--- INET PEER SETTINGS
#---------------------------------------

# The inet_peer_gc_maxtime variable tells the garbage collector how often to pass over
# the inet peer storage memory pool during low, or absent, memory pressure.
# This value is in effect under the reversed conditions of the inet_peer_gc_mintime in other words.
# It works exactly the same as the inet_peer_gc_mintime, except for the fact that it will be
# in effect under different system loads. This variable is measured in jiffies.
#PROC_INET_PEER_GC_MAXTIME=120

# The inet_peer_gc_mintime variable sets the minimum time between garbage collections (gc) passes
# in the inet peer storage under heavy memory pressure. If the system is under heavy utilization
# and there is a lot of constraints on the memory pool, this timer is used to tell the garbage
# collector how often to pass over the memory pool used by the inet peer storage, in jiffies.
# The inet_peer_gc_mintime variable takes an integer value and has a default value of 10 jiffies.
# This should be a fairly good value for most users and servers.
#PROC_INET_PEER_GC_MINTIME=10

# inet_peer_maxttl - INTEGER
# Maximum time-to-live of entries. Unused entries will expire after
# this period of time if there is no memory pressure on the pool (i.e.
# when the number of entries in the pool is very small).
# Measured in seconds.
#PROC_INET_PEER_GC_MAXTTL=600

# inet_peer_minttl - INTEGER
# Minimum time-to-live of entries. Should be enough to cover fragment
# time-to-live on the reassembling side. This minimum time-to-live  is
# guaranteed if the pool size is less than inet_peer_threshold.
# Measured in seconds.
#PROC_INET_PEER_GC_MINTTL=120

# inet_peer_threshold - INTEGER
# The approximate size of the storage. Starting from this threshold
# entries will be thrown aggressively. This threshold also determines
# entries' time-to-live and time intervals between garbage collection
# passes. More entries, less time-to-live, less GC interval.
#PROC_INET_PEER_THRESHOLD=65664

#-------------------------------------------------------------------------------

