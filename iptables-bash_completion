#!/bin/bash

# -----------------------------------------------------------------
# Programmable completion code for iptables (netfilter.org)
#
# https://github.com/AllKind/iptables-bash_completion
# https://sourceforge.net/projects/ipt-bashcompl
# -----------------------------------------------------------------

# Copyright (C) 2013 AllKind (AllKind@fastest.cc)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# -----------------------------------------------------------------
# Tested with iptables versions:
# 1.4.16.3
# -----------------------------------------------------------------
#
# Put it into ~/.bash_completion or /etc/bash_completion.d/
#
# -----------------------------------------------------------------
#
# Version 1.0
#
# -----------------------------------------------------------------

shopt -s extglob

# -----------------------------------------------------------------
# FUNCTIONS
# -----------------------------------------------------------------

_iptables_bash_default_compl() { # taken from examples - modified by me
# call with the word to be completed as $1
local t
if [[ $1 == \$\(* ]]; then # command substitution
	t=${1#??}
	COMPREPLY=( $(compgen -c -P '$(' $t) )
elif [[ $1 == \$\{* ]]; then # variables with a leading `${'
	t=${1#??}
	COMPREPLY=( $(compgen -v -P '${' -S '}' $t) )
elif [[ $1 == \$* ]]; then # variables with a leading `$'
	t=${1#?}
	COMPREPLY=( $(compgen -v -P '$' $t ) )
elif [[ "$1" == *@* ]]; then # hostname
	t=${1#*@}
	COMPREPLY=( $( compgen -A hostname $t ) )
elif [[ $1 == *[*?[]* ]]; then # sh-style glob pattern
	COMPREPLY=( $( compgen -G "$1" ) )
# ksh-style extended glob pattern - must be complete
elif shopt -q extglob && [[ $1 == *[?*+\!@]\(*\)* ]]; then
	COMPREPLY=( $( compgen -G "$1" ) )
fi
}

# -----------------------------------------------------------------
# iptables functions
# -----------------------------------------------------------------
_iptables_select_on_inet_family() {
if [[ $1 != all ]]; then # select match according to current calling app
	if [[ $1 = v4 && $str_app = ip6tables ]]; then
		return 1
	elif [[ $1 = v6 && $str_app = iptables ]]; then
		return 1
	fi
fi
return 0
}

_iptables_is_option() {
local -i opt_idx
local str_q="$1"
if [[ $str_q = --new && $str_target = CLUSTERIP ]]; then
	return 1
fi
for opt_idx in ${!arr_opts[@]}; do set -- ${arr_opts[opt_idx]}
	while (($#)); do
		[[ $1 = $str_q ]] && return
		shift
	done
done
return 1
}

_iptables_is_target() {
local -i idx
local str_x="$1"
[[ $str_x = @(""|-*|*/*) ]] && return 1
for idx in ${!arr_targets[@]}; do
	[[ ${arr_targets[idx]%% *} = $str_x ]] && return
done
return 1
}

_iptables_is_match() {
local -i idx
local str_x="$1"
[[ $str_x = @(""|-*|*/*) ]] && return 1
for idx in ${!arr_matches[@]}; do
	[[ ${arr_matches[idx]%% *} = $str_x ]] && return
done
return 1
}

_iptables_get_match_by_table() {
local -i idx
local str_x="$1" # table name
for idx in ${!arr_matches[@]}; do
	set -- ${arr_matches[idx]}
	_iptables_select_on_inet_family $2 || continue
	if [[ $3 = all ]] || [[ ${3//,/ } = *${str_x}* ]]; then # valid in current table
		printf "%s\n" "${arr_matches[idx]%% *}"
	fi
done
}

_iptables_get_target_by_table() {
local -i idx
local str_x="$1"
for idx in ${!arr_targets[@]}; do set -- ${arr_targets[idx]}
	_iptables_select_on_inet_family $2 || continue
	if [[ $3 = all ]] || [[ ${3//,/ } = *${str_x}* ]]; then
		printf "%s\n" "${arr_targets[idx]%% *}"
	fi
done
}

_iptables_get_builtin_chains_by_table() {
local str_cmd str_name str_rest
while read -r str_cmd str_name str_rest; do
	[[ $str_cmd = -P ]] && printf "%s\n" "$str_name" || return 0
done < <(iptables -S -t $1 2>/dev/null)
}

_iptables_get_user_chains() {
local str_cmd str_name str_rest
while read -r str_cmd str_name str_rest; do
	if [[ $str_cmd = -N ]]; then printf "%s\n" "$str_name"
	elif [[ $str_cmd = -A ]]; then return 0
	fi
done < <(iptables -S -t $1 2>/dev/null)
}

_iptables_get_target_options() {
local -i idx
local str_x="$1"
for idx in ${!arr_targets[@]}; do set -- ${arr_targets[idx]}
	if [[ $1 = $str_x ]]; then
		_iptables_select_on_inet_family $2 || continue
		shift 3
		printf "%s\n" "$*"
		return 0
	fi
done
}

_iptables_get_match_options() {
local -i idx cix rix xix got_arg 
local str_match="$1" str_opt str_tmp
local arr_reply=()
for idx in ${!arr_matches[@]}; do set -- ${arr_matches[idx]}
	if [[ $1 = $str_match ]]; then arr_reply=()
		_iptables_select_on_inet_family $2 || continue
		shift 3
		for str_opt in "$@"; do
			if [[ $str_opt = *,* ]]; then # redundant option names
				for str_tmp in ${str_opt//,/ }; do # exclude the aliases from listing
					if _iptables_is_in_compwords $str_tmp; then
						continue 2
					fi
				done
			fi
			arr_reply[${#arr_reply[@]}]="$str_opt"
		done
		for rix in ${!arr_reply[@]}; do str_opt="${arr_reply[rix]}"
			# find options which can be used globally (multiple use of match), but filter them out
			# if we already used them in the current active match
			for xix in ${!arr_global_matches[@]}; do # retrieve list of global options
				set -- ${arr_global_matches[xix]}
				if [[ $str_match = $1 ]]; then shift
					for str_tmp in "$@"; do
						if [[ $str_tmp = $str_opt ]]; then got_arg=0
							for ((cix=${#COMP_WORDS[@]}-1; cix > 0; cix--)); do
								if [[ -z ${COMP_WORDS[cix]} ]]; then continue
								elif [[ ${COMP_WORDS[cix]} != $str_opt && ${COMP_WORDS[cix]} != $str_match ]]; then
								   if [[ ${COMP_WORDS[cix]} = -* ]]; then
									   _iptables_is_option "${COMP_WORDS[cix]}" && break # another option
								   else
										if _iptables_is_match "${COMP_WORDS[cix]}"; then break # another match
										elif _iptables_is_target "${COMP_WORDS[cix]}"; then break # another target
										fi
								   fi
								elif [[ ${COMP_WORDS[cix]} = $str_opt ]]; then got_arg=1 # got the option
								elif [[ ${COMP_WORDS[cix]} = $str_match && ${COMP_WORDS[cix-1]} = @(-m|--match|-p|--proto) ]]
								then # got the match
									((got_arg)) || break # but don't have arg
									unset arr_reply[rix]
								fi
							done
						fi
					done
				fi
			done
		done
		printf "%s\n" "${arr_reply[*]//,/ }"
		return 0
	fi
done
}

_iptables_get_rulenum() {
[[ ${COMP_WORDS[${1}+2]} = +([[:digit:]]) ]] && printf "%d\n" ${COMP_WORDS[${1}+2]}
}

#_iptables_last_is_option() {
#local -i idx
#for ((idx=${#COMP_WORDS[@]}-1; idx > 0; idx--)); do
#	if [[ -z ${COMP_WORDS[idx]} || ${COMP_WORDS[idx]} != @(-*) ]]; then continue
#	elif _iptables_is_option "${COMP_WORDS[idx]}"; then return 0
#	fi
#done
#return 1
#}

#_iptables_last_is_match() {
#local -i idx
#for ((idx=${#COMP_WORDS[@]}-1; idx > 0; idx--)); do
#	if [[ -z ${COMP_WORDS[idx]} ]]; then continue
#	elif [[ ${COMP_WORDS[idx]} != -* ]]; then
#		if _iptables_is_match "${COMP_WORDS[idx]}" && \
#			[[ ${COMP_WORDS[idx-1]} = @(-m|--match|-p|--proto) ]]
#		then
#			return 0
#		elif _iptables_is_target "${COMP_WORDS[idx]}"; then
#			return 1
#		fi
#	elif [[ ${COMP_WORDS[idx]} = -* ]] && _iptables_is_option "${COMP_WORDS[idx]}"
#	then return 1
#	fi
#done
#return 1
#}
#
#_iptables_last_is_target() {
#local -i idx
#for ((idx=${#COMP_WORDS[@]}-1; idx > 0; idx--)); do
#	if [[ -z ${COMP_WORDS[idx]} ]]; then continue
#	elif [[ ${COMP_WORDS[idx]} != -* ]]; then
#		if _iptables_is_target "${COMP_WORDS[idx]}" && \
#			[[ ${COMP_WORDS[idx]} = $str_target && ${COMP_WORDS[idx-1]} = @(-@(j|-jump|g|-goto)) ]]
#		then return 0
#		elif _iptables_is_match "${COMP_WORDS[idx]}" && [[ ${COMP_WORDS[idx-1]} = @(-m|--match|-p|--proto) ]]
#		then return 1
#		fi
#	elif [[ ${COMP_WORDS[idx]} = -* ]] && _iptables_is_option "${COMP_WORDS[idx]}"
#	then return 1
#	fi
#done
#return 1
#}

_iptables_last_is() {
local -i idx
for ((idx=${#COMP_WORDS[@]}-1; idx > 0; idx--)); do
	if [[ -z ${COMP_WORDS[idx]} || ${COMP_WORDS[idx]} = - ]]; then continue
	elif [[ ${COMP_WORDS[idx]} != -* ]]; then
		if _iptables_is_target "${COMP_WORDS[idx]}" && \
			[[ ${COMP_WORDS[idx]} = $str_target && ${COMP_WORDS[idx-1]} = @(-@(j|-jump|g|-goto)) ]]
		then printf "%s\n" "target"
		return 0
	elif _iptables_is_match "${COMP_WORDS[idx]}" && [[ ${COMP_WORDS[idx-1]} = @(-@(m|-match|p|-proto)) ]]
		then printf "%s\n" "match"
		return 0
		fi
	elif _iptables_is_option "${COMP_WORDS[idx]}"
	then printf "%s\n" "option"
		return 0
	fi
done
}

# -----------------------------------------------------------------
# retrieve arguments data
# -----------------------------------------------------------------
_iptables_get_ifnames() {
while read -r; do
	REPLY="${REPLY#*: }"
	printf "%s\n" ${REPLY%%:*}
done < <(PATH=${PATH}:/sbin command ip -o link show)
}

_iptables_get_protocols() {
local str_name rest
while read -r str_name rest; do
	[[ $str_name = *([[:blank:]])#* ]] && continue
	printf "%s\n" "$str_name"
done < /etc/protocols
}

_iptables_get_services() {
local str_name rest
while read -r str_name rest; do
	[[ $str_name = *([[:blank:]])#* ]] && continue
	printf "%s\n" "$str_name"
done < /etc/services
}

_iptables_get_setnames() {
PATH=${PATH}:/sbin command ipset -n list
}

_iptables_get_cpuinfo() {
local str_name c num
while read -r str_name c num; do
	[[ $str_name = processor ]] && printf "%s\n" "$num"
done < /proc/cpuinfo
}

_iptables_get_realms() {
local str_x
while read -r; do
	[[ $REPLY = *([[:space:]])#* ]] && continue
	if [[ $REPLY = *([[:space:]])+([[:digit:]])+([[:space:]])+([[:graph:]])* ]]; then
		str_x="${REPLY#*+([[:digit:]])+([[:space:]])}"
		printf "%s\n" "${str_x%#*}"
	fi
done </etc/iproute2/rt_realms
} # -------------------------------------------------------------------------

# -----------------------------------------------------------------
# misc functions
# -----------------------------------------------------------------
_iptables_get_cw_idx() {
local -i idx index=0
for idx in ${!COMP_WORDS[@]}; do
	if [[ ${COMP_WORDS[idx]} = $1 ]]; then index=$idx
		# we don't break, as args could be used double.
		# choosing the last one, is ugly but less worse i think
		# TODO: find a solution
#		printf "%d\n" "$idx"
#		return 0
	fi
done
printf "%d\n" $((index ? index : -1))
}

_iptables_is_in_compwords() {
local -i cix
for ((cix=1; cix < ${#COMP_WORDS[@]}; cix++)); do
	[[ $1 = ${COMP_WORDS[cix]} ]] && return
done
}

_iptables_swap_array() {
local -i idx
local s_arr=$1 d_arr=$2 
eval $d_arr'=()'
eval 'for idx in ${!'$s_arr'[@]};do '$d_arr'[$idx]="${'$s_arr'[$idx]}";done'
}

# -----------------------------------------------------------------
# main function
# -----------------------------------------------------------------
_iptables_complete() {
local -i i=0 x=0 y=0 opt_request=0 got_action=0 set_counters=0 rulenum=0
#declare -i i=x=y=got_action=set_counters=rulenum=0
local cur prev ipt_version
local str_table="filter" str_chain str_target str_jump str_action str_tmp str_c
local arr_tmp_opts=() arr_cmd_matches=() arr_tmp=()
local -r str_app="${COMP_WORDS[0]//*\//}"

if ((${BASH_VERSINFO[0]} < 3)); then
	return 0
fi

# old iptables versions, which don't have the `-S' option are not supported
"$str_app" -S OUTPUT 1 &>/dev/null || return

# iptables version TODO: checks re version
ipt_version="$("$str_app" --version)"
ipt_version="${ipt_version#$str_app v}"

local arr_opts=(
"-d --destination"
"-f --fragment"
"-g --goto"
"-h --help"
"-i --in-interface"
"-j --jump"
"-m --match"
"-n --numeric"
"-o --out-interface"
"-p --proto"
"-s --source"
"-t --table"
"-v --verbose"
"-x --exact"
"-A --append"
"-C --check"
"-D --delete"
"-E --rename-chain"
"-F --flush"
"-I --insert"
"-L --list"
"-N --new"
"-P --policy"
"-R --replace"
"-S --list-rules"
"-V --version"
"-X --delete-chain"
"-Z --zero"
--line-numbers
--set-counters
--modprobe=
)

local arr_command_opts=(
"-h --help"
"-t --table"
"-v --verbose"
"-A --append"
"-C --check"
"-D --delete"
"-E --rename-chain"
"-F --flush"
"-I --insert"
"-L --list"
"-N --new"
"-P --policy"
"-R --replace"
"-S --list-rules"
"-V --version"
"-X --delete-chain"
"-Z --zero"
--set-counters
)

local arr_rule_action_opts=(
"-d --destination"
"-f --fragment"
"-g --goto"
"-i --in-interface"
"-j --jump"
"-m --match"
"-o --out-interface"
"-p --proto"
"-s --source"
"-t --table"
"-v --verbose"
--modprobe=
)

local arr_min_opts=(
"-t --table"
"-v --verbose"
)

local arr_list_opts=(
"-n --numeric"
"-t --table"
"-v --verbose"
"-x --exact"
--line-numbers
)

local arr_tables=(
filter
mangle
nat
security
raw
)

# target-name all|v4|v6 all|table1,table2,... option [...]
local arr_targets=(
"ACCEPT all all"
"AUDIT all all --type" # TODO: audit drop in nat table, really valid?
"DROP all filter,mangle,security,raw"
"CHECKSUM all mangle --checksum-fill"
"CLASSIFY all all --set-class"
"CLUSTERIP v4 mangle --new --hashmode --clustermac --total-nodes --local-node --hash-init"
"CONNSECMARK all mangle,security --save --restore"
"ECN all mangle --ecn-tcp-remove" # TODO: maybe check if proto is tcp
"DNAT v4 nat --to-destination --random --persistent"
"DSCP all mangle --set-dscp --set-dscp-class" # TODO: mutual exclusive options
"HL v6 mangle --hl-set --hl-dec --hl-inc" # TODO: mutual exclusive options
"IDLETIMER all all --timeout --label"
"LED all all --led-trigger-id --led-delay --led-always-blink"
"LOG all all --log-level --log-prefix --log-tcp-sequence --log-tcp-options --log-ip-options --log-uid"
"MASQUERADE v4 nat --to-ports --random" # TODO: maybe check if proto is tcp|udp
"NETMAP v4 nat --to"
"NFLOG all all --nflog-group --nflog-prefix --nflog-range --nflog-threshold"
"NFQUEUE all all --queue-num --queue-balance --queue-bypass" # TODO: mutual exclusive options
"NOTRACK all raw"
"RATEEST all all --rateest-name --rateest-interval --rateest-ewmalog"
"REDIRECT v4 nat --to-ports --random" # TODO: maybe check if proto is tcp|udp
"REJECT all filter --reject-with"
"SECMARK all mangle,security --selctx" # TODO: retrieve security_context
"SET all all --add-set --del-set --timeout --exist"
"SNAT v4 nat --to-source --random --persistent"
"TEE all all --gateway" # TODO: really valid in all tables? cmdline does not forbid it
"TCPMSS all mangle --set-mss --clamp-mss-to-pmtu" # TODO: maybe check if proto is tcp
"TOS all mangle --set-tos --and-tos --or-tos --xor-tos" # TODO: mutual exclusive options
"TPROXY all mangle --on-port --on-ip --tproxy-mark" # TODO: maybe check if proto is tcp|udp
"TRACE all raw"
"TTL v4 mangle --ttl-set --ttl-dec --ttl-inc" # TODO: mutual exclusive options
)

# match-name all|v4|v6 all|table1,table2,... option[,alias] [...]
local arr_matches=(
"tcp all all --source-port,--sport --destination-port,--dport --tcp-flags --syn --tcp-option"
"udp all all --source-port,--sport --destination-port,--dport"
"icmp v4 all --icmp-type"
"icmp6 v6 all --icmpv6-type"
"addrtype all all --src-type --dst-type --limit-iface-in --limit-iface-out"
"comment all all --comment"
"connbytes all all --connbytes --connbytes-dir --connbytes-mode"
"connmark all all --mark"
"cpu all all --cpu"
"dscp all all --dscp --dscp-class" # TODO: mutual exclusive options
"ecn all all --ecn-tcp-cwr --ecn-tcp-ece --ecn-ip-ect"
"eui64 v6 all"
"helper all all --helper" # TODO: check if we can retrieve list of helpers
"iprange all all --src-range --dst-range"
"length all all --length"
"mac all all --mac-source"
"owner all all --uid-owner --gid-owner --socket-exists"
"quota all all --quota"
"mark all all --mark"
"pkttype all all --pkt-type"
"realm v4 all --realm"
"rpfilter all mangle,raw --loose --validmark --accept-local"
"sctp all all --source-port,--sport --destination-port,--dport --chunk-types"
"socket all all --transparent" # TODO: was --transparent option available from the beginning?
"set all all --match-set --return-nomatch"
)

local arr_global_matches=(
"mark --mark"
"set --match-set --return-nomatch"
"sctp --chunk-types"
)

local arr_icmp_types=( any
echo-reply,pong
destination-unreachable
network-unreachable
host-unreachable
protocol-unreachable
port-unreachable
fragmentation-needed
source-route-failed
network-unknown
host-unknown
network-prohibited
host-prohibited
TOS-network-unreachable
TOS-host-unreachable
communication-prohibited
host-precedence-violation
precedence-cutoff
source-quench
redirect
network-redirect
host-redirect
TOS-network-redirect
TOS-host-redirect
echo-request,ping
router-advertisement
router-solicitation
time-exceeded,ttl-exceeded
ttl-zero-during-transit
ttl-zero-during-reassembly
parameter-problem
ip-header-bad
required-option-missing
timestamp-request
timestamp-reply
address-mask-request
address-mask-reply
)
local arr_icmp6_types=(
destination-unreachable
no-route
communication-prohibited
address-unreachable
port-unreachable
packet-too-big
time-exceeded,ttl-exceeded
ttl-zero-during-transit
ttl-zero-during-reassembly
parameter-problem
bad-header
unknown-header-type
unknown-option
echo-request,ping
echo-reply,pong
router-solicitation
router-advertisement
neighbour-solicitation,neighbor-solicitation
neighbour-advertisement,neighbor-advertisement
redirect
)

COMPREPLY=()
#COMP_WORDBREAKS=$' \t\n"\'><=;|&(:'

# expecting _get_comp_words_by_ref() to exist from bash_completion
if declare -f _get_comp_words_by_ref &>/dev/null; then
	_get_comp_words_by_ref cur || return
	_get_comp_words_by_ref prev || return
else # not so neat, but a workaround
	cur="${COMP_WORDS[COMP_CWORD]}"
	prev="${COMP_WORDS[COMP_CWORD-1]}"
fi

#_DEBUG_IPT_COMPL=Y
if [[ $_DEBUG_IPT_COMPL ]]; then
	printf "\nCOMP_WORDBREAKS: <%s>\n" "$COMP_WORDBREAKS"
	printf "COMP_LINE: <%s>\n" "$COMP_LINE"
	printf "COMP_TYPE: <%s>\n" "$COMP_TYPE"
	printf "COMP_POINT: <%s>\n" "$COMP_POINT"
	printf "COMP_KEY: <%s>\n" "$COMP_KEY"
	printf "COMP_CWORD: <%s>\n" "$COMP_CWORD"
	printf "COMP_WORDS:\n"
	printf "<%s>\n" "${COMP_WORDS[@]}"
	printf "cur: <%s> prev: <%s>\n" "$cur" "$prev"
fi

for ((i=1; i < ${#COMP_WORDS[@]}; i++)); do
	case ${COMP_WORDS[i]} in
		-j|--jump|-g|--goto)
			str_jump=${COMP_WORDS[i]} str_target="${COMP_WORDS[i+1]}"
		;;
		-m|--match) arr_cmd_matches[${#arr_cmd_matches[@]}]="${COMP_WORDS[i+1]}" ;;
		-p|--proto) # if proto is not an integer, add it to list of matches
			# that might break things, but makes it easier to handle with current code.
			# actually i don't know a scenario that will mess up, but yeah...
			[[ ${COMP_WORDS[i]} = +([[:digit:]]) ]] || arr_cmd_matches[${#arr_cmd_matches[@]}]="${COMP_WORDS[i+1]}"
		;;
		-t|--table) str_table="${COMP_WORDS[i+1]}" ;;
		-E|--rename-chain)
			str_chain="${COMP_WORDS[i+1]}" str_action=${COMP_WORDS[i]}
		   	let got_action+=1
			_iptables_swap_array arr_min_opts arr_tmp_opts
		;;
		-A|--append|-C|--check)
			str_chain="${COMP_WORDS[i+1]}" str_action=${COMP_WORDS[i]}
		   	let got_action+=1
			_iptables_swap_array arr_rule_action_opts arr_tmp_opts
		;;
		-D|--delete|-I|--insert|-R|--replace)
			str_chain="${COMP_WORDS[i+1]}" str_action=${COMP_WORDS[i]} rulenum=$(_iptables_get_rulenum $i)
		   	let got_action+=1
			_iptables_swap_array arr_rule_action_opts arr_tmp_opts
		;;
		-F|--flush)
			str_chain="${COMP_WORDS[i+1]}" str_action=${COMP_WORDS[i]}
		   	let got_action+=1
			_iptables_swap_array arr_min_opts arr_tmp_opts
		;;
		-L|--list)
		   	str_chain="${COMP_WORDS[i+1]}" str_action=${COMP_WORDS[i]} rulenum=$(_iptables_get_rulenum $i)
		   	let got_action+=1
			_iptables_swap_array arr_list_opts arr_tmp_opts
		;;
		-N|--new|-X|--delete-chain)
			if [[ ${COMP_WORDS[i]} = --new && $str_target = CLUSTERIP ]]; then
				:
			else
				str_chain="${COMP_WORDS[i+1]}" str_action=${COMP_WORDS[i]}
				let got_action+=1
				_iptables_swap_array arr_min_opts arr_tmp_opts
			fi
		;;
		-P|--policy)
			str_chain="${COMP_WORDS[i+1]}" str_action=${COMP_WORDS[i]}
		   	let got_action+=1
			_iptables_swap_array arr_min_opts arr_tmp_opts
		;;
		-S|--list-rules)
			str_chain="${COMP_WORDS[i+1]}" str_action=${COMP_WORDS[i]} rulenum=$(_iptables_get_rulenum $i)
		   	let got_action+=1
			_iptables_swap_array arr_min_opts arr_tmp_opts
		;;
		-Z|--zero)
			str_chain="${COMP_WORDS[i+1]}" str_action=${COMP_WORDS[i]} rulenum=$(_iptables_get_rulenum $i)
		   	let got_action+=1
			_iptables_swap_array arr_min_opts arr_tmp_opts
		;;
		--line-numbers)
		   	rulenum=$(_iptables_get_rulenum $i)
			_iptables_swap_array arr_min_opts arr_tmp_opts
			arr_tmp_opts[${#arr_tmp_opts[@]}]="-L --list"
			arr_tmp_opts[${#arr_tmp_opts[@]}]="-n --numeric"
			arr_tmp_opts[${#arr_tmp_opts[@]}]="-x --exact"
		;;
		--set-counters) #set_counters=1
			_iptables_swap_array arr_rule_action_opts arr_tmp_opts
			arr_tmp_opts[${#arr_tmp_opts[@]}]="-A --append"
			arr_tmp_opts[${#arr_tmp_opts[@]}]="-I --insert"
		;;
	esac
done
((${#arr_cmd_matches[@]})) || arr_cmd_matches[0]="" # init with empty string so we don't run into bad subscript error

if ((got_action > 1)); then # allow only one main command
	return 0
fi
# we have a rulenumber given, under certain commands, this reduces amount of valid options
if ((rulenum)); then
	if [[ $str_action != @(-@(L|-list|S|-list-rules|I|-insert|R|-replace)) ]]; then
		_iptables_swap_array arr_min_opts arr_tmp_opts
	fi
fi

if [[ $str_jump ]]; then # remove mutual exclusive jump/goto
	case "$str_jump" in 
		-j|--jump) str_tmp=-g ;;
		-g|--goto) str_tmp=-j ;;
	esac
	for x in ${!arr_tmp_opts[@]}; do
		if [[ ${arr_tmp_opts[x]} = *$str_tmp* ]]; then
			unset arr_tmp_opts[x]
			break
		fi
	done
fi
case "$cur" in
	-*) opt_request=1 # any option is requested
		case "$prev" in # depend on previous option - terminating choices first
			@(-@(A|-append|C|-check|D|-delete|E|-rename-chain|I|-insert|N|-new|P|-policy|R|-replace|V|-version)))
				if [[ $prev = --new && $str_target = CLUSTERIP ]]; then
					:
				else
					return 0 # command option not valid at this context
				fi
			;;
			@(-@(i|-in-interface|o|-out-interface|m|-match|p|-proto|s|-source|d|-destination|t|-table|-h|--help|-set-counters)))
				return 0 # option not valid at this context
			;;
			@(--@(dport|destination-port|sport|source-port|icmp-type|icmpv6-type|tcp-option|tcp-flags)))
				return 0 # match option not valid at this context
			;;
			@(--@(add-set|del-set|match-set|comment|chunk-types|cpu|connbytes|connbytes-dir|connbytes-mode|ecn-ip-ect|helper)))
				return 0 # match option not valid at this context
			;;
			@(--@(length|mac-source|mark|pkt-type|quota|src-range|dst-range|src-type|dst-type|uid-owner|gid-owner|realm)))
				return 0 # match option not valid at this context
			;;
			@(--@(gateway|reject-with|to-destination|to-source|to-ports|to|selctx|set-class|set-mss|timeout|label|type)))
				return 0 # target option not valid at this context
			;;
			@(--@(queue-num|queue-balance|set-dscp|dscp|dscp--class|set-dscp-class|set-tos|and-tos|or-tos|xor-tos)))
				return 0 # target option not valid at this context
			;;
			@(--@(led-trigger-id|led-delay|rateest-name|rateest-interval|rateest-ewmalog|on-port|on-ip|tproxy-mark)))
				return 0 # target option not valid at this context
			;;
			@(--@(hl-set|hl-dec|hl-inc|ttl-set|ttl-dec|ttl-inc)))
				return 0 # target option not valid at this context
			;;
			@(--@(hashmode|clustermac|total-nodes|local-node|hash-init)))
				return 0 # target option not valid at this context
			;;
			@(--@(log-level|log-prefix|nflog-group|nflog-prefix|nflog-range|nflog-threshold)))
				return 0 # target option not valid at this context
			;;
		esac
		i=$(_iptables_get_cw_idx "$prev")
		if ((i > 1)); then # depend on option before previous option
			case "${COMP_WORDS[i-1]}" in
				-E|--rename-chain|-P|--policy|-R|--replace|--set-counters)
					return 0
				;;
				@(--@(add-set|del-set|match-set)))
					return 0
				;;
				--label)
					if ((${#prev} > 27 )); then return 0; fi
				;;
				--log-prefix)
					if ((${#prev} > 29 )); then return 0; fi
				;;
				--nflog-prefix)
					if ((${#prev} > 64 )); then return 0; fi
				;;
				@(--@(hl-set|hl-dec|hl-inc|ttl-set|ttl-dec|ttl-inc|nflog-group|nflog-range|nflog-threshold|timeout|total-nodes|local-node|led-delay)))
					if [[ $prev != +([[:digit:]]) ]]; then return 0; fi
				;;
				--queue-num)
					if [[ $prev != +([[:digit:]]) ]]; then return 0; fi
					if ((prev > 65535)); then return 0; fi
				;;
				@(--@(dscp|set-dscp)))
					if [[ $prev != @(+([[:digit:]])|0x+([[:xdigit:]])) ]]; then return 0; fi
					if ((prev > 63)); then return 0; fi
				;;
			esac
		fi
		case "$str_target" in
			CLUSTERIP) # CLUSTERIP rules must start with --new
				i=$(_iptables_get_cw_idx CLUSTERIP)
				if ((i > 1)); then
					if [[ ${COMP_WORDS[i+2]} && ${COMP_WORDS[i+1]} != --new ]]; then
						return 0
					fi
				fi
			;;
		esac
		# done with terminating conditions, collect information
		if ! ((got_action)); then
		   	# if we don't now the main command and haven't defined remaining options
			# while parsing existing cmdline, set option list to main command list
			((${#arr_tmp_opts[@]})) || _iptables_swap_array arr_command_opts arr_tmp_opts
		fi
		case "$cur" in # show either short or long options (single or double dash)
			-?(+([[:word:]]))) # any short-option is requested
				arr_tmp_opts=( "${arr_tmp_opts[@]/%--*/}" )
			;;
		--?(+([[:word:]]))*) # any long-option is requested
				arr_tmp_opts=( "${arr_tmp_opts[@]/#-* }" )
			;;
		esac
		if ((${#COMP_WORDS[@]} > 2)); then # we got one option, so remove options that are mutual exclusive to all others
			for i in ${!arr_tmp_opts[@]}; do
				if [[ ${arr_tmp_opts[i]} = @(-@(V|-version)) ]]; then
					unset arr_tmp_opts[i]
					break
				fi
			done
		fi
		# from here we start to set a compreply
		# TODO: exclude mutual exclusive match and target options from compreply
		if _iptables_is_option "$prev"; then
			COMPREPLY=( $( compgen -W '${arr_tmp_opts[@]}' -- $cur ) )
		elif _iptables_is_target "$prev"; then
			if [[ $prev != @(ACCEPT|DROP|NOTRACK|TRACE) ]]; then # targets with no option
				COMPREPLY=( $( compgen -W '$(_iptables_get_target_options "$prev") -h --help' -- $cur ) )
			fi
		elif _iptables_is_match "$prev"; then
			COMPREPLY=( $( compgen -W '$(_iptables_get_match_options "$prev") -h --help' -- $cur ) )
		else
			case "$(_iptables_last_is)" in
				target)
					if [[ $str_target != @(ACCEPT|DROP|NOTRACK|TRACE) ]]; then # targets with no option
						COMPREPLY=( $( compgen -W '$(_iptables_get_target_options "$str_target") ${arr_tmp_opts[@]}' -- $cur ) )
					fi
				;;
				match)
					COMPREPLY=( $( compgen -W '$(_iptables_get_match_options "${arr_cmd_matches[${#arr_cmd_matches[@]}-1]}") ${arr_tmp_opts[@]}' -- $cur ) )
				;;
				option)
					COMPREPLY=( $( compgen -W '${arr_tmp_opts[@]}' -- $cur ) )
				;;
			esac
		fi
		if ! ((${#COMPREPLY[@]})); then # by default display all options if no reply was previously found
			COMPREPLY=( $( compgen -W '${arr_tmp_opts[@]}' -- $cur ) )
		fi
	;;
	*) # not an option
		if [[ -z $cur ]] && ((${#COMP_WORDS[@]} == 2)); then # no option given, present main command list first
			COMPREPLY=( ${arr_command_opts[@]} )
			return 0
		fi
		case "$prev" in # depend on previous option
			@(-@(A|-append|C|-check|D|-delete|F|-flush|I|-insert|L|-list|S|-list-rules|X|-delete-chain|Z|-zero))) # chain name expected next
				COMPREPLY=( $( compgen -W '$(_iptables_get_builtin_chains_by_table $str_table) \
					$(_iptables_get_user_chains $str_table)' -- $cur ) )
			   	return 0
			;;
			-E|--rename-chain|-R|--replace) # retrieve existing chains
				COMPREPLY=( $( compgen -W '$(_iptables_get_user_chains $str_table)' -- $cur ) )
				return 0
			;;
			-P|--policy)
				COMPREPLY=( $( compgen -W '$(_iptables_get_builtin_chains_by_table $str_table)' -- $cur ) )
				return 0
			;;
			-m|--match) arr_tmp=()
#				# do not show matches already used (except those explicitly defined for multiple usage)
#				for str_tmp in $(_iptables_get_match_by_table $str_table); do
#					for str_c in ${arr_cmd_matches[@]}; do
#						if [[ $str_tmp = $str_c ]]; then
#							for x in ${!arr_global_matches[@]}; do
#								if [[ $str_c = ${arr_global_matches[x]%% *} ]]; then
#									arr_tmp[${#arr_tmp[@]}]="$str_tmp"
#									break
#								fi
#							done
#							continue 2
#						fi
#					done
#					arr_tmp[${#arr_tmp[@]}]="$str_tmp"
#				done
#				COMPREPLY=( $( compgen -W '${arr_tmp[@]}' -- $cur ) )
				COMPREPLY=( $( compgen -W '$(_iptables_get_match_by_table $str_table)' -- $cur ) )
				return 0
			;;
			-i|--in-interface|-o|--out-interface)
				COMPREPLY=( $( compgen -W '$(_iptables_get_ifnames)' -- $cur ) )
				return 0
			;;
			-g|--goto)
				COMPREPLY=( $( compgen -W '$(_iptables_get_user_chains $str_table)' -- $cur ) )
				return 0
			;;
			-j|--jump)
				COMPREPLY=( $( compgen -W '$(_iptables_get_target_by_table $str_table) \
				   	$(_iptables_get_user_chains $str_table)' -- $cur ) )
				return 0
			;;
			-p|--proto)
				COMPREPLY=( $( compgen -W '$(_iptables_get_protocols)' -- $cur ) )
				return 0
			;;
			-t|--table)
				COMPREPLY=( $( compgen -W '${arr_tables[@]}' -- $cur ) )
				return 0
			;;
			-h|--help|-V|--version)
				return 0
			;;
			@(--@(add-set|del-set|match-set)))
				COMPREPLY=( $( compgen -W '$(_iptables_get_setnames)' -- $cur ) )
				return 0
			;;
			@(--@(dport|destination-port|sport|source-port|on-port)))
				COMPREPLY=( $( compgen -W '$(_iptables_get_services)' -- $cur ) )
				return 0
			;;
			--icmp-type)
				COMPREPLY=( $( compgen -W '${arr_icmp_types[@]//,/ }' -- $cur ) )
				return 0
			;;
			--icmpv6-type)
				COMPREPLY=( $( compgen -W '${arr_icmp6_types[@]//,/ }' -- $cur ) )
				return 0
			;;
			--reject-with)
				case "$str_app" in
					iptables)
						COMPREPLY=( $( compgen -W 'icmp-net-unreachable icmp-host-unreachable\
						   	icmp-port-unreachable icmp-proto-unreachable icmp-net-prohibited\
						   	icmp-host-prohibited icmp-admin-prohibited tcp-reset' -- $cur ) )
					;;
					ip6tables)
						COMPREPLY=( $( compgen -W 'icmp6-no-route no-route icmp6-adm-prohibited\
						   	adm-prohibited icmp6-addr-unreachable addr-unreach\
						   	icmp6-port-unreachable port-unreach tcp-reset' -- $cur ) )
					;;
				esac
				return 0
			;;
			--chunk-types)
				COMPREPLY=( $( compgen -W 'all any only' -- $cur ) )
				return 0
			;;
			--cpu)
				COMPREPLY=( $( compgen -W '$(_iptables_get_cpuinfo)' -- $cur ) )
				return 0
			;;
			--connbytes-dir)
				COMPREPLY=( $( compgen -W 'original reply both' -- $cur ) )
				return 0
			;;
			--connbytes-mode)
				COMPREPLY=( $( compgen -W 'packets bytes avgpkt' -- $cur ) )
				return 0
			;;
			--ecn-ip-ect)
				COMPREPLY=( $( compgen -W '0 1 2 3' -- $cur ) )
				return 0
			;;
			--hashmode)
				COMPREPLY=( $( compgen -W 'sourceip sourceip-sourceport sourceip-sourceport-destport' -- $cur ) )
				return 0
			;;
			--uid-owner)
				COMPREPLY=( $( compgen -u -- $cur ) )
				return 0
			;;
			--gid-owner)
				COMPREPLY=( $( compgen -g -- $cur ) )
				return 0
			;;
			--log-level)
				COMPREPLY=( $( compgen -W 'alert crit debug emerg err info notice warning' -- $cur ) )
				return 0
			;;
			--nflog-group)
				str_tmp=$(set +f; cd /proc/sys/net/netfilter/nf_log/ && printf "%s\n" *)
				COMPREPLY=( $( compgen -W '$str_tmp' -- $cur ) )
				return 0
			;;
			--pkt-type)
				COMPREPLY=( $( compgen -W 'unicast broadcast multicast' -- $cur ) )
				return 0
			;;
			--realm)
				COMPREPLY=( $( compgen -W '$(_iptables_get_realms)' -- $cur ) )
				return 0
			;;
			--src-type|--dst-type)
				COMPREPLY=( $( compgen -W 'UNSPEC UNICAST LOCAL BROADCAST ANYCAST MULTICAST \
					BLACKHOLE UNREACHABLE PROHIBIT THROW NAT XRESOLVE' -- $cur ) )
				return 0
			;;
			--type)
				COMPREPLY=( $( compgen -W 'accept drop reject' -- $cur ) )
				return 0
			;;
			--dscp-class|--set-dscp-class)
				COMPREPLY=( $( compgen -W 'BE EF AF11 AF12 AF13 AF21 AF22 AF23 AF31 AF32 AF33 AF41 AF42 AF42 CS1 CS2 CS3 Cs4' -- $cur ) )
				return 0
			;;
			--rateest-interval|--rateest-ewmalog)
				if [[ $cur = +([[:digit:]])?(.*([[:digit:]]))*([[:alpha:]]) ]]; then # glob not perfect, requires more work
					COMPREPLY=( $( compgen -W '${cur//[[:alpha:]]/}s ${cur//[[:alpha:]]/}ms ${cur//[[:alpha:]]/}us' -- $cur ) )
					return 0
				fi
			;;
			--set-tos)
				if [[ $str_app = iptables ]]; then
					COMPREPLY=( $( compgen -W 'Minimize-Delay Maximize-Throughput Maximize-Reliability Minimize-Cost Normal-Service' -- $cur ) )
					return 0
				fi
			;;
			DATA) # sctp match
				COMPREPLY=( I U B E i u b e )
				return 0
			;;
			ABORT|SHUTDOWN_COMPLETE) # sctp match
				COMPREPLY=( T t )
				return 0
			;;
		esac
		i=$(_iptables_get_cw_idx "$prev")
		if ((i > 1)); then # depend on option before previous option
			case "${COMP_WORDS[i-1]}" in
				--chunk-types)
					compopt -o nospace
					COMPREPLY=( $( compgen -W 'DATA ABORT SHUTDOWN_COMPLETE' -- $cur ) )
					return 0
				;;
				-P|--policy)
					COMPREPLY=( $( compgen -W 'ACCEPT DROP' -- $cur ) )
					return 0
				;;
				--add-set|--del-set|--match-set)
					COMPREPLY=( $( compgen -W 'src dst' -- $cur ) )
					compopt -o nospace
					return 0
				;;
			esac
		fi
	;;
esac

if ((${#COMPREPLY[@]})); then # post process the reply
	if ((opt_request)); then # only run the option de-dupe if an option was requested
		for ((i=1; i < ${#COMP_WORDS[@]}; i++)); do
			[[ ${COMP_WORDS[i]} = @(-|--|"") ]] || [[ ${COMP_WORDS[i]} != -?(-)?* ]] && continue
				for y in ${!arr_opts[@]}; do # remove short or long option if one of them is given
					set -- ${arr_opts[y]}
					if [[ ${COMP_WORDS[i]} = @($1|$2) ]]; then
						for x in ${!COMPREPLY[@]}; do
							if [[ ${COMPREPLY[x]} = @($1|$2) ]]; then
								if [[ ${COMP_WORDS[i]} = @(-@(m|-match)) ]]; then # options allowed multiple times
									if [[ ${COMPREPLY[x]} = $1 ]]; then
										COMPREPLY[x]="${COMPREPLY[x]%$2}"
									elif [[ ${COMPREPLY[x]} = $2 ]]; then
										COMPREPLY[x]="${COMPREPLY[x]#$1}"
									fi
								else
									unset COMPREPLY[x]
								fi
								continue 3 # no need to de-dupe anymore, so we move one
							fi
						done
					fi
				done
			[[ ${COMP_WORDS[i]} = @(-@(m|-match|-match-set|-return-nomatch|-chunk-types|-mark)) ]] && continue # options allowed multiple times
			for x in ${!COMPREPLY[@]}; do # list an option only once
				if [[ ${COMP_WORDS[i]} = ${COMPREPLY[x]} ]]; then
					unset COMPREPLY[x]
					break
				fi
			done
		done
	fi
else
	_iptables_bash_default_compl "$cur"
fi

case "${COMPREPLY[0]}" in
	--modprobe=)
		compopt -o nospace
	;;
esac

if [[ $_DEBUG_IPT_COMPL ]]; then
	printf "COMPREPLY:\n"
	printf "<%s>\n" "${COMPREPLY[@]}"
fi
}
complete -F _iptables_complete iptables ip6tables

