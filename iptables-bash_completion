#!/bin/bash

# -----------------------------------------------------------------
# Programmable completion code for iptables (netfilter.org)
#
# https://github.com/AllKind/iptables-bash_completion
# https://sourceforge.net/projects/ipt-bashcompl
# -----------------------------------------------------------------

# Copyright (C) 2013 AllKind (AllKind@fastest.cc)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# -----------------------------------------------------------------
# Tested with iptables versions:
# 1.4.16.3
# -----------------------------------------------------------------
# Requirements:
#
# The bash completion package version 2.0 or greater is recommended.
# http://bash-completion.alioth.debian.org/
#
# If the package is not available, things might not be so reliable.
# Also the colon (if there) is removed from COMP_WORDBREAKS.
# This alteration is globally, which might affect other completions,
# if they don't take care of it themselves.
#
# -----------------------------------------------------------------
# Installation:
#
# Put it into ~/.bash_completion or /etc/bash_completion.d/
#
# -----------------------------------------------------------------
#
# Version 1.0-pre-alpha
#
# -----------------------------------------------------------------

shopt -s extglob

# -----------------------------------------------------------------
# FUNCTIONS
# -----------------------------------------------------------------

_iptables_bash_default_compl() { # taken from examples - modified by me
# call with the word to be completed as $1
local t
if [[ $1 == \$\(* ]]; then # command substitution
	t=${1#??}
	COMPREPLY=( $(compgen -c -P '$(' $t) )
elif [[ $1 == \$\{* ]]; then # variables with a leading `${'
	t=${1#??}
	COMPREPLY=( $(compgen -v -P '${' -S '}' $t) )
elif [[ $1 == \$* ]]; then # variables with a leading `$'
	t=${1#?}
	COMPREPLY=( $(compgen -v -P '$' $t ) )
elif [[ "$1" == *@* ]]; then # hostname
	t=${1#*@}
	COMPREPLY=( $( compgen -A hostname $t ) )
elif [[ $1 == *[*?[]* ]]; then # sh-style glob pattern
	COMPREPLY=( $( compgen -G "$1" ) )
# ksh-style extended glob pattern - must be complete
elif shopt -q extglob && [[ $1 == *[?*+\!@]\(*\)* ]]; then
	COMPREPLY=( $( compgen -G "$1" ) )
fi
}

# -----------------------------------------------------------------
# iptables functions
# -----------------------------------------------------------------
_iptables_select_on_inet_family() {
if [[ $1 != all ]]; then # select match according to current calling app
	if [[ $1 = v4 && $str_app = ip6tables ]]; then
		return 1
	elif [[ $1 = v6 && $str_app = iptables ]]; then
		return 1
	fi
fi
return 0
}

_iptables_is_option() {
local -i opt_idx
local str_q="$1"
[[ $str_q = -* ]] || return
if [[ $str_q = --new && $str_target = CLUSTERIP ]]; then # CLUSTERIP also has --new
	return 1
fi
if [[ $str_q = --proto ]] && ((${#arr_cmd_matches[@]})) && \
	[[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]
then # policy match also has --proto
	return 1
fi
for opt_idx in ${!arr_opts[@]}; do set -- ${arr_opts[opt_idx]}
	while (($#)); do
		[[ $1 = $str_q ]] && return
		shift
	done
done
return 1
}

_iptables_is_target() {
local -i idx
local str_x="$1"
[[ $str_x = @(""|-*|*/*) ]] && return 1
for idx in ${!arr_targets[@]}; do
	[[ ${arr_targets[idx]%% *} = $str_x ]] && return
done
return 1
}

_iptables_is_match() {
local -i idx
local str_x="$1"
[[ $str_x = @(""|-*|*/*) ]] && return 1
for idx in ${!arr_matches[@]}; do
	[[ ${arr_matches[idx]%% *} = $str_x ]] && return
done
return 1
}

_iptables_get_match_by_table() {
local -i idx
local str_x="$1" # table name
for idx in ${!arr_matches[@]}; do
	set -- ${arr_matches[idx]}
	_iptables_select_on_inet_family $2 || continue
	if [[ $3 = all ]] || [[ ${3//,/ } = *${str_x}* ]]; then # valid in current table
		if [[ $str_proto ]]; then
			case "$1" in
				connlimit|ecn|osf|tcp|tcpmss)
					[[ $str_proto = tcp ]] || continue
				;;
				multiport)
					[[ $str_proto = @(tcp|udp|dccp|sctp) ]] || continue
				;;
				icmp|udp|tcp|ah|esp|dccp|sctp)
					[[ $str_proto = $1 ]] || continue
				;;
			esac
		fi
		printf "%s\n" "$1"
	fi
done
}

_iptables_get_target_by_table() {
local -i idx
local str_x="$1" # table
for idx in ${!arr_targets[@]}; do set -- ${arr_targets[idx]}
	_iptables_select_on_inet_family $2 || continue
	if [[ $3 = all ]] || [[ ${3//,/ } = *${str_x}* ]]; then # allowed in table
		if [[ $str_proto ]]; then
			case "$1" in
				ECN|TCPMSS|TCPOPTSTRIP)
					[[ $str_proto = tcp ]] || continue
				;;
#				XY)
#					[[ $str_proto = @(tcp|udp) ]] || continue
#				;;
			esac
		fi
		printf "%s\n" "$1"
	fi
done
}

_iptables_get_builtin_chains_by_table() {
local str_cmd str_name str_rest
while read -r str_cmd str_name str_rest; do
	[[ $str_cmd = -P ]] && printf "%s\n" "$str_name" || return 0
done < <(iptables -S -t $1 2>/dev/null)
}

_iptables_get_user_chains() {
local str_cmd str_name str_rest
while read -r str_cmd str_name str_rest; do
	if [[ $str_cmd = -N ]]; then printf "%s\n" "$str_name"
	elif [[ $str_cmd = -A ]]; then return 0
	fi
done < <(iptables -S -t $1 2>/dev/null)
}

_iptables_get_target_options() {
local -i idx
local str_x="$1"
for idx in ${!arr_targets[@]}; do set -- ${arr_targets[idx]}
	if [[ $1 = $str_x ]]; then
		_iptables_select_on_inet_family $2 || continue
		shift 3
		printf "%s\n" "$*"
		return 0
	fi
done
}

_iptables_get_match_options() {
local -i idx cix rix xix got_arg 
local str_match="$1" str_opt str_tmp
local arr_reply=()
for idx in ${!arr_matches[@]}; do set -- ${arr_matches[idx]}
	if [[ $1 = $str_match ]]; then arr_reply=()
		_iptables_select_on_inet_family $2 || continue
		shift 3
		for str_opt in "$@"; do
			if [[ $str_opt = *,* ]]; then # redundant option names
				for str_tmp in ${str_opt//,/ }; do # exclude the aliases from listing
					if _iptables_is_in_compwords $str_tmp; then
						continue 2
					fi
				done
			fi
			arr_reply[${#arr_reply[@]}]="$str_opt"
		done
		for rix in ${!arr_reply[@]}; do str_opt="${arr_reply[rix]}"
			# find options which can be used globally (multiple use of match), but filter them out
			# if we already used them in the current active match
			for xix in ${!arr_global_matches[@]}; do # retrieve list of global options
				set -- ${arr_global_matches[xix]}
				if [[ $str_match = $1 ]]; then shift
					for str_tmp in "$@"; do
						if [[ $str_tmp = $str_opt ]]; then got_arg=0
							for ((cix=${#words[@]}-1; cix > 0; cix--)); do
								if [[ -z ${words[cix]} ]]; then continue
								elif [[ ${words[cix]} != $str_opt && ${words[cix]} != $str_match ]]; then
								   if [[ ${words[cix]} = -* ]]; then
									   _iptables_is_option "${words[cix]}" && break # another option
								   else
										if _iptables_is_match "${words[cix]}"; then break # another match
										elif _iptables_is_target "${words[cix]}"; then break # another target
										fi
								   fi
								elif [[ ${words[cix]} = $str_opt ]]; then got_arg=1 # got the option
								elif [[ ${words[cix]} = $str_match && ${words[cix-1]} = @(-m|--match|-p|--proto) ]]
								then # got the match
									((got_arg)) || break # but don't have arg
									unset arr_reply[rix]
								fi
							done
						fi
					done
				fi
			done
		done
		printf "%s\n" "${arr_reply[*]//,/ }"
		return 0
	fi
done
}

_iptables_get_rulenum() {
[[ ${words[${1}+2]} = +([[:digit:]]) ]] && printf "%d\n" ${words[${1}+2]}
}

#_iptables_last_is_option() {
#local -i idx
#for ((idx=${#words[@]}-1; idx > 0; idx--)); do
#	if [[ -z ${words[idx]} || ${words[idx]} != @(-*) ]]; then continue
#	elif _iptables_is_option "${words[idx]}"; then return 0
#	fi
#done
#return 1
#}

#_iptables_last_is_match() {
#local -i idx
#for ((idx=${#words[@]}-1; idx > 0; idx--)); do
#	if [[ -z ${words[idx]} ]]; then continue
#	elif [[ ${words[idx]} != -* ]]; then
#		if _iptables_is_match "${words[idx]}" && \
#			[[ ${words[idx-1]} = @(-m|--match|-p|--proto) ]]
#		then
#			return 0
#		elif _iptables_is_target "${words[idx]}"; then
#			return 1
#		fi
#	elif [[ ${words[idx]} = -* ]] && _iptables_is_option "${words[idx]}"
#	then return 1
#	fi
#done
#return 1
#}
#
#_iptables_last_is_target() {
#local -i idx
#for ((idx=${#words[@]}-1; idx > 0; idx--)); do
#	if [[ -z ${words[idx]} ]]; then continue
#	elif [[ ${words[idx]} != -* ]]; then
#		if _iptables_is_target "${words[idx]}" && \
#			[[ ${words[idx]} = $str_target && ${words[idx-1]} = @(-@(j|-jump|g|-goto)) ]]
#		then return 0
#		elif _iptables_is_match "${words[idx]}" && [[ ${words[idx-1]} = @(-m|--match|-p|--proto) ]]
#		then return 1
#		fi
#	elif [[ ${words[idx]} = -* ]] && _iptables_is_option "${words[idx]}"
#	then return 1
#	fi
#done
#return 1
#}

_iptables_last_is() {
local -i idx
for ((idx=${#words[@]}-1; idx > 0; idx--)); do
	[[ -z ${words[idx]} || ${words[idx]} = - ]] && continue
	if [[ ${words[idx]} = -?* ]]; then
		if _iptables_is_option "${words[idx]}"; then
			if [[ ${words[idx]} = --proto ]] && ((${#arr_cmd_matches[@]})) && \
				[[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]
			then continue
			fi
			printf "%s\n" "option"
			return 0
		fi
	else
		if _iptables_is_target "${words[idx]}" && \
			[[ ${words[idx]} = $str_target && ${words[idx-1]} = @(-@(j|-jump|g|-goto)) ]]
		then printf "%s\n" "target"
			return 0
		elif _iptables_is_match "${words[idx]}" && \
			[[ ${words[idx-1]} = @(-@(m|-match|p|-proto)) ]]
		then
			if [[ ${words[idx-1]} = --proto ]] && ((${#arr_cmd_matches[@]})) && \
				[[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]
			then continue
			fi
			printf "%s\n" "match"
			return 0
		fi
	fi
done
}

# -----------------------------------------------------------------
# retrieve arguments data
# -----------------------------------------------------------------
_iptables_get_ifnames() {
while read -r; do
	REPLY="${REPLY#*: }"
	printf "%s\n" ${REPLY%%:*}
done < <(PATH=${PATH}:/sbin command ip -o link show)
}

_iptables_get_protocols() {
local str_name rest
while read -r str_name rest; do
	[[ $str_name = *([[:blank:]])#* ]] && continue
	printf "%s\n" "$str_name"
done < /etc/protocols
}

_iptables_get_services() {
local str_name rest
while read -r str_name rest; do
	[[ $str_name = *([[:blank:]])#* ]] && continue
	printf "%s\n" "$str_name"
done < /etc/services
}

_iptables_get_setnames() {
PATH=${PATH}:/sbin command ipset -n list
}

_iptables_get_tc_classes() { # TODO: query by interface?
local str_dev c t str_class rest
while read -r; do [[ $REPLY = lo ]] && continue
	for str_dev in $REPLY; do
		while read c t str_class rest; do
			[[ $str_class = +([[:digit:]]):+([[:digit:]]) ]] && printf "%s\n" "$str_class"
		done < <(PATH=${PATH}:/sbin command tc class show dev $str_dev)
	done
done < <(_iptables_get_ifnames)
}

_iptables_get_realms() {
local str_x
while read -r; do
	[[ $REPLY = *([[:space:]])#* ]] && continue
	if [[ $REPLY = *([[:space:]])+([[:digit:]])+([[:space:]])+([[:graph:]])* ]]; then
		str_x="${REPLY#*+([[:digit:]])+([[:space:]])}"
		printf "%s\n" "${str_x%#*}"
	fi
done </etc/iproute2/rt_realms
}

_iptables_compl_port_range() { # complete named port ranges
local str_prefix="$1" lcur="${1#*:}"
str_prefix=${str_prefix%"$lcur"}
compgen -P "$str_prefix" -W '$(_iptables_get_services)' -- "$lcur"
}

# -----------------------------------------------------------------
# misc functions
# -----------------------------------------------------------------
_iptables_get_cw_idx() {
local -i idx index=0
for idx in ${!COMP_WORDS[@]}; do
	if [[ ${COMP_WORDS[idx]} = $1 ]]; then index=$idx
		# we don't break, as args could be used double.
		# choosing the last one, is ugly but less worse i think
		# TODO: find a solution
#		printf "%d\n" "$idx"
#		return 0
	fi
done
printf "%d\n" $((index ? index : -1))
}

_iptables_is_in_compwords() {
local -i cix
for ((cix=1; cix < ${#words[@]}; cix++)); do
	[[ $1 = ${words[cix]} ]] && return
done
}

_iptables_swap_array() {
local -i idx
local s_arr=$1 d_arr=$2 
eval $d_arr'=()'
eval 'for idx in ${!'$s_arr'[@]};do '$d_arr'[$idx]="${'$s_arr'[$idx]}";done'
}

_iptables_build_comma_list() {
local lcur="$1" lmatch="" rlist="" prefix=""
shift
local arr_list=("${@}")
local str_pat=$(IFS=\|; printf "%s" "${arr_list[*]}")
compopt -o nospace
if [[ $lcur ]]; then
	if [[ ${lcur} = @($str_pat) ]]; then
		prefix="${lcur}," rlist="$lcur" lmatch=""
	elif [[ ${lcur:$((${#lcur}-1))} = , ]]; then
		prefix="${lcur}" rlist="$lcur" lmatch=""
	elif [[ ${lcur:$((${#lcur}-1))} != , ]]; then
		if [[ ${lcur##*,} != @($str_pat) ]]; then
			if [[ $lcur = *,* ]]; then
				prefix="${lcur%${lcur##*,}}" rlist="${lcur%${lcur##*,}}" lmatch="${lcur##*,}"
			else
				prefix="${lcur%${lcur##*,}}" rlist="${lcur%${lcur##*,}}" lmatch="${lcur}"
			fi
			[[ $prefix && ${prefix:$((${#prefix}-1))} != , ]] && prefix="${prefix},"
		else
			prefix="${lcur}," rlist="$lcur" lmatch=""
		fi
	fi
	for x in ${rlist//,/ }; do
		for i in ${!arr_list[@]}; do
			if [[ $x = ${arr_list[i]} ]]; then
				unset arr_list[i]
			fi
		done
	done
fi
((${#arr_list[@]} == 1)) && compopt +o nospace
COMPREPLY=( $( compgen -P "${prefix}" -W '${arr_list[@]}' -- "$lmatch" ) )
}

_iptables_build_ipset_flag_list() {
local lcur="$1" lmatch="" prefix=""
shift
local arr_list=("${@}")
local str_pat=$(IFS=\|; printf "%s" "${arr_list[*]}")
compopt -o nospace
if [[ $lcur ]]; then
	if [[ ${lcur} = @($str_pat) ]]; then
		prefix="${lcur}," lmatch=""
	elif [[ ${lcur:$((${#lcur}-1))} = , ]]; then
		prefix="${lcur}" lmatch=""
	elif [[ ${lcur:$((${#lcur}-1))} != , ]]; then
		if [[ ${lcur##*,} != @($str_pat) ]]; then
			if [[ $lcur = *,* ]]; then
				prefix="${lcur%${lcur##*,}}" lmatch="${lcur##*,}"
			else
				prefix="${lcur%${lcur##*,}}" lmatch="${lcur}"
			fi
			[[ $prefix && ${prefix:$((${#prefix}-1))} != , ]] && prefix="${prefix},"
		else
			prefix="${lcur}," lmatch=""
		fi
	fi
fi
(($(IFS=,; set -- ${prefix}; printf "%d\n" $#) == 5)) && compopt +o nospace
COMPREPLY=( $( compgen -P "${prefix}" -W '${arr_list[@]}' -- "$lmatch" ) )
}

# -----------------------------------------------------------------
# main function
# -----------------------------------------------------------------
_iptables_complete() {
local cur prev cword words
local -i i=x=y=got_bashcompl=0
local -i opt_request=got_action=set_counters=rulenum=policy_match_index=inline_help=0
local ipt_version str_chain str_target str_jump str_action str_proto str_help str_tmp str_var
local str_table="filter" str_chain str_target str_jump str_action str_proto str_help str_tmp str_var
local arr_tmp_opts=() arr_cmd_matches=() arr_cmd_opts=() arr_tmp=()
local -r str_app="${COMP_WORDS[0]//*\//}"

if ((${BASH_VERSINFO[0]} < 3)); then
	return 0
fi

# old iptables versions, which don't have the `-S' option are not supported
"$str_app" -S OUTPUT 1 &>/dev/null || return

# iptables version TODO: checks re version
ipt_version="$("$str_app" --version)"
ipt_version="${ipt_version#$str_app v}"

local arr_opts=(
"-d --destination"
"-f --fragment"
"-g --goto"
"-h --help"
"-i --in-interface"
"-j --jump"
"-m --match"
"-n --numeric"
"-o --out-interface"
"-p --proto"
"-s --source"
"-t --table"
"-v --verbose"
"-x --exact"
"-A --append"
"-C --check"
"-D --delete"
"-E --rename-chain"
"-F --flush"
"-I --insert"
"-L --list"
"-N --new"
"-P --policy"
"-R --replace"
"-S --list-rules"
"-V --version"
"-X --delete-chain"
"-Z --zero"
--line-numbers
--set-counters
--modprobe=
)

local arr_command_opts=(
"-h --help"
"-j --jump"
"-m --match"
"-t --table"
"-v --verbose"
"-A --append"
"-C --check"
"-D --delete"
"-E --rename-chain"
"-F --flush"
"-I --insert"
"-L --list"
"-N --new"
"-P --policy"
"-R --replace"
"-S --list-rules"
"-V --version"
"-X --delete-chain"
"-Z --zero"
--set-counters
)

local arr_rule_action_opts=(
"-d --destination"
"-f --fragment"
"-g --goto"
"-i --in-interface"
"-j --jump"
"-m --match"
"-o --out-interface"
"-p --proto"
"-s --source"
"-t --table"
"-v --verbose"
--modprobe=
)

local arr_min_opts=(
"-t --table"
"-v --verbose"
)

local arr_list_opts=(
"-n --numeric"
"-t --table"
"-v --verbose"
"-x --exact"
--line-numbers
)

local arr_tables=(
filter
mangle
nat
security
raw
)

local arr_global_matches=(
"connmark --mark"
"mark --mark"
"sctp --chunk-types"
"set --match-set --return-nomatch"
)

local arr_proto_defs=(
"icmp 1"
"tcp 6"
"udp 17"
"esp 50"
"ah 51"
"sctp 132"
)

# target-name all|v4|v6 all|table1,table2,... option [...]
local arr_targets=(
"ACCEPT all all"
"AUDIT all all --type" # TODO: audit drop in nat table, really valid?
"CT all all --notrack --helper --ctevents --expevents --zone --timeout" # TODO: mutual exclusive options, get zone-ids?, get timeout policy names
"DROP all filter,mangle,security,raw"
"CHECKSUM all mangle --checksum-fill"
"CLASSIFY all all --set-class"
"CLUSTERIP v4 mangle --new --hashmode --clustermac --total-nodes --local-node --hash-init"
"CONNMARK all all --save-mark --restore-mark --mask --nfmask --ctmask \
	--set-xmark --and-mark --or-mark --xor-mark --set-mark" # TODO: mutual exclusive options | save|restore-mark only valid in mangle table
"CONNSECMARK all mangle,security --save --restore"
"ECN all mangle --ecn-tcp-remove"
"DNAT v4 nat --to-destination --random --persistent"
"DSCP all mangle --set-dscp --set-dscp-class" # TODO: mutual exclusive options
"HL v6 mangle --hl-set --hl-dec --hl-inc" # TODO: mutual exclusive options
"HMARK all all --hmark-tuple --hmark-mod --hmark-offset --hmark-src-prefix \
	--hmark-dst-prefix --hmark-sport-mask --hmark-dport-mask --hmark-spi-mask \
	--hmark-proto-mask --hmark-rnd" # TODO: required options | mutual exclusive options | check used options form -tuple completion
"IDLETIMER all all --timeout --label"
"LED all all --led-trigger-id --led-delay --led-always-blink"
"LOG all all --log-level --log-prefix --log-tcp-sequence --log-tcp-options --log-ip-options --log-uid"
"MASQUERADE v4 nat --to-ports --random" # TODO: maybe check if proto is tcp|udp
"NETMAP v4 nat --to"
"NFLOG all all --nflog-group --nflog-prefix --nflog-range --nflog-threshold"
"NFQUEUE all all --queue-num --queue-balance --queue-bypass" # TODO: mutual exclusive options
"NOTRACK all raw"
"RATEEST all all --rateest-name --rateest-interval --rateest-ewmalog"
"REDIRECT v4 nat --to-ports --random" # TODO: maybe check if proto is tcp|udp
"REJECT all filter --reject-with"
"SECMARK all mangle,security --selctx" # TODO: retrieve security_context
"SET all all --add-set --del-set --timeout --exist"
"SNAT v4 nat --to-source --random --persistent"
"TEE all all --gateway" # TODO: really valid in all tables? cmdline does not forbid it
"TCPMSS all mangle --set-mss --clamp-mss-to-pmtu"
"TCPOPTSTRIP all mangle --strip-options"
"TOS all mangle --set-tos --and-tos --or-tos --xor-tos" # TODO: mutual exclusive options
"TPROXY all mangle --on-port --on-ip --tproxy-mark" # TODO: maybe check if proto is tcp|udp
"TRACE all raw"
"TTL v4 mangle --ttl-set --ttl-dec --ttl-inc" # TODO: mutual exclusive options
"ULOG v4 all --ulog-nlgroup --ulog-prefix --ulog-cprange --ulog-qthreshold"
)

# match-name all|v4|v6 all|table1,table2,... option[,alias] [...]
local arr_matches=(
"tcp all all --source-port,--sport --destination-port,--dport --tcp-flags --syn --tcp-option"
"udp all all --source-port,--sport --destination-port,--dport"
"icmp v4 all --icmp-type"
"icmp6 v6 all --icmpv6-type"
"addrtype all all --src-type --dst-type --limit-iface-in --limit-iface-out"
"ah v4 all --ahspi"
"ah v6 all --ahspi --ahlen --ahres"
"cluster all all --cluster-total-nodes --cluster-local-node --cluster-local-nodemask --cluster-hash-seed"
"comment all all --comment"
"connbytes all all --connbytes --connbytes-dir --connbytes-mode"
"connlimit all all --connlimit-upto --connlimit-above --connlimit-mask --connlimit-saddr --connlimit-daddr" # TODO: mutual exclusive options | valid in all tables?
"connmark all all --mark"
"conntrack all all --ctstate --ctproto --ctorigsrc --ctorigdst --ctreplsrc \
	--ctrepldst --ctorigsrcport --ctorigdstport --ctreplsrcport \
	--ctrepldstport --ctstatus --ctexpire --ctdir"
"cpu all all --cpu"
"dccp all all --source-port,--sport --destination-port,--dport --dccp-types --dccp-option"
"devgroup all all --src-group --dst-group" # TODO: retrieve names of device groups
"dscp all all --dscp --dscp-class" # TODO: mutual exclusive options
"dst v6 all --dst-len --dst-opts" # TODO: valid values, --dst-opts value only twice?
"ecn all all --ecn-tcp-cwr --ecn-tcp-ece --ecn-ip-ect"
"esp all all --espspi"
"eui64 v6 all"
"frag v6 all --fragid --fraglen --fragres --fragfirst --fragmore --fraglast"
"hashlimit all all --hashlimit-upto --hashlimit-above --hashlimit-burst --hashlimit-mode \
	--hashlimit-srcmask --hashlimit-dstmask --hashlimit-name --hashlimit-htable-size \
	--hashlimit-htable-max --hashlimit-htable-expire --hashlimit-htable-gcinterval" # TODO: mutual exclusive options | required options
"helper all all --helper" # TODO: check if we can retrieve list of helpers
"hbh v6 all --hbh-len --hbh-opts"
"hl v6 all --hl-eq --hl-gt --hl-lt"
"iprange all all --src-range --dst-range"
"ipvs all all --ipvs --vproto --vaddr --vport --vdir --vmethod --vportctl"
"length all all --length"
"mac all all --mac-source"
"mh v6 all --mh-type" # TODO: named mh-types, ip6tables -p ipv6-mh -h does not display any
"owner all all --uid-owner --gid-owner --socket-exists"
"quota all all --quota"
"limit all all --limit --limit-burst"
"mark all all --mark"
"nfacct all all --nfacct-name"
"osf all all --genre --ttl --log" # TODO: retrieve valid genre strings?
"physdev all all --physdev-in --physdev-out --physdev-is-in --physdev-is-out --physdev-is-bridged"
"pkttype all all --pkt-type"
"policy all all --dir --pol --strict --reqid --spi --proto --mode --tunnel-src --tunnel-dst --next" # TODO: mutual exclusive options, reqid value?
"realm v4 all --realm"
"recent all all --set --rsource --rdest --mask --rcheck --update --remove --seconds --reap --hitcount"
"rpfilter all mangle,raw --loose --validmark --accept-local"
"rt v6 all --rt-type --rt-segsleft --rt-len --rt-0-res --rt-0-addrs --rt-0-not-strict"
"sctp all all --source-port,--sport --destination-port,--dport --chunk-types"
"socket all all --transparent" # TODO: was --transparent option available from the beginning?
"set all all --match-set --return-nomatch"
"state all all --state"
"statistic all all --mode --probability --every --packet" # TODO: mutual exclusive options
"string all all --algo --from --to --string --hex-string" # TODO: mutual exclusive options
"tcpmss all all --mss"
"time all all --datestart --timestart --timestop --monthdays --weekdays --kerneltz" # TODO: --date[start|stop] value verification
"tos all all --tos"
"ttl v4 all --ttl-eq --ttl-gt --ttl-lt"
"u32 all all --u32"
#"unclean v4 all" # don't have it
)

local arr_icmp_types=( any
echo-reply,pong
destination-unreachable
network-unreachable
host-unreachable
protocol-unreachable
port-unreachable
fragmentation-needed
source-route-failed
network-unknown
host-unknown
network-prohibited
host-prohibited
TOS-network-unreachable
TOS-host-unreachable
communication-prohibited
host-precedence-violation
precedence-cutoff
source-quench
redirect
network-redirect
host-redirect
TOS-network-redirect
TOS-host-redirect
echo-request,ping
router-advertisement
router-solicitation
time-exceeded,ttl-exceeded
ttl-zero-during-transit
ttl-zero-during-reassembly
parameter-problem
ip-header-bad
required-option-missing
timestamp-request
timestamp-reply
address-mask-request
address-mask-reply
)
local arr_icmp6_types=(
destination-unreachable
no-route
communication-prohibited
address-unreachable
port-unreachable
packet-too-big
time-exceeded,ttl-exceeded
ttl-zero-during-transit
ttl-zero-during-reassembly
parameter-problem
bad-header
unknown-header-type
unknown-option
echo-request,ping
echo-reply,pong
router-solicitation
router-advertisement
neighbour-solicitation,neighbor-solicitation
neighbour-advertisement,neighbor-advertisement
redirect
)

COMPREPLY=()
#COMP_WORDBREAKS=$' \t\n"\'><=;|&(:'

# expecting _get_comp_words_by_ref() to exist from bash_completion
if declare -f _get_comp_words_by_ref &>/dev/null; then got_bashcompl=1
	_get_comp_words_by_ref -n : cur prev cword words || return
else # not so neat, but a workaround
	COMP_WORDBREAKS=$' \t\n"\'><=;|&('
	cur="${COMP_WORDS[COMP_CWORD]}"
	prev="${COMP_WORDS[COMP_CWORD-1]}"
	cword=$COMP_CWORD
	for i in ${!COMP_WORDS[@]}; do words[i]="${COMP_WORDS[i]}"; done
fi

#_DEBUG_IPT_COMPL=Y
if [[ $_DEBUG_IPT_COMPL ]]; then
	printf "\nCOMP_WORDBREAKS: <%s>\n" "$COMP_WORDBREAKS"
	printf "COMP_LINE: <%s>\n" "$COMP_LINE"
	printf "COMP_TYPE: <%s>\n" "$COMP_TYPE"
	printf "COMP_POINT: <%s>\n" "$COMP_POINT"
	printf "COMP_KEY: <%s>\n" "$COMP_KEY"
	printf "COMP_CWORD: <%s>\n" "$COMP_CWORD"
	printf "COMP_WORDS:\n"
	printf "<%s>\n" "${COMP_WORDS[@]}"
	printf "cur: <%s> prev: <%s>\n" "$cur" "$prev"
fi

for ((i=1; i < ${#words[@]}; i++)); do
	case ${words[i]} in
		-j|--jump|-g|--goto)
			str_jump=${words[i]} str_target="${words[i+1]}" arr_cmd_opts[${#arr_cmd_opts[@]}]=${COMP_WORDS[i]}
		;;
		-m|--match)
			arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]}
			if [[ ${words[i+1]} ]]; then
				arr_cmd_matches[${#arr_cmd_matches[@]}]="${words[i+1]}"
				[[ ${words[i+1]} = policy ]] && policy_match_index=$(($i+1))
			fi
		;;
		-p|--proto) # if proto is a known match, add it to list of matches
			arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]}
			if [[ ${words[i]} = --proto ]]; then
				if ((${#arr_cmd_matches[@]})) && [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]; then
					continue # policy match also has --proto !!DAMN!!
				fi
			fi
			str_proto="${words[i+1]}"
			if [[ ${words[i+1]} = +([[:digit:]]) ]]; then
				for x in ${!arr_proto_defs[@]}; do # translate known numeric proto specs into names
					set -- ${arr_proto_defs[x]}
					if ((words[i+1] == $2)); then
						str_proto=$1
						arr_cmd_matches[${#arr_cmd_matches[@]}]="$str_proto"
						break
					fi
				done
			else
				_iptables_is_match "${words[i+1]}" && arr_cmd_matches[${#arr_cmd_matches[@]}]="$str_proto"
			fi
		;;
		-t|--table) str_table="${words[i+1]}" arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]} ;;
		-E|--rename-chain)
			str_chain="${words[i+1]}" str_action=${words[i]}
		   	let got_action+=1
			_iptables_swap_array arr_min_opts arr_tmp_opts
		;;
		-A|--append|-C|--check)
			str_chain="${words[i+1]}" str_action=${words[i]}
		   	let got_action+=1
			_iptables_swap_array arr_rule_action_opts arr_tmp_opts
		;;
		-D|--delete|-I|--insert|-R|--replace)
			str_chain="${words[i+1]}" str_action=${words[i]} rulenum=$(_iptables_get_rulenum $i)
		   	let got_action+=1
			_iptables_swap_array arr_rule_action_opts arr_tmp_opts
		;;
		-F|--flush)
			str_chain="${words[i+1]}" str_action=${words[i]}
		   	let got_action+=1
			_iptables_swap_array arr_min_opts arr_tmp_opts
		;;
		-L|--list)
		   	str_chain="${words[i+1]}" str_action=${words[i]} rulenum=$(_iptables_get_rulenum $i)
		   	let got_action+=1
			_iptables_swap_array arr_list_opts arr_tmp_opts
		;;
		-N|--new|-X|--delete-chain)
			if [[ ${words[i]} = --new && $str_target = CLUSTERIP ]]; then
				:
			else
				str_chain="${words[i+1]}" str_action=${words[i]}
				let got_action+=1
				_iptables_swap_array arr_min_opts arr_tmp_opts
			fi
		;;
		-P|--policy)
			str_chain="${words[i+1]}" str_action=${words[i]}
		   	let got_action+=1
			_iptables_swap_array arr_min_opts arr_tmp_opts
		;;
		-S|--list-rules)
			str_chain="${words[i+1]}" str_action=${words[i]} rulenum=$(_iptables_get_rulenum $i)
		   	let got_action+=1
			_iptables_swap_array arr_min_opts arr_tmp_opts
		;;
		-Z|--zero)
			str_chain="${words[i+1]}" str_action=${words[i]} rulenum=$(_iptables_get_rulenum $i)
		   	let got_action+=1
			_iptables_swap_array arr_min_opts arr_tmp_opts
		;;
		--line-numbers)
		   	rulenum=$(_iptables_get_rulenum $i) arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]}
			_iptables_swap_array arr_min_opts arr_tmp_opts
			arr_tmp_opts[${#arr_tmp_opts[@]}]="-L --list"
			arr_tmp_opts[${#arr_tmp_opts[@]}]="-n --numeric"
			arr_tmp_opts[${#arr_tmp_opts[@]}]="-x --exact"
		;;
		--set-counters) arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]} #set_counters=1
			_iptables_swap_array arr_rule_action_opts arr_tmp_opts
			arr_tmp_opts[${#arr_tmp_opts[@]}]="-A --append"
			arr_tmp_opts[${#arr_tmp_opts[@]}]="-I --insert"
		;;
	esac
done
((${#arr_cmd_matches[@]})) || arr_cmd_matches[0]="" # init with empty string so we don't run into bad subscript error
((${#arr_cmd_opts[@]})) || arr_cmd_opts[0]="" # init with empty string so we don't run into bad subscript error
if ! ((got_action)); then
	if [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} && -z $str_target ]] && ((COMP_CWORD < 7))
	then inline_help=1
	elif [[ $str_target ]] && [[ -z ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} ]] && ((COMP_CWORD < 7))
	then inline_help=1
	fi
fi

if [[ $_DEBUG_IPT_COMPL ]]; then
	printf "arr_cmd_matches[*]: %s\n" "${arr_cmd_matches[*]}"
	printf "str_proto: %s\n" "$str_proto"
	printf "str_chain: %s\n" "$str_chain"
	printf "str_target: %s\n" "$str_target"
fi

if ((got_action > 1)); then # allow only one main command
	return 0
fi
# we have a rulenumber given, under certain commands, this reduces amount of valid options
if ((rulenum)); then
	if [[ $str_action != @(-@(L|-list|S|-list-rules|I|-insert|R|-replace)) ]]; then
		_iptables_swap_array arr_min_opts arr_tmp_opts
	fi
fi

if [[ $str_jump ]]; then # remove mutual exclusive jump/goto
	case "$str_jump" in 
		-j|--jump) str_tmp=-g ;;
		-g|--goto) str_tmp=-j ;;
	esac
	for x in ${!arr_tmp_opts[@]}; do
		if [[ ${arr_tmp_opts[x]} = *$str_tmp* ]]; then
			unset arr_tmp_opts[x]
			break
		fi
	done
fi
case "$cur" in
	-*) opt_request=1 # any option is requested
		case "$prev" in # depend on previous option - terminating choices first
			@(-@(A|-append|C|-check|D|-delete|E|-rename-chain|I|-insert|N|-new|P|-policy|R|-replace|V|-version)))
				if [[ $prev = --new && $str_target = CLUSTERIP ]]; then
					:
				else
					return 0 # command option not valid at this context
				fi
			;;
			@(-@(i|-in-interface|o|-out-interface|m|-match|p|-proto|s|-source|d|-destination|t|-table|-h|--help|-set-counters)))
				return 0 # option not valid at this context
			;;
			@(--@(dport|destination-port|sport|source-port|icmp-type|icmpv6-type|tcp-option|tcp-flags)))
				return 0 # match option not valid at this context
			;;
			@(--@(add-set|del-set|match-set|comment|chunk-types|cpu|connbytes|connbytes-dir|connbytes-mode|ecn-ip-ect|helper)))
				return 0 # match option not valid at this context
			;;
			@(--@(length|mac-source|mark|mss|pkt-type|quota|src-range|dst-range|src-type|dst-type|uid-owner|gid-owner|realm|tos)))
				return 0 # match option not valid at this context
			;;
			@(--@(algo|from|to|string|hex-string|mode|probability|every|packet|rt-type|rt-segsleft|rt-len|rt-0-addrs)))
				return 0 # match option not valid at this context
			;;
			@(--@(physdev-in|physdev-out|genre|ttl|log|limit|limit-burst|mh-type|nfacct-name|fragid|fraglen|ahspi|espspi)))
				return 0 # match option not valid at this context
			;;
			@(--@(connlimit-upto|connlimit-above|connlimit-mask|src-group|dst-group|mask|seconds|hitcount|state)))
				return 0 # match option not valid at this context
			;;
			@(--@(dccp-option|dccp-types|dst-len|dst-opts|hbh-len|hbh-opts|datestart|datestop|timestart|timestop|monthdays|weekdays)))
				return 0 # match option not valid at this context
			;;
			@(--@(cluster-total-nodes|cluster-local-node|cluster-local-nodemask|cluster-hash-seed)))
				return 0 # cluster match option not valid at this context
			;;
			@(--ct@(state|proto|origsrc|origdst|replsrc|repldst|origsrcport|origdstport|replsrcport|status|expire|dir)))
				return 0 # conntrack match option not valid at this context
			;;
			@(--@(dir|pol|reqid|spi|tunnel-src|tunnel-dst)))
				return 0 # policy match option not valid at this context
			;;
			@(--hashlimit-@(upto|above|burst|mode|srcmask|dstmask|name|htable-size|htable-max|htable-expire|htable-gcinterval)))
				return 0 # hashlimit match option not valid at this context
			;;
			@(--@(vproto|vaddr|vport|vdir|vmethod|vportctl)))
				return 0 # ipvs match option not valid at this context
			;;
			@(--@(set-xmark|and-mark|or-mark|xor-mark|set-mark|nfmask|ctmask)))
				return 0 # CONNMARK target option not valid at this context
			;;
			@(--hmark-@(tuple|mod|offset|src-prefix|dst-prefix|sport-mask|dport-mask|spi-mask|proto-mask|rnd)))
				return 0 # HMARK target option not valid at this context
			;;
			@(--@(ctevents|expevents|zone|timeout)))
				return 0 # CT target option not valid at this context
			;;
			@(--@(gateway|reject-with|to-destination|to-source|to-ports|to|selctx|set-class|set-mss|timeout|label|type)))
				return 0 # target option not valid at this context
			;;
			@(--@(queue-num|queue-balance|set-dscp|dscp|dscp-class|set-dscp-class|set-tos|and-tos|or-tos|xor-tos|strip-options)))
				return 0 # target option not valid at this context
			;;
			@(--@(led-trigger-id|led-delay|rateest-name|rateest-interval|rateest-ewmalog|on-port|on-ip|tproxy-mark|u32)))
				return 0 # target option not valid at this context
			;;
			@(--@(hl-set|hl-dec|hl-inc|hl-eq|hl-gt|hl-lt|ttl-set|ttl-dec|ttl-inc|ttl-eq|ttl-gt|ttl-lt)))
				return 0 # target option not valid at this context
			;;
			@(--@(hashmode|clustermac|total-nodes|local-node|hash-init)))
				return 0 # CLUSTERIP target option not valid at this context
			;;
			@(--@(log-level|log-prefix|nflog-group|nflog-prefix|nflog-range|nflog-threshold|\
				ulog-nlgroup|ulog-prefix|ulog-cprange|ulog-qthreshold)))
				return 0 # [U|NF]LOG target option not valid at this context
			;;
		esac
#		i=$(_iptables_get_cw_idx "$prev")
		i=$((cword -1))
		if ((i > 1)); then # depend on option before previous option
			case "${words[i-1]}" in
				-E|--rename-chain|-P|--policy|-R|--replace|--set-counters) 
					return 0
				;;
				@(--@(add-set|del-set|match-set))) # expecting set name
					return 0
				;;
				@(--@(hl-set|hl-dec|hl-inc|ttl-set|ttl-dec|ttl-inc|ttl-eq|ttl-gt|ttl-lt|dccp-option|\
					nflog-group|nflog-range|nflog-threshold|timeout|total-nodes|local-node|led-delay|\
					ulog-cprange|ulog-qthreshold|from|to|every|packet|rt-type|rt-len|ttl|log|\
					limit-burst|hl-eq|hl-gt|hl-lt|fraglen|connlimit-upto|connlimit-above|ahlen|\
					cluster-total-nodes|cluster-local-node|spi|seconds|hitcount|zone|hbh-len|dst-len|\
					hmark-offset)))
					[[ $prev = +([[:digit:]]) ]] || return 0 # digit value expected
				;;
				@(--hashlimit-@(burst|buckets|entries|htable-expire|htable-gcinterval)))
					[[ $prev = +([[:digit:]]) ]] || return 0 # hashlimit match - digit value expected
					return 0
				;;
				@(--@(hashlimit-srcmask|hashlimit-dstmask)))
					[[ $prev = +([[:digit:]]) ]] || return 0
					((prev > 32)) && return 0
				;;
				--hmark-mod) # HMARK target - int >0
					[[ $prev = +([[:digit:]]) ]] || return 0
					((prev > 0)) || return 0
				;;
				--hmark-sport-mask|--hmark-dport-mask) # HMARK target - 16 bit xdigit
					[[ $prev = +([[:xdigit:]]) ]] || return 0
					((prev >= 0 && prev <= 0xFFFF)) || return 0
				;;
				--mask) # CONNMARK target and recent match have --mask
					if [[ $str_target = CONNMARK ]]; then
						[[ $prev = @(0x+([[:xdigit:]])|+([[:digit:]])) ]] || return 0
						((prev <= 4294967295)) || return 0
					elif [[ ${arr_matches[${#arr_matches[@]}-1]} = recent ]]; then
						[[ $prev = +([[:digit:]]) ]] || return 0
						((prev > 32)) && return 0
					fi
				;;
				--hmark-proto-mask) # 8bit digit or xdigit value | HMARK target
					[[ $prev = @(0x+([[:xdigit:]])|+([[:digit:]])) ]] || return 0
					((prev <= 0xFF)) || return 0
				;;
				--cluster-local-nodemask|ct-mask|nf-mask|and-mark|or-mark|xor-mark|hmark-spi-mask|hmark-rnd)
					# 32bit digit or xdigit value expected
					[[ $prev = @(0x+([[:xdigit:]])|+([[:digit:]])) ]] || return 0
					((prev <= 4294967295)) || return 0
				;;
				@(--@(set-mark|set-xmark))) # CONNMARK target mark[/mask]
					[[ $prev = @(+([[:digit:]])|0x+([[:xdigit:]]))?(/@(+([[:digit:]])|0x+([[:xdigit:]]))) ]] || return 0
					for str_tmp in ${prev//\// }; do
						((str_tmp <= 4294967295)) || return 0
					done
				;;
				# numeric range definition with `:' expected -> COMP_WORDBREAKS `:' problem
				@(--@(fragid|mss|rt-segsleft|ctexpire)))
					[[ $prev = +([[:digit:]])?(:+([[:digit:]])) ]] || return 0
				;;
				--ahspi|--espspi) # 32 bit range values -> COMP_WORDBREAKS `:' problem
					[[ $prev = +([[:digit:]])?(:+([[:digit:]])) ]] || return 0
					for str_tmp in ${prev/:/ }; do
						((str_tmp <= 4294967295)) || return 0
					done
				;;
				--connlimit-mask) # connlimit match
					[[ $prev = +([[:digit:]]) ]] || return 0
					if [[ $str_app = iptables ]]; then
						((prev > 32)) && return 0
					elif [[ $str_app = ip6tables ]]; then
						((prev > 128)) && return 0
					fi
				;;
				--label) # IDLETIMER target
					((${#prev} > 27)) && return 0
				;;
				--log-prefix) # LOG target
					((${#prev} > 29)) && return 0
				;;
				--nflog-prefix) # NFLOG target
					((${#prev} > 64)) && return 0
				;;
				--ulog-prefix) # ULOG target
					((${#prev} > 32)) && return 0
				;;
				@(--@(limit|hashlimit-upto|hashlimit-above))) # [hash]limit match
					[[ $prev = +([[:digit:]])?(/@(second|minute|hour|day)) ]] || return 0
				;;
				--probability) # statistic match
					[[ $prev = @(0?(.[0-9])|1?(.0)) ]] || return 0
				;;
				--queue-num) # NFQUEUE target
					[[ $prev = +([[:digit:]]) ]] || return 0
					((prev > 65535)) && return 0
				;;
				--ulog-nlgroup) # ULOG target
					[[ $prev = +([[:digit:]]) ]] || return 0
					((prev < 1 || prev > 32)) && return 0
				;;
				@(--@(dscp|set-dscp))) # dscp match and DSCP target - digit or 0xxdigit
					[[ $prev = @(+([[:digit:]])|0x+([[:xdigit:]])) ]] || return 0
					((prev > 63)) && return 0
				;;
				--hbh-opts|--dst-opts) # hbh and dst match
					[[ $prev = +([[:digit:]]):+([[:digit:]])*(,+([[:digit:]]):+([[:digit:]])) ]] || return 0
				;;
				--timestart|--timestop) # time match
					[[ $prev = +([[:digit:]])+([[:digit:]]):+([[:digit:]])+([[:digit:]])?(:+([[:digit:]])+([[:digit:]])) ]] || return 0
				;;
				--monthdays) # time match
					[[ $prev = +([[:digit:]])*(,+([[:digit:]])) ]] || return 0
					for str_tmp in ${prev//,/ }; do
						((str_tmp < 1 || str_tmp > 31)) && return 0
					done
				;;
				--weekdays) # time match
					str_tmp="Mo|Mon|Tu|Tue|We|Wed|Th|Thu|Fr|Fri|Sa|Sat|Su|Sun"
					if [[ $prev = @(@($str_tmp)|+([[:digit:]]))*(,@(@($str_tmp)|+([[:digit:]]))) ]]; then
						for str_var in ${prev//,/ }; do
							if [[ $str_var = +([[:digit:]]) ]]; then
								((str_var < 1 || str_var > 7)) && return 0
							elif [[ $str_var = @($str_tmp)*(,@($str_tmp)) ]]; then :
							else return 0
							fi
						done
					else return 0
					fi
				;;
			esac
		fi
		case "$str_target" in
			CLUSTERIP) # CLUSTERIP rules must start with --new
				i=$(_iptables_get_cw_idx CLUSTERIP)
				if ((i > 1)); then
					if [[ ${words[i+2]} && ${words[i+1]} != --new ]]; then
						return 0
					fi
				fi
			;;
		esac
		# done with terminating conditions, collect information
		if ! ((got_action)); then
		   	# if we don't know the main command and haven't defined remaining options
			# while parsing existing cmdline, set option list to main command list
			((${#arr_tmp_opts[@]})) || _iptables_swap_array arr_command_opts arr_tmp_opts
		fi
		case "$cur" in # show either short or long options (single or double dash)
			-?(+([[:word:]]))) # any short-option is requested
				arr_tmp_opts=( "${arr_tmp_opts[@]/%--*/}" )
				((inline_help)) && str_help=-h
			;;
		--?(+([[:word:]]))*) # any long-option is requested
				arr_tmp_opts=( "${arr_tmp_opts[@]/#-* }" )
				((inline_help)) && str_help=--help
			;;
		esac
		if ((${#words[@]} > 2)); then # we got one option, so remove options that are mutual exclusive to all others
			for i in ${!arr_tmp_opts[@]}; do
				if [[ ${arr_tmp_opts[i]} = @(-@(V|-version)) ]]; then
					unset arr_tmp_opts[i]
					break
				fi
			done
		fi
		# from here we start to set a compreply
		# TODO: exclude mutual exclusive match and target options from compreply
		if _iptables_is_option "$prev"; then
			COMPREPLY=( $( compgen -W '${arr_tmp_opts[@]}' -- $cur ) )
		elif _iptables_is_target "$prev"; then
			if [[ $prev != @(ACCEPT|DROP|NOTRACK|TRACE) ]]; then # targets with no option
				COMPREPLY=( $( compgen -W '$(_iptables_get_target_options "$prev") $str_help' -- $cur ) )
			fi
#		elif _iptables_is_match "$prev" && [[ ${words[$(_iptables_get_cw_idx "$prev")-1]} = @(-m|--match) ]]; then
		elif _iptables_is_match "$prev" && [[ ${words[cword-2]} = @(-m|--match) ]]; then
			COMPREPLY=( $( compgen -W '$(_iptables_get_match_options "$prev") $str_help' -- $cur ) )
		else
			case "$(_iptables_last_is)" in
				target)
					if [[ $str_target != @(ACCEPT|DROP|NOTRACK|TRACE) ]]; then # targets with no option
						COMPREPLY=( $( compgen -W '$(_iptables_get_target_options "$str_target") ${arr_tmp_opts[@]}' -- $cur ) )
					fi
				;;
				match)
					COMPREPLY=( $( compgen -W '$(_iptables_get_match_options "${arr_cmd_matches[${#arr_cmd_matches[@]}-1]}") ${arr_tmp_opts[@]}' -- $cur ) )
				;;
				option)
					if [[ ${arr_cmd_opts[${#arr_cmd_opts[@]}-1]} = @(-p|--proto) && ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = @(icmp|tcp|udp|esp|ah) ]]
					then # also load match options if last option was -p|--proto and also is a known match
						COMPREPLY=( $( compgen -W '$(_iptables_get_match_options "${arr_cmd_matches[${#arr_cmd_matches[@]}-1]}") ${arr_tmp_opts[@]}' -- $cur ) )
					else
						COMPREPLY=( $( compgen -W '${arr_tmp_opts[@]}' -- $cur ) )
					fi
				;;
			esac
		fi
		if ! ((${#COMPREPLY[@]})); then # by default display all options if no reply was previously found
			COMPREPLY=( $( compgen -W '${arr_tmp_opts[@]}' -- $cur ) )
		fi
	;;
	*) # not an option
		if [[ -z $cur ]] && ((${#words[@]} == 2)); then # no option given, present main command list first
			COMPREPLY=( ${arr_command_opts[@]} )
			return 0
		fi
		case "$prev" in # depend on previous option
			-h|--help|-V|--version)
				return 0
			;;
			@(-@(A|-append|C|-check|D|-delete|F|-flush|I|-insert|L|-list|S|-list-rules|X|-delete-chain|Z|-zero)))
				# chain name expected next
				COMPREPLY=( $( compgen -W '$(_iptables_get_builtin_chains_by_table $str_table) \
					$(_iptables_get_user_chains $str_table)' -- $cur ) )
			   	return 0
			;;
			-E|--rename-chain|-R|--replace) # retrieve existing chains
				COMPREPLY=( $( compgen -W '$(_iptables_get_user_chains $str_table)' -- $cur ) )
				return 0
			;;
			-P|--policy)
				COMPREPLY=( $( compgen -W '$(_iptables_get_builtin_chains_by_table $str_table)' -- $cur ) )
				return 0
			;;
			-g|--goto)
				COMPREPLY=( $( compgen -W '$(_iptables_get_user_chains $str_table)' -- $cur ) )
				return 0
			;;
			-j|--jump)
				COMPREPLY=( $( compgen -W '$(_iptables_get_target_by_table $str_table) \
				   	$(_iptables_get_user_chains $str_table)' -- $cur ) )
				return 0
			;;
			-t|--table)
				COMPREPLY=( $( compgen -W '${arr_tables[@]}' -- $cur ) )
				return 0
			;;
			-m|--match) arr_tmp=()
				# do not show matches already used
				# except those explicitly defined for multiple usage
				for str_tmp in $(_iptables_get_match_by_table $str_table); do
					for str_var in ${arr_cmd_matches[@]}; do # matches already used on the command-line
						if [[ $str_tmp = $str_var ]]; then
							if [[ $str_tmp = $str_proto && $COMP_LINE != *@(-m|--match)+([[:blank:]])$str_tmp* ]]; then
								arr_tmp[${#arr_tmp[@]}]="$str_tmp" # proto used matches, allow if it hasnt been used
							else
								for x in ${!arr_global_matches[@]}; do # those are allways shown
									if [[ $str_tmp = ${arr_global_matches[x]%% *} ]]; then
										arr_tmp[${#arr_tmp[@]}]="$str_tmp"
										break
									fi
								done
							fi
							continue 2
						fi
					done
					arr_tmp[${#arr_tmp[@]}]="$str_tmp"
				done
				COMPREPLY=( $( compgen -W '${arr_tmp[@]}' -- $cur ) )
#				COMPREPLY=( $( compgen -W '$(_iptables_get_match_by_table $str_table)' -- $cur ) )
				return 0
			;;
			@(-@(i|-in-interface|o|-out-interface|-physdev-in|-physdev-out)))
				COMPREPLY=( $( compgen -W '$(_iptables_get_ifnames)' -- $cur ) )
				return 0
			;;
			-p|--proto|--ctproto|--vproto)
				if [[ $prev = --proto ]]; then
					if ((${#arr_cmd_matches[@]})) && [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]
					then COMPREPLY=( $( compgen -W 'ah esp ipcomp' -- $cur ) )
						return 0 # policy match also has --proto
					fi
				fi
				COMPREPLY=( $( compgen -W '$(_iptables_get_protocols)' -- $cur ) )
				return 0
			;;
			@(--@(on-port|vport|vportctl)))
				COMPREPLY=( $( compgen -W '$(_iptables_get_services)' -- $cur ) )
				return 0
			;;
			@(--@(dport|destination-port|sport|source-port)))
				if [[ $cur = *:* ]]; then
					COMPREPLY=( $(_iptables_compl_port_range "$cur") )
					((got_bashcompl)) && __ltrim_colon_completions "$cur"
				else
					compopt -o nospace
					COMPREPLY=( $( compgen -W '$(_iptables_get_services)' -- $cur ) )
				fi
				return 0
			;;
			--icmp-type)
				COMPREPLY=( $( compgen -W '${arr_icmp_types[@]//,/ }' -- $cur ) )
				return 0
			;;
			--icmpv6-type)
				COMPREPLY=( $( compgen -W '${arr_icmp6_types[@]//,/ }' -- $cur ) )
				return 0
			;;
			--reject-with) # REJECT target
				case "$str_app" in
					iptables)
						COMPREPLY=( $( compgen -W 'icmp-net-unreachable icmp-host-unreachable\
						   	icmp-port-unreachable icmp-proto-unreachable icmp-net-prohibited\
						   	icmp-host-prohibited icmp-admin-prohibited tcp-reset' -- $cur ) )
					;;
					ip6tables)
						COMPREPLY=( $( compgen -W 'icmp6-no-route no-route icmp6-adm-prohibited\
						   	adm-prohibited icmp6-addr-unreachable addr-unreach\
						   	icmp6-port-unreachable port-unreach tcp-reset' -- $cur ) )
					;;
				esac
				return 0
			;;
			--type) # AUDIT target
				COMPREPLY=( $( compgen -W 'accept drop reject' -- $cur ) )
				return 0
			;;
			--set-class) # CLASSIFY target
				COMPREPLY=( $( compgen -W '$(_iptables_get_tc_classes)' -- $cur ) )
				((got_bashcompl)) && __ltrim_colon_completions "$cur"
				return 0
			;;
			--hashmode) # CLUSTERIP target
				COMPREPLY=( $( compgen -W 'sourceip sourceip-sourceport sourceip-sourceport-destport' -- $cur ) )
				return 0
			;;
			--expevents) # CT target
				COMPREPLY=( $( compgen -W 'new' -- $cur ) )
				return 0
			;;
			--ctevents) # CT target
				_iptables_build_comma_list "$cur" new related destroy reply assured protoinfo helper mark natseqinfo secmark
				return 0
			;;
			--hmark-tuple) # HMARK target
				_iptables_build_comma_list "$cur" src dst sport dport spi ct
				return 0
			;;
			--log-level) # LOG target
				COMPREPLY=( $( compgen -W 'alert crit debug emerg err info notice warning' -- $cur ) )
				return 0
			;;
			--nflog-group) # NFLOG target
				str_tmp=$(set +f; cd /proc/sys/net/netfilter/nf_log/ && printf "%s\n" *)
				COMPREPLY=( $( compgen -W '$str_tmp' -- $cur ) )
				return 0
			;;
			--strip-options) # TCPOPTSTRIP target
				_iptables_build_comma_list "$cur" wscale mss sack-permitted sack timestamp md5
				return 0
			;;
			@(--@(add-set|del-set|match-set))) # set match and SET target
				COMPREPLY=( $( compgen -W '$(_iptables_get_setnames)' -- $cur ) )
				((got_bashcompl)) && __ltrim_colon_completions "$cur"
				return 0
			;;
			--algo) # string match
				COMPREPLY=( $( compgen -W 'bm kmp' -- $cur ) )
				return 0
			;;
			--chunk-types) # sctp match
				COMPREPLY=( $( compgen -W 'all any only' -- $cur ) )
				return 0
			;;
			--ctstate) # conntrack match
				_iptables_build_comma_list "$cur" NEW ESTABLISHED RELATED INVALID UNTRACKED SNAT DNAT
				return 0
			;;
			--ctstatus) # conntrack match
				_iptables_build_comma_list "$cur" NONE EXPECTED SEEN_REPLY ASSURED CONFIRMED
				return 0
			;;
			--ctdir) # conntrack match
				COMPREPLY=( $( compgen -W 'ORIGINAL REPLY' -- $cur ) )
				return 0
			;;
			--cpu) # cpu match
				str_tmp=$(while read -r str_name c num;do [[ $str_name = processor ]] && printf "%s\n" "$num";done</proc/cpuinfo)
				COMPREPLY=( $( compgen -W '$str_tmp' -- $cur ) )
				return 0
			;;
			--connbytes-dir) # connbytes match
				COMPREPLY=( $( compgen -W 'original reply both' -- $cur ) )
				return 0
			;;
			--connbytes-mode) # connbytes match
				COMPREPLY=( $( compgen -W 'packets bytes avgpkt' -- $cur ) )
				return 0
			;;
			--dccp-types) # dccp match
				_iptables_build_comma_list "$cur" REQUEST RESPONSE DATA ACK DATAACK CLOSEREQ CLOSE RESET SYNC SYNCACK INVALID
				return 0
			;;
			--log|--ttl) # osf match
				COMPREPLY=( $( compgen -W '0 1 2' -- $cur ) )
				return 0
			;;
			--ecn-ip-ect) # ecn match
				COMPREPLY=( $( compgen -W '0 1 2 3' -- $cur ) )
				return 0
			;;
			--mode) # overlap in option names, policy and statistic match both have --mode
				if ((${#arr_cmd_matches[@]})); then
					if [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]; then
						COMPREPLY=( $( compgen -W 'tunnel transport' -- $cur ) )
					elif [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = statistic ]]; then
						COMPREPLY=( $( compgen -W 'random nth' -- $cur ) )
					fi
					return 0
				fi
			;;
			--dir) # policy match
				COMPREPLY=( $( compgen -W 'in out' -- $cur ) )
				return 0
			;;
			--pol) # policy match
				COMPREPLY=( $( compgen -W 'none ipsec' -- $cur ) )
				return 0
			;;
			--nfacct-name) # nfacct match
				str_tmp=$( while read -r;do REPLY="${REPLY%;}";printf "%s\n" ${REPLY##*=};done < <(PATH=${PATH}:/sbin command nfacct list) )
				COMPREPLY=( $( compgen -W '$str_tmp' -- $cur ) )
				return 0
			;;
			--uid-owner) # owner match
				COMPREPLY=( $( compgen -u -- $cur ) )
				return 0
			;;
			--gid-owner) # owner match
				COMPREPLY=( $( compgen -g -- $cur ) )
				return 0
			;;
			--pkt-type) # pkttype match
				COMPREPLY=( $( compgen -W 'unicast broadcast multicast' -- $cur ) )
				return 0
			;;
			--realm) # realm match
				COMPREPLY=( $( compgen -W '$(_iptables_get_realms)' -- $cur ) )
				return 0
			;;
			--state) # state match
				_iptables_build_comma_list "$cur" NEW ESTABLISHED RELATED INVALID UNTRACKED
				return 0
			;;
			--src-type|--dst-type) # addrtype match
				COMPREPLY=( $( compgen -W 'UNSPEC UNICAST LOCAL BROADCAST ANYCAST MULTICAST \
					BLACKHOLE UNREACHABLE PROHIBIT THROW NAT XRESOLVE' -- $cur ) )
				return 0
			;;
			--dscp-class|--set-dscp-class) # dscp match and DSCP target
				COMPREPLY=( $( compgen -W 'BE EF AF11 AF12 AF13 AF21 AF22 AF23 AF31 AF32 AF33 AF41 AF42 AF42 CS1 CS2 CS3 Cs4' -- $cur ) )
				return 0
			;;
			--rateest-interval|--rateest-ewmalog) # rateest match
				if [[ $cur = +([[:digit:]])?(.*([[:digit:]]))*([[:alpha:]]) ]]; then # glob not perfect, requires more work
					COMPREPLY=( $( compgen -W '${cur//[[:alpha:]]/}s ${cur//[[:alpha:]]/}ms ${cur//[[:alpha:]]/}us' -- $cur ) )
					return 0
				fi
			;;
			--limit|--hashlimit-above|--hashlimit-upto) # limit match
				if [[ $cur = +([[:digit:]])?(/*([[:alpha:]])) ]]; then str_tmp="${cur//+(\/|+([[:alpha:]]))/}"
					COMPREPLY=( $( compgen -W '${str_tmp}/second ${str_tmp}/minute ${str_tmp}/hour ${str_tmp}/day' -- $cur ) )
					return 0
				fi
			;;
			--hashlimit-mode) # hashlimit match
				_iptables_build_comma_list "$cur" srcip srcport dstip dstport
				return 0
			;;
			--tos|--set-tos) # tos match and TOS target
				if [[ $str_app = iptables ]]; then
					COMPREPLY=( $( compgen -W 'Minimize-Delay Maximize-Throughput Maximize-Reliability Minimize-Cost Normal-Service' -- $cur ) )
					return 0
				fi
			;;
			--vdir) # ipvs match
				COMPREPLY=( $( compgen -W 'ORIGINAL REPLY' -- $cur ) )
				return 0
			;;
			--vmethod) # ipvs match
				COMPREPLY=( $( compgen -W 'GATE IPIP MASQ' -- $cur ) )
				return 0
			;;
			--weekdays) # time match
				_iptables_build_comma_list "$cur" Mon Tue Wed Thu Fri Sat Sun
				return 0
			;;
			DATA) # sctp match
				COMPREPLY=( I U B E i u b e )
				return 0
			;;
			ABORT|SHUTDOWN_COMPLETE) # sctp match
				COMPREPLY=( T t )
				return 0
			;;
		esac
		i=$((cword -1))
		if ((i > 1)); then # depend on option before previous option
			case "${words[i-1]}" in
				--chunk-types) # sctp match
					compopt -o nospace
					COMPREPLY=( $( compgen -W 'DATA ABORT SHUTDOWN_COMPLETE' -- $cur ) )
					return 0
				;;
				-P|--policy) # chain policy
					COMPREPLY=( $( compgen -W 'ACCEPT DROP' -- $cur ) )
					return 0
				;;
				--add-set|--del-set|--match-set) # set match and SET target
					_iptables_build_ipset_flag_list "$cur" src dst
					return 0
				;;
			esac
		fi
	;;
esac

if [[ $_DEBUG_IPT_COMPL ]]; then
	printf "COMPREPLY before dedupe:\n"
	printf "<%s>\n" "${COMPREPLY[@]}"
fi
if ((${#COMPREPLY[@]})); then # post process the reply
	if ((opt_request)); then # only run the option de-dupe if an option was requested
		for ((i=1; i < ${#words[@]}; i++)); do
			[[ ${words[i]} = @(-|--|"") ]] || [[ ${words[i]} != -?(-)?* ]] && continue # no option
				# if the user supplied the short form of an option previously, and now requests the long form,
			   	# remove the corresponding long option, vice versa for short options
				for y in ${!arr_opts[@]}; do # cycle through main options
					set -- ${arr_opts[y]} # $1 = short , $2 = long option
					if [[ ${words[i]} = @($1|$2) ]]; then # we got short or long version on the cmdline
						for x in ${!COMPREPLY[@]}; do # compare with compreply
							if [[ ${COMPREPLY[x]} = @($1|$2) ]]; then
								# options allowed multiple times
								if [[ ${COMPREPLY[x]} = @(-@(m|-match)) ]]; then
									:
								elif [[ ${COMPREPLY[x]} = --proto ]] && ((policy_match_index)) && \
									[[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]; then
									: # always allow --proto if policy is the last match
								elif [[ ${COMPREPLY[x]} = -p ]] && ((policy_match_index)) && \
									[[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy && -z $str_proto ]]; then
									: # allow -p after first option of policy match was set, if not set before
								else # exceptions done
									if [[ $_DEBUG_IPT_COMPL ]]; then
										printf "removing option alias - unsetting COMPREPLY[$x]: %s\n" "${COMPREPLY[x]}"
									fi
									unset COMPREPLY[x]
									continue 3 # no need to de-dupe anymore, so we move one
								fi
							fi
						done
					fi
				done
			[[ ${words[i]} = @(-@(m|-match|-match-set|-return-nomatch|-chunk-types|-mark|-reqid|-spi|-mode|-tunnel-src|-tunnel-dst|-next)) ]] && continue # options allowed multiple times
			for x in ${!COMPREPLY[@]}; do # list an option only once
				if [[ ${COMPREPLY[x]} = --proto ]] && ((policy_match_index)) && \
					[[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]; then
					continue
				elif [[ ${COMPREPLY[x]} = -p ]] && ((policy_match_index)) && \
					[[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy && -z $str_proto ]]; then
					continue
				fi
				if [[ ${words[i]} = ${COMPREPLY[x]} ]]; then
					if [[ $_DEBUG_IPT_COMPL ]]; then
						printf "removing dupe option - unsetting COMPREPLY[$x]: %s\n" "${COMPREPLY[x]}"
					fi
					unset COMPREPLY[x]
					break
				fi
			done
		done
	fi
else
	[[ $cur ]] &&	_iptables_bash_default_compl "$cur"
fi

case "${COMPREPLY[0]}" in
	--modprobe=)
		compopt -o nospace
	;;
esac

if [[ $_DEBUG_IPT_COMPL ]]; then
	printf "COMPREPLY after dedupe:\n"
	printf "<%s>\n" "${COMPREPLY[@]}"
fi
}
complete -F _iptables_complete iptables ip6tables

