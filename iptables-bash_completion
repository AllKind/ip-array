#!/bin/bash

# -----------------------------------------------------------------
# Programmable completion code for iptables (netfilter.org)
#
# https://github.com/AllKind/iptables-bash_completion
# https://sourceforge.net/projects/ipt-bashcompl
# -----------------------------------------------------------------

# Copyright (C) 2013 AllKind (AllKind@fastest.cc)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# -----------------------------------------------------------------
# Tested with iptables versions:
# 1.4.16.3
# -----------------------------------------------------------------
# Requirements:
#
# The bash completion package version 2.0 or greater is recommended.
# http://bash-completion.alioth.debian.org/
#
# If the package is not available, things might not be so reliable.
# Also the colon (if there) is removed from COMP_WORDBREAKS.
# This alteration is globally, which might affect other completions,
# if they don't take care of it themselves.
#
# -----------------------------------------------------------------
# Installation:
#
# Put it into ~/.bash_completion or /etc/bash_completion.d/
#
# -----------------------------------------------------------------
#
# Version 1.0-alpha-10
#
# -----------------------------------------------------------------

shopt -s extglob

# -----------------------------------------------------------------
# FUNCTIONS
# -----------------------------------------------------------------

_iptables_bash_default_compl() { # taken from examples - modified by me
# call with the word to be completed as $1
local t
if [[ $1 == \$\(* ]]; then # command substitution
    t=${1#??}
    COMPREPLY=( $(compgen -c -P '$(' $t) )
elif [[ $1 == \$\{* ]]; then # variables with a leading `${'
    t=${1#??}
    COMPREPLY=( $(compgen -v -P '${' -S '}' $t) )
elif [[ $1 == \$* ]]; then # variables with a leading `$'
    t=${1#?}
    COMPREPLY=( $(compgen -v -P '$' $t ) )
elif [[ "$1" == *@* ]]; then # hostname
    t=${1#*@}
    COMPREPLY=( $( compgen -A hostname $t ) )
    # prefix as long we have multiple completions
    if ((${#COMPREPLY[@]} > 1)); then
        COMPREPLY=( $( compgen -P '@' -A hostname $t ) )
    fi
elif [[ $1 == *[*?[]* ]]; then # sh-style glob pattern
    COMPREPLY=( $( compgen -G "$1" ) )
# ksh-style extended glob pattern - must be complete
elif shopt -q extglob && [[ $1 == *[?*+\!@]\(*\)* ]]; then
    COMPREPLY=( $( compgen -G "$1" ) )
fi
}

# -----------------------------------------------------------------
# iptables functions
# -----------------------------------------------------------------
_iptables_select_on_inet_family() {
if [[ $1 != all ]]; then # select match according to current calling app
    if [[ $1 = v4 && $str_app = ip6tables ]]; then
        return 1
    elif [[ $1 = v6 && $str_app = iptables ]]; then
        return 1
    fi
fi
return 0
}

_iptables_get_rulenum() {
[[ ${words[${1}+2]} = +([[:digit:]]) ]] && printf "%d\n" ${words[${1}+2]}
}

_iptables_is_option() {
local -i opt_idx
local str_q="$1"
[[ $str_q = -* ]] || return
# CLUSTERIP also has --new
if [[ $str_q = --new && $str_target = CLUSTERIP ]]; then
    return 1
fi
if [[ $str_q = --proto ]] && \
    ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]
then # policy match also has --proto
    return 1
fi
for opt_idx in ${!arr_opts[@]}; do set -- ${arr_opts[opt_idx]}
    while (($#)); do
        [[ $1 = $str_q ]] && return
        shift
    done
done
return 1
}

_iptables_is_target() {
local -i idx
local str_x="$1"
[[ $str_x = @(""|-*|*/*) ]] && return 1
for idx in ${!arr_targets[@]}; do
    [[ ${arr_targets[idx]%% *} = $str_x ]] && return
done
return 1
}

_iptables_is_match() {
local -i idx
local str_x="$1"
[[ $str_x = @(""|-*|*/*) ]] && return 1
for idx in ${!arr_matches[@]}; do
    [[ ${arr_matches[idx]%% *} = $str_x ]] && return
done
return 1
}

_iptables_get_match_by_table() {
local -i idx
local str_x="$1" # table name
for idx in ${!arr_matches[@]}; do
    set -- ${arr_matches[idx]}
    _iptables_select_on_inet_family $2 || continue
    # valid in current table
    if [[ $3 = all ]] || [[ ${3//,/ } = *${str_x}* ]]; then
        if [[ $str_proto ]]; then
            case "$1" in
                connlimit|ecn|osf|tcp|tcpmss)
                    [[ $str_proto = tcp ]] || continue
                ;;
                multiport)
                    [[ $str_proto = @(tcp|udp|dccp|sctp) ]] || continue
                ;;
                icmp|udp|tcp|ah|esp|dccp|sctp)
                    [[ $str_proto = $1 ]] || continue
                ;;
            esac
        fi
        printf "%s\n" "$1"
    fi
done
}

_iptables_get_target_by_table() {
local -i idx
local str_x="$1" # table
for idx in ${!arr_targets[@]}; do set -- ${arr_targets[idx]}
    _iptables_select_on_inet_family $2 || continue
    if [[ $3 = all ]] || [[ ${3//,/ } = *${str_x}* ]]; then # allowed in table
        if [[ $str_proto ]]; then
            case "$1" in
                ECN|TCPMSS|TCPOPTSTRIP)
                    [[ $str_proto = tcp ]] || continue
                ;;
#                XY)
#                    [[ $str_proto = @(tcp|udp) ]] || continue
#                ;;
            esac
        fi
        printf "%s\n" "$1"
    fi
done
}

_iptables_get_builtin_chains_by_table() {
local str_cmd str_name str_rest
while read -r str_cmd str_name str_rest; do
    [[ $str_cmd = -P ]] && printf "%s\n" "$str_name" || return 0
done < <(iptables -S -t $1 2>/dev/null)
}

_iptables_get_user_chains() {
local str_cmd str_name str_rest
while read -r str_cmd str_name str_rest; do
    if [[ $str_cmd = -N ]]; then printf "%s\n" "$str_name"
    elif [[ $str_cmd = -A ]]; then return 0
    fi
done < <(iptables -S -t $1 2>/dev/null)
}

_iptables_get_target_opts() {
local -i idx oidx ridx=0
local str_x="$1" oIFS="$IFS" str_opt str_flags str_xflag
local -a arr_topts=() arr_reply=()
for idx in ${!arr_targets[@]}; do set -- ${arr_targets[idx]}
    if [[ $1 = $str_x ]]; then
        _iptables_select_on_inet_family $2 || continue
        shift 3
        arr_topts=( "$@" )
        # check targets option flags
        for oidx in ${!arr_topts[@]}; do
            if [[ ${arr_topts[oidx]} != *:* ]]; then
               arr_reply[ridx++]="${arr_topts[oidx]}"
               continue
           fi
            str_flags="${arr_topts[oidx]#*:}"
            str_opt="${arr_topts[oidx]%:"$str_flags"}"
            IFS=:
            set -- $str_flags
            IFS="$oIFS"
            while (($#)); do
                if [[ $1 = ex ]]; then # mutual exclusive options
                    shift
                    for str_xflag in ${1//,/ }; do
                        _iptables_is_in_compwords "$str_xflag" && continue 3
                    done
                elif [[ $1 = table ]]; then # option is table depending
                    shift
                    for str_xflag in ${1//,/ }; do
                        [[ $str_table = $str_xflag ]] || continue 3
                    done
                elif [[ $1 = proto ]]; then # option is protocol depending
                    shift
                    if [[ $str_proto ]]; then
                        str_xflag="${1//,/|}"
                        [[ $str_proto = @($str_xflag) ]] || continue 2
                    fi
                fi
                shift
            done
            arr_reply[ridx++]="$str_opt"
        done
        printf "%s\n" "${arr_reply[*]}"
        return 0
    fi
done
}

_iptables_get_match_opts() {
local -i idx cix rix xix got_arg
local str_match="$1" oIFS="$IFS" str_opt str_tmp str_flags str_xflag
local arr_reply=()
for idx in ${!arr_matches[@]}; do set -- ${arr_matches[idx]}
    [[ $1 = $str_match ]] || continue
    _iptables_select_on_inet_family $2 || continue
    shift 3
    arr_reply=() arr_mopts=( "$@" )
    # check match option flags
    for rix in ${!arr_mopts[@]}; do
        str_flags="${arr_mopts[rix]#*:}"
        str_opt="${arr_mopts[rix]%:"$str_flags"}"
        IFS=:
        set -- $str_flags
        IFS="$oIFS"
        while (($#)); do
            if [[ $1 = ex ]]; then # mutual exclusive options
                shift
                for str_xflag in ${1//,/ }; do
                    _iptables_is_in_compwords "$str_xflag" && continue 3
                done
            elif [[ $1 = optis ]]; then
                # mutual exclusive options, value depending
                shift
                if _iptables_is_in_compwords "${1%=*}"; then
                    [[ ${words[$(_iptables_get_cw_idx "${1%=*}")+1]} = ${1#*=} ]] || continue 2
                fi
            fi
            shift
        done
        if [[ $str_opt = *,* ]]; then # redundant option names
            for str_tmp in ${str_opt//,/ }; do # exclude the aliases from listing
                if _iptables_is_in_compwords $str_tmp; then
                    continue 2
                fi
            done
        fi
        arr_reply[${#arr_reply[@]}]="$str_opt"
    done
    for rix in ${!arr_reply[@]}; do str_opt="${arr_reply[rix]}"
        # find options which can be used globally (multiple use of match), but filter them out
        # if we already used them in the current active match
        for xix in ${!arr_global_matches[@]}; do # retrieve list of global options
            set -- ${arr_global_matches[xix]}
            [[ $str_match = $1 ]] || continue
            shift
            for str_tmp in "$@"; do
                [[ $str_tmp = $str_opt ]] || continue
                got_arg=0
                for ((cix=${#words[@]}-1; cix > 0; cix--)); do
                    if [[ -z ${words[cix]} ]]; then continue
                    elif [[ ${words[cix]} != $str_opt && \
                        ${words[cix]} != $str_match ]]
                    then
                       if [[ ${words[cix]} = -?* ]]; then
                            # another option
                           _iptables_is_option "${words[cix]}" && break
                       else
                            if _iptables_is_match "${words[cix]}" && \
                                [[ ${words[cix-1]} = @(-m|--match|-p|--proto) ]]
                            then break # another match
                            elif _iptables_is_target "${words[cix]}" && \
                                [[ ${words[cix-1]} = @(-j|--jump|-g|--goto) ]]
                            then break # another target
                            fi
                       fi
                    elif [[ ${words[cix]} = $str_opt ]]; then
                        got_arg=1 # got the option
                    elif [[ ${words[cix]} = $str_match && \
                        ${words[cix-1]} = @(-m|--match|-p|--proto) ]]
                    then # got the match
                        ((got_arg)) || break # but don't have arg
                        unset arr_reply[rix]
                        break
                    fi
                done
            done
        done
    done
    printf "%s\n" "${arr_reply[*]//,/ }"
    return 0
done
}

# -----------------------------------------------------------------
# retrieve arguments data
# -----------------------------------------------------------------
_iptables_get_networks() {
local foo str_net rest
[[ -r /etc/networks ]] || return 0
while read -r foo str_net rest; do
    [[ $foo = @(""|*([[:blank:]])#*) ]] && continue
    [[ $str_net = *([[:blank:]])#* ]] && continue
    printf "%s\n" "$str_net"
done < /etc/networks
}

_iptables_get_ifnames() {
while read -r; do
    REPLY="${REPLY#*: }"
    printf "%s\n" ${REPLY%%:*}
done < <(PATH=${PATH}:/sbin command ip -o link show)
}

_iptables_get_protocols() {
local str_name rest
while read -r str_name rest; do
    [[ $str_name = *([[:blank:]])#* ]] && continue
    printf "%s\n" "$str_name"
done < /etc/protocols
}

_iptables_get_services() {
local str_offset="" str_name str_num str_p=all rest
while (($#)); do
    if [[ $1 = -p ]]; then
        str_p="${2:-all}"
        shift
    elif [[ $1 = -o && $2 ]]; then
        # second part of range will have offset = first_part_of_range
        str_offset="${2}"
        shift
    fi
    shift
done
# find service num to set offset
if [[ $str_offset && $str_offset != +([[:digit:]]) ]]; then
    while read str_name str_num rest; do
        if [[ $str_name = *([[:blank:]])#* ]]; then continue
        elif [[ $str_p != all && ${str_num#*/} != $str_p ]]; then
            continue
        fi
        [[ $str_name = $str_offset ]] && str_offset=${str_num%/*} && break
    done < /etc/services
    [[ $str_offset = +([[:digit:]]) ]] || return 0
fi
while read -r str_name str_num rest; do
    if [[ $str_name = *([[:blank:]])#* ]]; then continue
    elif [[ $str_p != all && ${str_num#*/} != $str_p ]]; then
        continue
    elif [[ $str_offset && $str_num && $str_num = +([[:digit:]])/* ]] && \
        ((${str_num%/*} <= $str_offset)); then
        continue
    fi
    printf "%s\n" "$str_name"
done < /etc/services
}

_iptables_compl_port_range() { # complete named port ranges
local str_prefix="$1" lcur="${1#*:}"
str_prefix=${str_prefix%"$lcur"}
compgen -P "$str_prefix" -W \
    '$(_iptables_get_services -p "$str_proto" -o "${str_prefix%:}")' \
    -- "$lcur"
}

_iptables_get_setnames() {
PATH=${PATH}:/sbin command ipset -n list
}

_iptables_get_tc_classes() { # TODO: query by interface?
local str_dev c t str_class rest
while read -r; do [[ $REPLY = lo ]] && continue
    for str_dev in $REPLY; do
        while read c t str_class rest; do
            [[ $str_class = +([[:digit:]]):+([[:digit:]]) ]] && printf "%s\n" "$str_class"
        done < <(PATH=${PATH}:/sbin command tc class show dev $str_dev)
    done
done < <(_iptables_get_ifnames)
}

_iptables_get_realms() {
local str_x
while read -r; do
    [[ $REPLY = *([[:space:]])#* ]] && continue
    if [[ $REPLY = *([[:space:]])+([[:digit:]])+([[:space:]])+([[:graph:]])* ]]; then
        str_x="${REPLY#*+([[:digit:]])+([[:space:]])}"
        printf "%s\n" "${str_x%#*}"
    fi
done </etc/iproute2/rt_realms
}

# -----------------------------------------------------------------
# misc functions
# -----------------------------------------------------------------
_iptables_dedupe_opt_alias() {
for i in ${!arr_cmd_opts[@]}; do
    [[ ${arr_cmd_opts[i]} ]] || continue
    # if the user supplied the short form of an option previously, and now
    # requests the long form, remove the corresponding long option,
    # vice versa for short options
    for y in ${!arr_opts[@]}; do # cycle through main options
        set -- ${arr_opts[y]} # $1 = short , $2 = long option
        str_tmp=""
        if [[ ${arr_cmd_opts[i]} = $1 ]]; then
            # we got short version on the cmdline
            str_tmp=$2
        elif [[ ${arr_cmd_opts[i]} = $2 ]]; then
            # we got long version on the cmdline
            str_tmp=$1
        fi
        [[ $str_tmp ]] || continue
        for x in ${!arr_tmp_opts[@]}; do # compare with compreply
            [[ ${arr_tmp_opts[x]//[[:blank:]]/} = $str_tmp ]] || continue
#            [[ ${arr_tmp_opts[x]} = $str_tmp ]] || continue
            # options allowed multiple times
            if [[ ${arr_tmp_opts[x]} = @(-@(m|-match)) ]]; then
                :
            elif [[ ${arr_tmp_opts[x]} = --proto ]] && ((policy_match_index)) && \
                [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]; then
                : # always allow --proto if policy is the last match
            elif [[ ${arr_tmp_opts[x]} = -p ]] && ((policy_match_index)) && \
                [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy && -z $str_proto ]]
            then
                : # allow -p after first option of policy match was set, if not set before
            else # exceptions done
                if [[ $_DEBUG_NF_COMPLETION ]]; then
                    printf "removing option alias arr_tmp_opts[$x]: %s\n" "${arr_tmp_opts[x]}"
                fi
                unset arr_tmp_opts[x]
                continue 3
            fi
        done
    done
done
}

_iptables_dedupe_opts() {
local str_opt
# post process the reply - remove dupclicate options
for str_opt in "$@"; do # list an option only once
    # options allowed multiple time
    if [[ $str_opt = @(-m|--match|--mark) ]]; then
        printf "%s\n" "$str_opt"
        continue
    elif [[ $str_last_is = match ]]; then
        # per match options allowed multiple times
        if [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]; then
            if [[ $str_opt = @(--@reqid|spi|mode|tunnel-src|tunnel-dst|next) ]]
            then
                printf "%s\n" "$str_opt"
                continue
            elif [[ $str_opt = -p ]] && -z $str_proto ]]; then
                # show -p so we can specify protocol when last match is policy
                # because policy match also has --proto
                printf "%s\n" "$str_opt"
                continue
            fi
        elif [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = set ]]; then
            if [[ $str_opt = @(--match-set|--return-nomatch) ]]; then
                printf "%s\n" "$str_opt"
                continue
            fi
        elif [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = sctp ]]; then
            if [[ $str_opt = --chunk-types ]]; then
                printf "%s\n" "$str_opt"
                continue
            fi
        fi
    fi
    for ((i=1; i < ${#words[@]}-1; i++)); do
        [[ ${words[i]} != -* ]] && continue
        if [[ ${words[i]} = $str_opt ]]; then
            if [[ $_DEBUG_NF_COMPLETION ]]; then
                printf "removing dupe option: %s\n" "$str_opt"
            fi
            continue 2
        fi
    done
#    for i in ${!arr_cmd_opts[@]}; do
#        if [[ ${arr_cmd_opts[i]} = $str_opt ]]; then
#            if [[ $_DEBUG_NF_COMPLETION ]]; then
#                printf "removing dupe option: %s\n" "$str_opt"
#            fi
#            continue 2
#        fi
#    done
    printf "%s\n" "$str_opt"
done
}

_iptables_get_cw_idx() {
local -i idx index=0
for idx in ${!words[@]}; do
    if [[ ${words[idx]} = $1 ]]; then index=$idx
        # we don't break, as args could be used double.
        # choosing the last one, is ugly but less worse i think
        # TODO: find a solution
#        printf "%d\n" "$idx"
#        return 0
    fi
done
printf "%d\n" $((index ? index : -1))
}

_iptables_is_in_compwords() {
local -i cix
for ((cix=1; cix < ${#words[@]}; cix++)); do
    [[ $1 = ${words[cix]} ]] && return
done
}

_iptables_swap_array() {
local -i idx
local s_arr=$1 d_arr=$2
eval $d_arr'=()'
eval 'for idx in ${!'$s_arr'[@]};do '$d_arr'[$idx]="${'$s_arr'[$idx]}";done'
}

_iptables_build_comma_list() {
local lcur="$1" lmatch="" rlist="" prefix=""
shift
local arr_list=("${@}")
local str_pat=$(IFS=\|; printf "%s" "${arr_list[*]}")
compopt -o nospace
if [[ $lcur ]]; then
    if [[ ${lcur} = @($str_pat) ]]; then
        prefix="${lcur}," rlist="$lcur" lmatch=""
    elif [[ ${lcur:$((${#lcur}-1))} = , ]]; then
        prefix="${lcur}" rlist="$lcur" lmatch=""
    elif [[ ${lcur:$((${#lcur}-1))} != , ]]; then
        if [[ ${lcur##*,} != @($str_pat) ]]; then
            if [[ $lcur = *,* ]]; then
                prefix="${lcur%${lcur##*,}}"
                rlist="${lcur%${lcur##*,}}"
                lmatch="${lcur##*,}"
            else
                prefix="${lcur%${lcur##*,}}"
                rlist="${lcur%${lcur##*,}}"
                lmatch="${lcur}"
            fi
            [[ $prefix && ${prefix:$((${#prefix}-1))} != , ]] && prefix="${prefix},"
        else
            prefix="${lcur}," rlist="$lcur" lmatch=""
        fi
    fi
    for x in ${rlist//,/ }; do
        for i in ${!arr_list[@]}; do
            if [[ $x = ${arr_list[i]} ]]; then
                unset arr_list[i]
            fi
        done
    done
fi
((${#arr_list[@]} == 1)) && compopt +o nospace
COMPREPLY=( $( compgen -P "${prefix}" -W '${arr_list[@]}' -- "$lmatch" ) )
}

_iptables_build_ipset_flaglist() {
local lcur="$1" lmatch="" prefix=""
shift
local arr_list=("${@}")
local str_pat=$(IFS=\|; printf "%s" "${arr_list[*]}")
if [[ $lcur ]]; then
    if [[ ${lcur} = @($str_pat) ]]; then
        prefix="${lcur}," lmatch=""
    elif [[ ${lcur:$((${#lcur}-1))} = , ]]; then
        prefix="${lcur}" lmatch=""
    elif [[ ${lcur:$((${#lcur}-1))} != , ]]; then
        if [[ ${lcur##*,} != @($str_pat) ]]; then
            if [[ $lcur = *,* ]]; then
                prefix="${lcur%${lcur##*,}}" lmatch="${lcur##*,}"
            else
                prefix="${lcur%${lcur##*,}}" lmatch="${lcur}"
            fi
            [[ $prefix && ${prefix:$((${#prefix}-1))} != , ]] && prefix="${prefix},"
        else
            prefix="${lcur}," lmatch=""
        fi
    fi
fi
(($(IFS=,; set -- ${prefix}; printf "%d\n" $#) < 5)) && compopt -o nospace
COMPREPLY=( $( compgen -P "${prefix}" -W '${arr_list[@]}' -- "$lmatch" ) )
}

# -----------------------------------------------------------------
# main function
# -----------------------------------------------------------------

_iptables_complete() {
local cur prev cword words
local str_chain str_target str_jump str_action str_proto str_help
local ipt_version str_last_is str_var str_tmp str_regex
local str_table="filter"
local arr_tmp_opts=() arr_cmd_matches=() arr_cmd_opts=() arr_all_matches=()
local arr_last_opts=() arr_tmp=()
local -i i=x=y=got_action=got_bashcompl=inline_help=list_only=0
local -i rulenum=line_numbers=set_counters=target_index=policy_match_index=0
local -i last_index=0
local -r str_app="${COMP_WORDS[0]//*\//}"

# at least bash 3.0 is required
((${BASH_VERSINFO[0]} < 3)) && return 0

# old iptables versions, which don't have the `-S' option are not supported
"$str_app" -S OUTPUT 1 &>/dev/null || return

# iptables version TODO: checks re version
#ipt_version="$("$str_app" --version)"
#ipt_version="${ipt_version#$str_app v}"

local arr_opts=(
"-d --destination"
"-f --fragment"
"-g --goto"
"-h --help"
"-i --in-interface"
"-j --jump"
"-m --match"
"-n --numeric"
"-o --out-interface"
"-p --proto"
"-s --source"
"-t --table"
"-v --verbose"
"-x --exact"
"-A --append"
"-C --check"
"-D --delete"
"-E --rename-chain"
"-F --flush"
"-I --insert"
"-L --list"
"-N --new"
"-P --policy"
"-R --replace"
"-S --list-rules"
"-V --version"
"-X --delete-chain"
"-Z --zero"
--line-numbers
--set-counters
--modprobe=
)

local arr_command_opts=(
"-h --help"
"-j --jump"
"-m --match"
"-t --table"
"-v --verbose"
"-A --append"
"-C --check"
"-D --delete"
"-E --rename-chain"
"-F --flush"
"-I --insert"
"-L --list"
"-N --new"
"-P --policy"
"-R --replace"
"-S --list-rules"
"-V --version"
"-X --delete-chain"
"-Z --zero"
#--set-counters
)

local arr_command_opts_no_target=(
"-h --help"
"-m --match"
"-t --table"
"-v --verbose"
"-A --append"
"-C --check"
"-D --delete"
"-E --rename-chain"
"-I --insert"
"-N --new"
"-R --replace"
"-Z --zero"
--set-counters
)

local arr_rule_action_opts=(
"-d --destination"
"-f --fragment"
"-g --goto"
"-i --in-interface"
"-j --jump"
"-m --match"
"-o --out-interface"
"-p --proto"
"-s --source"
"-t --table"
"-v --verbose"
--modprobe=
)

local arr_min_opts=(
"-t --table"
"-v --verbose"
)

local arr_global_matches=(
"connmark --mark"
"mark --mark"
"sctp --chunk-types"
"set --match-set --return-nomatch"
)

local arr_proto_defs=(
"icmp 1"
"tcp 6"
"udp 17"
"dccp 33"
"esp 50"
"ah 51"
"sctp 132"
)

# target-name all|v4|v6 all|table1,table2,... option [...]
local arr_targets=(
"ACCEPT all all"
"AUDIT all all --type" # TODO: audit drop in nat table, really valid?
"CT all all \
    --notrack:ex:--helper,--ctevents,--expevents,--zone,--timeout \
    --helper:ex:--notrack \
    --ctevents:ex:--notrack \
    --expevents:ex:--notrack \
    --zone:ex:--notrack \
    --timeout:ex:--notrack" # TODO: get zone-ids?, get timeout policy names
"DROP all filter,mangle,security,raw"
"CHECKSUM all mangle --checksum-fill"
"CLASSIFY all all --set-class"
"CLUSTERIP v4 mangle --new --hashmode --clustermac --total-nodes --local-node --hash-init"
"CONNMARK all all \
    --save-mark:ex:--restore-mark,--set-xmark,--and-mark,--or-mark,--xor-mark,--set-mark:table:mangle \
    --restore-mark:ex:--save-mark,--set-xmark,--and-mark,--or-mark,--xor-mark,--set-mark:table:mangle \
    --mask:ex:--nfmask,--ctmask \
    --nfmask:ex:--mask,--ctmask \
    --ctmask:ex:--mask,--nfmask \
    --set-xmark:ex:--save-mark,--restore-mark,--and-mark,--or-mark,--xor-mark,--set-mark,--mask,--ctmask,--nfmask \
    --and-mark:ex:--save-mark,--restore-mark,--set-xmark,--or-mark,--xor-mark,--set-mark,--mask,--ctmask,--nfmask \
    --or-mark:ex:--save-mark,--restore-mark,--and-mark,--set-xmark,--xor-mark,--set-mark,--mask,--ctmask,--nfmask \
    --xor-mark:ex:--save-mark,--restore-mark,--and-mark,--or-mark,--set-xmark,--set-mark,--mask,--ctmask,--nfmask \
    --set-mark:ex:--save-mark,--restore-mark,--and-mark,--or-mark,--set-xmark,--xor-mark,--mask,--ctmask,--nfmask"
"CONNSECMARK all mangle,security --save:ex:--restore --restore:ex:--save"
"ECN all mangle --ecn-tcp-remove"
"DNAT v4 nat --to-destination --random:ex:--presistent --persistent:ex:--random"
"DSCP all mangle --set-dscp:ex:--set-dscp-class --set-dscp-class:ex:set-dscp"
"HL v6 mangle --hl-set:ex:--hl-dec,--hl-inc \
    --hl-dec:ex:--hl-set,--hl-inc \
    --hl-inc:ex:--hl-set,--hl-dec"
"HMARK all all \
    --hmark-tuple:ex:--hmark-src-prefix,--hmark-dst-prefix,--hmark-sport-mask,--hmark-dport-mask,--hmark-spi-mask,--hmark-proto-mask \
    --hmark-mod --hmark-offset \
    --hmark-src-prefix:ex:--hmark-tuple \
    --hmark-dst-prefix:ex:--hmark-tuple \
    --hmark-sport-mask:ex:--hmark-tuple,--hmark-spi-mask \
    --hmark-dport-mask:ex:--hmark-tuple,--hmark-spi-mask \
    --hmark-spi-mask:ex:--hmark-tuple,--hmark-sport-mask,--hmark-dport-mask \
    --hmark-proto-mask:ex:--hmark-tuple \
    --hmark-rnd" # TODO: required options | check used options form -tuple completion
"IDLETIMER all all --timeout --label"
"LED all all --led-trigger-id --led-delay --led-always-blink"
"LOG all all --log-level --log-prefix --log-tcp-sequence --log-tcp-options --log-ip-options --log-uid"
"MASQUERADE v4 nat --to-ports:proto:tcp,udp --random:proto:tcp,udp" # TODO: only tcp,udp? what about dccp,sctp,udplite?
"MIRROR v4 mangle" # TODO: tables? don't have it
"NETMAP v4 nat --to"
"NFLOG all all --nflog-group --nflog-prefix --nflog-range --nflog-threshold"
"NFQUEUE all all --queue-num:ex:--queue-balance \
   --queue-balance:ex:--queue-num --queue-bypass"
"NOTRACK all raw"
"RATEEST all all --rateest-name --rateest-interval --rateest-ewmalog"
"REDIRECT v4 nat --to-ports:proto:tcp,udp --random:proto:tcp,udp" # TODO: only tcp,udp? what about dccp,sctp,udplite?
"REJECT all filter --reject-with"
"SECMARK all mangle,security --selctx" # TODO: retrieve security_context
"SET all all --add-set:ex:--del-set --del-set:ex:--add-set --timeout --exist"
"SNAT v4 nat --to-source --random:ex:--persistent --persistent:ex:--random"
"TEE all all --gateway" # TODO: really valid in all tables? cmdline does not forbid it
"TCPMSS all mangle --set-mss:ex:--clamp-mss-to-pmtu --clamp-mss-to-pmtu:ex:--set-mss"
"TCPOPTSTRIP all mangle --strip-options"
"TOS all mangle --set-tos:ex:--and-tos,--or-tos,--xor-tos \
    --and-tos:ex:--set-tos,--or-tos, --xor-tos \
    --or-tos:ex:--set-tos,--and-tos,--xor-tos \
       --xor-tos:ex:--set-tos,--and-tos,--or-tos"
"TPROXY all mangle --on-port:proto:tcp,udp --on-ip:proto:tcp,udp --tproxy-mark"
"TRACE all raw"
"TTL v4 mangle --ttl-set:ex:--ttl-dec,--ttl-inc \
   --ttl-dec:ex:--ttl-set,--ttl-inc \
   --ttl-inc:ex:--ttl-set,--ttl-dec"
"ULOG v4 all --ulog-nlgroup --ulog-prefix --ulog-cprange --ulog-qthreshold"
)

# match-name all|v4|v6 all|table1,table2,... option[,alias] [...]
local arr_matches=(
"tcp all all --source-port,--sport --destination-port,--dport --tcp-flags --syn --tcp-option"
"udp all all --source-port,--sport --destination-port,--dport"
"icmp v4 all --icmp-type"
"icmp6 v6 all --icmpv6-type"
"addrtype all all --src-type --dst-type --limit-iface-in --limit-iface-out"
"ah v4 all --ahspi"
"ah v6 all --ahspi --ahlen --ahres"
"cluster all all --cluster-total-nodes --cluster-local-node --cluster-local-nodemask --cluster-hash-seed"
"comment all all --comment"
"connbytes all all --connbytes --connbytes-dir --connbytes-mode"
"connlimit all all --connlimit-upto:ex:--connlimit-above \
    --connlimit-above:ex:--connlimit-upto \
    --connlimit-mask --connlimit-saddr --connlimit-daddr" # TODO: valid in all tables?
"connmark all all --mark"
"conntrack all all --ctstate --ctproto --ctorigsrc --ctorigdst --ctreplsrc \
    --ctrepldst --ctorigsrcport --ctorigdstport --ctreplsrcport \
    --ctrepldstport --ctstatus --ctexpire --ctdir"
"cpu all all --cpu"
"dccp all all --source-port,--sport --destination-port,--dport --dccp-types --dccp-option"
"devgroup all all --src-group --dst-group" # TODO: retrieve names of device groups
"dscp all all --dscp:ex:--dscp-class --dscp-class:ex:--dscp"
"dst v6 all --dst-len --dst-opts" # TODO: valid values, --dst-opts value only twice?
"ecn all all --ecn-tcp-cwr --ecn-tcp-ece --ecn-ip-ect"
"esp all all --espspi"
"eui64 v6 all"
"frag v6 all --fragid --fraglen --fragres --fragfirst --fragmore --fraglast"
"hashlimit all all --hashlimit-upto:ex:--hashlimit-above \
    --hashlimit-above:ex:--hashlimit-upto \
    --hashlimit-burst --hashlimit-mode --hashlimit-srcmask --hashlimit-dstmask \
    --hashlimit-name --hashlimit-htable-size --hashlimit-htable-max \
    --hashlimit-htable-expire --hashlimit-htable-gcinterval" # TODO: required options
"helper all all --helper" # TODO: check if we can retrieve list of helpers
"hbh v6 all --hbh-len --hbh-opts"
"hl v6 all --hl-eq:ex:--hl-gt,--hl-lt \
    --hl-gt:ex:--hl-eq,--hl-lt \
    --hl-lt:ex:--hl-eq,--hl-gt"
"iprange all all --src-range --dst-range"
"ipv6header v6 all --header --soft"
"ipvs all all --ipvs --vproto --vaddr --vport --vdir --vmethod --vportctl"
"length all all --length"
"mac all all --mac-source"
"mh v6 all --mh-type" # TODO: named mh-types, ip6tables -p ipv6-mh -h does not display any
"owner all all --uid-owner --gid-owner --socket-exists"
"quota all all --quota"
"limit all all --limit --limit-burst"
"mark all all --mark"
"multiport all all --source-ports,--sports:ex:--ports \
    --destination-ports,--dports:ex:--ports \
    --ports:ex:--source-ports,--sports,--destination-ports,--dports"
"nfacct all all --nfacct-name"
"osf all all --genre --ttl --log" # TODO: retrieve valid genre strings?
"physdev all all --physdev-in --physdev-out --physdev-is-in --physdev-is-out --physdev-is-bridged"
"pkttype all all --pkt-type"
"policy all all --dir --pol --strict --reqid --spi --proto --mode \
    --tunnel-src:optis:mode=tunnel --tunnel-dst:optis:mode=tunnel --next" # TODO: reqid value?
"rateest all all --rateest-delta \
    --rateest-lt:ex:--rateest-gt,--rateest-eq \
    --rateest-gt:ex:--rateest-lt,--rateest-eq \
    --rateest-eq:ex:--rateest-lt,--rateest-gt \
    --rateest:ex:--rateest1,--rateest2,--rateest-bps1,--rateest-bps2,--rateest-pps1,--rateest-pps2 \
    --rateest1:ex:--rateest,--rateest-bps,--rateest-pps \
    --rateest2:ex:--rateest,--rateest-bps,--rateest-pps \
    --rateest-bps:ex:--rateest1,--rateest2,--rateest-bps1,--rateest-bps2,--rateest-pps1,--rateest-pps2 \
    --rateest-pps:ex:--rateest1,--rateest2,--rateest-bps1,--rateest-bps2,--rateest-pps1,--rateest-pps2 \
    --rateest-bps1:ex:--rateest,--rateest-bps,--rateest-pps \
    --rateest-bps2:ex:--rateest,--rateest-bps,--rateest-pps \
    --rateest-pps1:ex:--rateest,--rateest-bps,--rateest-pps \
    --rateest-pps2:ex:--rateest,--rateest-bps,--rateest-pps"
"realm v4 all --realm"
"recent all all --set:ex:--rcheck,--update,--remove \
    --rcheck:ex:--set,--update,--remove \
    --update:ex:--set,--rcheck,--remove \
    --remove:ex:--set,--rcheck,--update \
    --rsource --rdest --mask --seconds --reap --hitcount"
"rpfilter all mangle,raw --loose --validmark --accept-local"
"rt v6 all --rt-type --rt-segsleft --rt-len --rt-0-res --rt-0-addrs --rt-0-not-strict"
"sctp all all --source-port,--sport --destination-port,--dport --chunk-types"
"socket all all --transparent" # TODO: was --transparent option available from the beginning?
"set all all --match-set --return-nomatch"
"state all all --state"
"statistic all all --mode --probability:optis:--mode=random \
    --every:optis:--mode=nth --packet:optis:--mode=nth"
"string all all --algo --from --to \
    --string:ex:--hex-string --hex-string:ex:--string"
"tcpmss all all --mss"
"time all all --datestart --timestart --timestop --monthdays --weekdays --kerneltz" # TODO: --date[start|stop] value verification
"tos all all --tos"
"ttl v4 all --ttl-eq:ex:--ttl-gt,--ttl-lt \
    --ttl-gt:ex:--ttl-eq,--ttl-lt \
    --ttl-lt:ex:--ttl-eq,--ttl-gt"
"u32 all all --u32"
"unclean v4 all" # don't have it
)

local arr_icmp_types=( any
echo-reply,pong
destination-unreachable
network-unreachable
host-unreachable
protocol-unreachable
port-unreachable
fragmentation-needed
source-route-failed
network-unknown
host-unknown
network-prohibited
host-prohibited
TOS-network-unreachable
TOS-host-unreachable
communication-prohibited
host-precedence-violation
precedence-cutoff
source-quench
redirect
network-redirect
host-redirect
TOS-network-redirect
TOS-host-redirect
echo-request,ping
router-advertisement
router-solicitation
time-exceeded,ttl-exceeded
ttl-zero-during-transit
ttl-zero-during-reassembly
parameter-problem
ip-header-bad
required-option-missing
timestamp-request
timestamp-reply
address-mask-request
address-mask-reply
)
local arr_icmp6_types=(
destination-unreachable
no-route
communication-prohibited
address-unreachable
port-unreachable
packet-too-big
time-exceeded,ttl-exceeded
ttl-zero-during-transit
ttl-zero-during-reassembly
parameter-problem
bad-header
unknown-header-type
unknown-option
echo-request,ping
echo-reply,pong
router-solicitation
router-advertisement
neighbour-solicitation,neighbor-solicitation
neighbour-advertisement,neighbor-advertisement
redirect
)

COMPREPLY=()
#COMP_WORDBREAKS=$' \t\n"\'><=;|&(:'

# expecting _get_comp_words_by_ref() to exist from bash_completion
if declare -f _get_comp_words_by_ref &>/dev/null; then got_bashcompl=1
    _get_comp_words_by_ref -n : cur prev cword words || return
else # not so neat, but a workaround
    COMP_WORDBREAKS="${COMP_WORDBREAKS//:/}"
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    cword=$COMP_CWORD
    for i in ${!COMP_WORDS[@]}; do words[i]="${COMP_WORDS[i]}"; done
fi

#_DEBUG_NF_COMPLETION=Y
if [[ $_DEBUG_NF_COMPLETION ]]; then
    printf "\nCOMP_WORDBREAKS: <%s>\n" "$COMP_WORDBREAKS"
    printf "COMP_LINE: <%s>\n" "$COMP_LINE"
    printf "COMP_TYPE: <%s>\n" "$COMP_TYPE"
    printf "COMP_POINT: <%s>\n" "$COMP_POINT"
    printf "COMP_KEY: <%s>\n" "$COMP_KEY"
    printf "COMP_CWORD: <%s>\n" "$COMP_CWORD"
    printf "cword: <%s>\n" "$cword"
    printf "words:\n" "<%s>\n" "${words[@]}"
    printf "cur: <%s> prev: <%s>\n" "$cur" "$prev"
fi

for ((i=1; i < ${#words[@]}-1; i++)); do
    case ${words[i]} in
        -j|--jump|-g|--goto)
            ((cword > last_index && cword > i)) && str_last_is=target
            str_jump=${words[i]}
            str_target="${words[i+1]}" target_index=$((i+1)) last_index=$i
            arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]}
        ;;
        -t|--table)
            if ((cword > last_index && cword > i)); then
                str_last_is=option
                arr_last_opts+=(${words[i]})
            fi
               str_table="${words[i+1]}"
            arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]}
        ;;
        -m|--match)
            if ((cword > last_index && cword > i)); then
                str_last_is=match
                arr_cmd_matches[${#arr_cmd_matches[@]}]="${words[i+1]}"
            fi
            last_index=$i
            arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]}
#            if [[ ${words[i+1]} ]]; then
                arr_all_matches[${#arr_all_matches[@]}]="${words[i+1]}"
                [[ ${words[i+1]} = policy ]] && policy_match_index=$((i+1))
#            fi
        ;;
        -p|--proto)
            # if proto is a known match, add it to list of matches
            arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]}
            if [[ ${words[i]} = --proto ]]; then
                if ((${#arr_cmd_matches[@]})) && \
                    [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]
                then
                    continue # policy match also has --proto !!DAMN!!
                fi
            fi
            if ((cword > last_index && cword > i)); then
                str_last_is=option
                arr_last_opts+=(${words[i]})
            fi
            str_proto="${words[i+1]}"
            if [[ $str_proto = +([[:digit:]]) ]]; then
                # translate known numeric proto specs into names
                for x in ${!arr_proto_defs[@]}; do
                    set -- ${arr_proto_defs[x]}
                    if ((str_proto == $2)); then
                        str_proto=$1
                        if ((cword > last_index && cword > i)); then
                            str_last_is=match
                            arr_cmd_matches[${#arr_cmd_matches[@]}]="$str_proto"
                        fi
                        break
                    fi
                done
            else
                if ((cword > last_index && cword > i)); then
                    _iptables_is_match "${words[i+1]}" && str_last_is=match && \
                    arr_cmd_matches[${#arr_cmd_matches[@]}]="$str_proto"
                fi
            fi
            last_index=$i
        ;;
        @(-@(A|-append|C|-check|E|-rename-chain|F|-flush|P|-policy|X|-delete-chain)))
            let got_action+=1
            ((cword > last_index && cword > i)) && str_last_is=action
            last_index=$i
            str_chain="${words[i+1]}" str_action=${words[i]}
            arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]}
        ;;
        @(-@(D|-delete|I|-insert|R|-replace|L|-list|S|-list-rules|Z|-zero)))
            let got_action+=1
            ((cword > last_index && cword > i)) && str_last_is=action
            last_index=$i str_chain="${words[i+1]}"
            str_action=${words[i]} rulenum=$(_iptables_get_rulenum $i)
            arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]}
        ;;
        -N|--new)
            if ! [[ ${words[i]} = --new && $str_target = CLUSTERIP ]]; then
                let got_action+=1
                ((cword > last_index && cword > i)) && str_last_is=action
                str_action=${words[i]}
                last_index=$i str_chain="${words[i+1]}"
                arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]}
            fi
        ;;
        --line-numbers)
#            line_numbers=1
            list_only=1
            if ((cword > last_index && cword > i)); then
                str_last_is=option
                arr_last_opts+=(${words[i]})
            fi
            last_index=$i
            rulenum=$(_iptables_get_rulenum $i)
            arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]}
        ;;
        --set-counters)
            set_counters=1
            if ((cword > last_index && cword > i)); then
                str_last_is=option
                arr_last_opts+=(${words[i]})
            fi
            last_index=$i
            arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]}
        ;;
        --exact|-x|-n|--numeric)
            list_only=1
            if ((cword > last_index && cword > i)); then
                str_last_is=option
                arr_last_opts+=(${words[i]})
            fi
            last_index=$i
            arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]}
        ;;
        -d|--destination|-f|-fragment|-i|--in-interface|-o|--out-interface|\
            -s|--source|-v|--verbose|--modprobe=)
            if ((cword > last_index && cword > i)); then
                str_last_is=option
                arr_last_opts+=(${words[i]})
            fi
            last_index=$i
            arr_cmd_opts[${#arr_cmd_opts[@]}]=${words[i]}
        ;;
    esac
done
if ((got_action > 1)); then # allow only one main command
    return 0
fi

# init with empty string so we don't run into bad subscript error
((${#arr_cmd_matches[@]})) || arr_cmd_matches[0]=""
((${#arr_cmd_opts[@]})) || arr_cmd_opts[0]=""
((${#arr_last_opts[@]})) || arr_last_opts[0]=""

if ! ((got_action)); then
    if [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} && \
        -z $str_target ]] && ((cword < 7))
    then inline_help=1
    elif [[ $str_target ]] && \
        [[ -z ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} ]] && ((cword < 7))
    then inline_help=1
    fi
fi

if [[ $_DEBUG_NF_COMPLETION ]]; then
    printf "arr_cmd_matches[*]: %s\n" "${arr_cmd_matches[*]}"
    printf "str_proto: %s\n" "$str_proto"
    printf "str_chain: %s\n" "$str_chain"
    printf "str_target: %s\n" "$str_target"
fi


# time to match on current word request
case "$cur" in
    -*) # any option is requested
        case "$prev" in # depend on previous option - terminating choices first
            @(-@(A|-append|C|-check|D|-delete|E|-rename-chain|I|-insert|N|-new|P|-policy|R|-replace|V|-version)))
                if ! [[ $prev = --new && $str_target = CLUSTERIP ]]; then
                    return 0 # command option not valid at this context
                fi
            ;;
            @(--@(add-set|del-set|match-set))) # set match and SET target
                # if the set names start with a dash
                COMPREPLY=( $( compgen -W '$(_iptables_get_setnames)' -- $cur ) )
                ((got_bashcompl)) && __ltrim_colon_completions "$cur"
                return 0
            ;;
            @(-@(j|jump|g|goto|i|-in-interface|o|-out-interface|m|-match|p|-proto|s|-source|d|-destination|t|-table|-h|--help|-set-counters)))
                return 0 # option not valid at this context
            ;;
            @(--@(dport|destination-port|sport|source-port|icmp-type|icmpv6-type|tcp-option|tcp-flags)))
                return 0 # match option not valid at this context
            ;;
            @(--@(comment|chunk-types|cpu|connbytes|connbytes-dir|connbytes-mode|ecn-ip-ect|helper)))
                return 0 # match option not valid at this context
            ;;
            @(--@(length|mac-source|mark|mss|pkt-type|quota|src-range|dst-range|src-type|dst-type|uid-owner|gid-owner|realm|tos)))
                return 0 # match option not valid at this context
            ;;
            @(--@(algo|from|to|string|hex-string|mode|probability|every|packet|rt-type|rt-segsleft|rt-len|rt-0-addrs)))
                return 0 # match option not valid at this context
            ;;
            @(--@(physdev-in|physdev-out|genre|ttl|log|limit|limit-burst|mh-type|nfacct-name|fragid|fraglen|ahspi|espspi)))
                return 0 # match option not valid at this context
            ;;
            @(--@(connlimit-upto|connlimit-above|connlimit-mask|src-group|dst-group|mask|seconds|hitcount|state|header)))
                return 0 # match option not valid at this context
            ;;
            @(--@(dccp-option|dccp-types|dst-len|dst-opts|hbh-len|hbh-opts|datestart|datestop|timestart|timestop|monthdays|weekdays)))
                return 0 # match option not valid at this context
            ;;
            @(--@(cluster-total-nodes|cluster-local-node|cluster-local-nodemask|cluster-hash-seed)))
                return 0 # cluster match option not valid at this context
            ;;
            @(--ct@(state|proto|origsrc|origdst|replsrc|repldst|origsrcport|origdstport|replsrcport|repldstport|status|expire|dir)))
                return 0 # conntrack match option not valid at this context
            ;;
            @(--@(dports|destination-ports|sports|source-ports|ports)))
                return 0 # multiport match option not valid at this context
            ;;
            @(--@(dir|pol|reqid|spi|tunnel-src|tunnel-dst)))
                return 0 # policy match option not valid at this context
            ;;
            @(--hashlimit-@(upto|above|burst|mode|srcmask|dstmask|name|htable-size|htable-max|htable-expire|htable-gcinterval)))
                return 0 # hashlimit match option not valid at this context
            ;;
            @(--@(vproto|vaddr|vport|vdir|vmethod|vportctl)))
                return 0 # ipvs match option not valid at this context
            ;;
            @(--rateest?(1|2|-bps|-pps|-bps1|-bps2|-pps1|-pps2)))
                return 0 # rateest match option not valid at this context
            ;;
            @(--@(set-xmark|and-mark|or-mark|xor-mark|set-mark|nfmask|ctmask)))
                return 0 # CONNMARK target option not valid at this context
            ;;
            @(--hmark-@(tuple|mod|offset|src-prefix|dst-prefix|sport-mask|dport-mask|spi-mask|proto-mask|rnd)))
                return 0 # HMARK target option not valid at this context
            ;;
            @(--@(ctevents|expevents|zone|timeout)))
                return 0 # CT target option not valid at this context
            ;;
            @(--@(gateway|reject-with|to-destination|to-source|to-ports|to|selctx|set-class|set-mss|timeout|label|type)))
                return 0 # target option not valid at this context
            ;;
            @(--@(queue-num|queue-balance|set-dscp|dscp|dscp-class|set-dscp-class|set-tos|and-tos|or-tos|xor-tos|strip-options)))
                return 0 # target option not valid at this context
            ;;
            @(--@(led-trigger-id|led-delay|rateest-name|rateest-interval|rateest-ewmalog|on-port|on-ip|tproxy-mark|u32)))
                return 0 # target option not valid at this context
            ;;
            @(--@(hl-set|hl-dec|hl-inc|hl-eq|hl-gt|hl-lt|ttl-set|ttl-dec|ttl-inc|ttl-eq|ttl-gt|ttl-lt)))
                return 0 # target option not valid at this context
            ;;
            @(--@(hashmode|clustermac|total-nodes|local-node|hash-init)))
                return 0 # CLUSTERIP target option not valid at this context
            ;;
            @(--@(log-level|log-prefix|nflog-group|nflog-prefix|nflog-range|nflog-threshold|\
                ulog-nlgroup|ulog-prefix|ulog-cprange|ulog-qthreshold)))
                return 0 # [U|NF]LOG target option not valid at this context
            ;;
        esac
        i=$((cword - 1))
        if ((i > 1)); then # depend on option before previous option
            case "${words[i-1]}" in
                -E|--rename-chain|-P|--policy|-R|--replace|--set-counters)
                    return 0
                ;;
                @(--@(add-set|del-set|match-set))) # expecting set flag
                    return 0
                ;;
                @(--@(hl-set|hl-dec|hl-inc|ttl-set|ttl-dec|ttl-inc|ttl-eq|ttl-gt|ttl-lt|dccp-option|\
                    nflog-group|nflog-range|nflog-threshold|timeout|total-nodes|local-node|led-delay|\
                    ulog-cprange|ulog-qthreshold|from|to|every|packet|rt-type|rt-len|ttl|log|\
                    limit-burst|hl-eq|hl-gt|hl-lt|fraglen|connlimit-upto|connlimit-above|ahlen|\
                    cluster-total-nodes|cluster-local-node|spi|seconds|hitcount|zone|hbh-len|dst-len|\
                    hmark-offset)))
                    [[ $prev = +([[:digit:]]) ]] || return 0 # digit value expected
                ;;
                @(--hashlimit-@(burst|buckets|entries|htable-expire|htable-gcinterval)))
                    [[ $prev = +([[:digit:]]) ]] || return 0 # hashlimit match - digit value expected
                    return 0
                ;;
                @(--@(hashlimit-srcmask|hashlimit-dstmask)))
                    [[ $prev = +([[:digit:]]) ]] || return 0
                    ((prev > 32)) && return 0
                ;;
                --hmark-mod) # HMARK target - int >0
                    [[ $prev = +([[:digit:]]) ]] || return 0
                    ((prev > 0)) || return 0
                ;;
                --hmark-sport-mask|--hmark-dport-mask) # HMARK target - 16 bit xdigit
                    [[ $prev = +([[:xdigit:]]) ]] || return 0
                    ((prev >= 0 && prev <= 0xFFFF)) || return 0
                ;;
                --mask) # CONNMARK target and recent match have --mask
                    if [[ $str_target = CONNMARK ]]; then
                        [[ $prev = @(0x+([[:xdigit:]])|+([[:digit:]])) ]] || return 0
                        ((prev <= 4294967295)) || return 0
                    elif [[ ${arr_matches[${#arr_matches[@]}-1]} = recent ]]; then
                        [[ $prev = +([[:digit:]]) ]] || return 0
                        ((prev > 32)) && return 0
                    fi
                ;;
                --hmark-proto-mask) # 8bit digit or xdigit value | HMARK target
                    [[ $prev = @(0x+([[:xdigit:]])|+([[:digit:]])) ]] || return 0
                    ((prev <= 0xFF)) || return 0
                ;;
                --cluster-local-nodemask|ct-mask|nf-mask|and-mark|or-mark|xor-mark|hmark-spi-mask|hmark-rnd)
                    # 32bit digit or xdigit value expected
                    [[ $prev = @(0x+([[:xdigit:]])|+([[:digit:]])) ]] || return 0
                    ((prev <= 4294967295)) || return 0
                ;;
                @(--@(mark|set-mark|set-xmark|tproxy-mark))) # [CONN]MARK/TPROXY target mark[/mask], [conn]mark match
                    [[ $prev = @(+([[:digit:]])|0x+([[:xdigit:]]))?(/@(+([[:digit:]])|0x+([[:xdigit:]]))) ]] || return 0
                    for str_tmp in ${prev//\// }; do
                        ((str_tmp <= 4294967295)) || return 0
                    done
                ;;
                # numeric range definition with `:' expected -> COMP_WORDBREAKS `:' problem
                @(--@(fragid|mss|rt-segsleft|ctexpire)))
                    [[ $prev = +([[:digit:]])?(:+([[:digit:]])) ]] || return 0
                ;;
                --ahspi|--espspi) # 32 bit range values -> COMP_WORDBREAKS `:' problem
                    [[ $prev = +([[:digit:]])?(:+([[:digit:]])) ]] || return 0
                    for str_tmp in ${prev/:/ }; do
                        ((str_tmp <= 4294967295)) || return 0
                    done
                ;;
                --connlimit-mask) # connlimit match
                    [[ $prev = +([[:digit:]]) ]] || return 0
                    if [[ $str_app = iptables ]]; then
                        ((prev > 32)) && return 0
                    elif [[ $str_app = ip6tables ]]; then
                        ((prev > 128)) && return 0
                    fi
                ;;
                --label) # IDLETIMER target
                    ((${#prev} > 27)) && return 0
                ;;
                --log-prefix) # LOG target
                    ((${#prev} > 29)) && return 0
                ;;
                --nflog-prefix) # NFLOG target
                    ((${#prev} > 64)) && return 0
                ;;
                --ulog-prefix) # ULOG target
                    ((${#prev} > 32)) && return 0
                ;;
                @(--@(limit|hashlimit-upto|hashlimit-above))) # [hash]limit match
                    [[ $prev = +([[:digit:]])?(/@(second|minute|hour|day)) ]] || return 0
                ;;
                --probability) # statistic match
                    [[ $prev = @(0?(.[0-9])|1?(.0)) ]] || return 0
                ;;
                --queue-num) # NFQUEUE target
                    [[ $prev = +([[:digit:]]) ]] || return 0
                    ((prev > 65535)) && return 0
                ;;
                --ulog-nlgroup) # ULOG target
                    [[ $prev = +([[:digit:]]) ]] || return 0
                    ((prev < 1 || prev > 32)) && return 0
                ;;
                @(--@(dscp|set-dscp))) # dscp match and DSCP target - digit or 0xxdigit
                    [[ $prev = @(+([[:digit:]])|0x+([[:xdigit:]])) ]] || return 0
                    ((prev > 63)) && return 0
                ;;
                --hbh-opts|--dst-opts) # hbh and dst match
                    [[ $prev = +([[:digit:]]):+([[:digit:]])*(,+([[:digit:]]):+([[:digit:]])) ]] || return 0
                ;;
                --to-ports) # MASQUERADE/REDIRECT target
                    [[ $prev = +([[:digit:]])-+([[:digit:]]) ]] || return 0
                ;;
                --timestart|--timestop) # time match
                    [[ $prev = +([[:digit:]])+([[:digit:]]):+([[:digit:]])+([[:digit:]])?(:+([[:digit:]])+([[:digit:]])) ]] || return 0
                ;;
                --monthdays) # time match
                    [[ $prev = +([[:digit:]])*(,+([[:digit:]])) ]] || return 0
                    for str_tmp in ${prev//,/ }; do
                        ((str_tmp < 1 || str_tmp > 31)) && return 0
                    done
                ;;
                --weekdays) # time match
                    str_tmp="Mo|Mon|Tu|Tue|We|Wed|Th|Thu|Fr|Fri|Sa|Sat|Su|Sun"
                    if [[ $prev = @(@($str_tmp)|+([[:digit:]]))*(,@(@($str_tmp)|+([[:digit:]]))) ]]
                    then
                        for str_var in ${prev//,/ }; do
                            if [[ $str_var = +([[:digit:]]) ]]; then
                                ((str_var < 1 || str_var > 7)) && return 0
                            elif [[ $str_var = @($str_tmp)*(,@($str_tmp)) ]]; then :
                            else return 0
                            fi
                        done
                    else return 0
                    fi
                ;;
            esac
        fi
        case "$str_target" in
            CLUSTERIP) # CLUSTERIP rules must start with --new
                if [[ ${words[target_index+2]} && ${words[target_index+1]} != --new ]]
                then return 0
                fi
            ;;
        esac

        # done with terminating conditions, collect information
        # we have a rulenumber given, under certain commands,
        # this reduces amount of valid options
        if ((rulenum)) && \
            [[ $str_action != @(-@(L|-list|S|-list-rules|I|-insert|R|-replace)) ]]
        then _iptables_swap_array arr_min_opts arr_tmp_opts
        #elif ((line_numbers && ! got_action)); then
        elif ((list_only && ! got_action)); then
            arr_tmp_opts=(
            "-h --help"
            "-t --table"
            "-v --verbose"
            "-L --list"
            "-n --numeric"
            "-x --exact"
            )
        elif ((set_counters && ! got_action)); then
            arr_tmp_opts=(
            "-h --help"
            "-j --jump"
            "-m --match"
            "-t --table"
            "-v --verbose"
            "-A --append"
            "-I --insert"
            )
        else
            case "$str_action" in
                -A|--append|-I|--insert)
                    arr_rule_action_opts[${#arr_rule_action_opts[@]}]="--set-counters"
                    _iptables_swap_array arr_rule_action_opts arr_tmp_opts
                ;;
                -C|--check|-D|--delete|-R|--replace)
                    _iptables_swap_array arr_rule_action_opts arr_tmp_opts
                ;;
                -E|--rename-chain|-F|--flush|-N|--new|-X|--delete-chain|\
                    -P|--policy|-S|--list-rules|-Z|--zero)
                    _iptables_swap_array arr_min_opts arr_tmp_opts
                ;;
                -L|--list)
                    for str_tmp in "-n --numeric" "-t --table" "-v --verbose" \
                        "-x --exact" "--line-numbers"; do
                        arr_tmp_opts[${#arr_tmp_opts[@]}]="$str_tmp"
                    done
                ;;
            esac
        fi

        if [[ $str_jump ]]; then # remove mutual exclusive jump/goto
            case "$str_jump" in
                -j|--jump) str_tmp="-g|--goto" ;;
                -g|--goto) str_tmp="-j||--jump" ;;
            esac
            for x in ${!arr_tmp_opts[@]}; do
                if [[ ${arr_tmp_opts[x]} = @($str_tmp) ]]; then
                    unset arr_tmp_opts[x]
                    break
                fi
            done
        fi

        if ! ((got_action)); then
            # if we don't know the main command and haven't defined remaining options
            # while parsing existing cmdline, set option list to main command list
            if [[ $str_target ]]; then
                ((${#arr_tmp_opts[@]})) || _iptables_swap_array arr_command_opts_no_target arr_tmp_opts
                if [[ $str_target = @(ACCEPT|DROP) ]]; then
                    arr_tmp_opts+=("-P --policy")
                fi
            else
                # env var controls wether we show all or a subset of options
                if [[ ${_IPTABLES_OPTS_ON_START:=actions} = actions ]]; then
                    ((${#arr_tmp_opts[@]})) || _iptables_swap_array arr_command_opts arr_tmp_opts
                else
                    ((${#arr_tmp_opts[@]})) || _iptables_swap_array arr_opts arr_tmp_opts
                fi
            fi
        fi
        case "$cur" in # show either short or long options (single or double dash)
            -?(+([[:word:]]))) # any short-option is requested
                arr_tmp_opts=( "${arr_tmp_opts[@]/% --*/}" )
                ((inline_help)) && str_help=-h
            ;;
        --?(+([[:word:]]))*) # any long-option is requested
                arr_tmp_opts=( "${arr_tmp_opts[@]/#-* }" )
                ((inline_help)) && str_help=--help
            ;;
        esac
        if ((${#words[@]} > 2)); then
            # we got one option, so remove options that are mutual exclusive to all others
            for i in ${!arr_tmp_opts[@]}; do
                if [[ ${arr_tmp_opts[i]} = @(-@(V|-version)) ]]; then
                    unset arr_tmp_opts[i]
                    break
                fi
            done
        fi

        # from here we start to set a compreply
        if _iptables_is_option "$prev"; then
            _iptables_dedupe_opt_alias
            COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts ${arr_tmp_opts[@]})' -- $cur ) )
        elif _iptables_is_target "$prev" && ((cword == target_index)); then
            # targets with no option
            if [[ $prev != @(ACCEPT|DROP|MIRROR|NOTRACK|TRACE) ]]; then
                COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts \
                    $(_iptables_get_target_opts "$prev") $str_help)' -- $cur ) )
            fi
        elif _iptables_is_match "$prev" && [[ ${words[cword-2]} = @(-m|--match) ]]
        then
            if [[ $prev = @(unclean|eui64) ]]; then # modules with no options
                _iptables_dedupe_opt_alias
                COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts ${arr_tmp_opts[@]} $str_help)' -- $cur ) )
            else
                COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts \
                    $(_iptables_get_match_opts "$prev") $str_help)' -- $cur ) )
            fi
        elif [[ $prev = \! && ${words[cword-3]} = @(-m|--match) ]] && _iptables_is_match "${words[cword-2]}"
        then
            COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts \
                $(_iptables_get_match_opts "${words[cword-2]}") $str_help)' -- $cur ) )
        else
            case "$str_last_is" in
                target)
                    _iptables_dedupe_opt_alias
                    if [[ $str_target = @(ACCEPT|DROP|MIRROR|NOTRACK|TRACE) ]]; then
                        # targets with no option
                        COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts ${arr_tmp_opts[@]})' -- $cur ) )
                    else
                        COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts \
                            $(_iptables_get_target_opts "$str_target") ${arr_tmp_opts[@]})' -- $cur ) )
                    fi
                ;;
                match)
                    _iptables_dedupe_opt_alias
                    COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts \
                        $(_iptables_get_match_opts "${arr_cmd_matches[${#arr_cmd_matches[@]}-1]}") \
                        ${arr_tmp_opts[@]})' -- $cur ) )
                ;;
                option)
                    _iptables_dedupe_opt_alias
                    if [[ ${arr_last_opts[${#arr_last_opts[@]}-1]} = @(-p|--proto) && \
                        ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = @(icmp|tcp|udp|esp|ah|dccp|sctp|) ]]
                    then # also load match options if last option was -p|--proto and also is a known match
                        COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts \
                            $(_iptables_get_match_opts "${arr_cmd_matches[${#arr_cmd_matches[@]}-1]}") \
                            ${arr_tmp_opts[@]})' -- $cur ) )
                    else
                        COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts ${arr_tmp_opts[@]})' -- $cur ) )
                    fi
                ;;
            esac
        fi
        if ! ((${#COMPREPLY[@]})); then
            # by default display all options if no reply was previously found
            _iptables_dedupe_opt_alias
            COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts ${arr_tmp_opts[@]})' -- $cur ) )
        fi
    ;;
    *) # not an option
        if [[ -z $cur ]] && ((${#words[@]} == 2)); then
            # no option given, present main command list first
            COMPREPLY=( ${arr_command_opts[@]} )
            return 0
        fi
        case "$prev" in # depend on previous option
            -h|--help|-V|--version)
                return 0
            ;;
            @(-@(A|-append|C|-check|D|-delete|F|-flush|I|-insert|L|-list|S|-list-rules|X|-delete-chain|Z|-zero)))
                # chain name expected next
                COMPREPLY=( $( compgen -W \
                    '$(_iptables_get_builtin_chains_by_table $str_table) $(_iptables_get_user_chains $str_table)' \
                    -- $cur ) )
                   return 0
            ;;
            -E|--rename-chain|-R|--replace) # retrieve existing chains
                COMPREPLY=( $( compgen -W '$(_iptables_get_user_chains $str_table)' -- $cur ) )
                return 0
            ;;
            -P|--policy)
                COMPREPLY=( $( compgen -W '$(_iptables_get_builtin_chains_by_table $str_table)' -- $cur ) )
                return 0
            ;;
            -g|--goto)
                COMPREPLY=( $( compgen -W '$(_iptables_get_user_chains $str_table)' -- $cur ) )
                return 0
            ;;
            -j|--jump)
                COMPREPLY=( $( compgen -W \
                    '$(_iptables_get_target_by_table $str_table) $(_iptables_get_user_chains $str_table)' \
                    -- $cur ) )
                return 0
            ;;
            -t|--table)
                COMPREPLY=( $( compgen -W 'filter mangle nat raw security' -- $cur ) )
                return 0
            ;;
            -m|--match) arr_tmp=()
                # do not show matches already used
                # except those explicitly defined for multiple usage
                for str_tmp in $(_iptables_get_match_by_table $str_table); do
                    # matches already used on the command-line
                    for ((i=0; i < ${#arr_all_matches[@]}-1; i++)); do
                        [[ $str_tmp = ${arr_all_matches[i]} ]] || continue
                        if [[ $str_tmp = $str_proto && \
                            $COMP_LINE != *@(-m|--match)+([[:blank:]])$str_tmp* ]]
                        then # proto used matches, allow if it hasnt been used
                            arr_tmp[${#arr_tmp[@]}]="$str_tmp"
                        else # those are always shown
                            for x in ${!arr_global_matches[@]}; do
                                if [[ $str_tmp = ${arr_global_matches[x]%% *} ]]; then
                                    arr_tmp[${#arr_tmp[@]}]="$str_tmp"
                                    break
                                fi
                            done
                        fi
                        continue 2
                    done
                    arr_tmp[${#arr_tmp[@]}]="$str_tmp"
                done
                COMPREPLY=( $( compgen -W '${arr_tmp[@]}' -- $cur ) )
                return 0
            ;;
            @(-@(i|-in-interface|o|-out-interface|-physdev-in|-physdev-out)))
                COMPREPLY=( $( compgen -W '$(_iptables_get_ifnames)' -- $cur ) )
                return 0
            ;;
            --src-range|--dst-range)
                if [[ $_IPT_IPLIST_FILE && -r $_IPT_IPLIST_FILE ]]; then
                    # if a file with ip addresses is in env var, load em
#                    str_regex='^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
                    if [[ $str_app = iptables ]]; then
                    str_regex='^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(/([3][0-2]|[1-2]?[0-9]))?$'
                    elif [[ $str_app = ip6tables ]]; then
                    str_regex='^([0-9a-fA-F]{1,4}(:[0-9a-fA-F]{1,4}){7}|([0-9a-fA-F]{1,4}:){1}(:[0-9a-fA-F]{1,4}){1,6}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,6}(:[0-9a-fA-F]{1,4}){1})(/([1]?[0-2][0-9]|[0-9]?[0-9]))?$'
                    fi
                    str_tmp=$(while read -r ip rest; do
                        [[ $ip = *([[:blank:]])\#* ]] && continue
                        ip="${ip//\#*/}"
                        [[ $ip =~ $str_regex ]] && printf "%s\n" "${ip%/*}"
                        done < "${_IPT_IPLIST_FILE}")
                fi
                if [[ $cur = *-* ]]; then
                    if [[ $str_tmp ]]; then
                        COMPREPLY+=( $( compgen -P "${cur%-*}-" -W "$str_tmp" -- "${cur#*-}" ) )
                        ((got_bashcompl)) && __ltrim_colon_completions "$str_prefix$cur"
                    fi
                else
                    if [[ $str_tmp ]]; then
                        compopt -o nospace
                        COMPREPLY+=( $( compgen -W "$str_tmp" -S '-' -- "$cur" ) )
                        ((got_bashcompl)) && __ltrim_colon_completions "$cur"
                    fi
                fi
            ;;
            @(-@(s|-source|d|-destination|-ctorigsrc|-ctorigdst|-ctreplsrc|-ctrepldst|-vaddr|-tunnel-src|-tunnel-dst|-gateway|-on-ip)))
                if ((got_bashcompl)); then
                   _known_hosts_real -- "$cur"
                else
                    COMPREPLY=( $( compgen -A hostname "$cur" ) )
                fi
                if [[ $_IPT_IPLIST_FILE && -r $_IPT_IPLIST_FILE ]]; then
                    # if a file with ip addresses is in env var, load em
                    if [[ $str_app = iptables ]]; then
                    str_regex='^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(/([3][0-2]|[1-2]?[0-9]))?$'
                    elif [[ $str_app = ip6tables ]]; then
                    str_regex='^([0-9a-fA-F]{1,4}(:[0-9a-fA-F]{1,4}){7}|([0-9a-fA-F]{1,4}:){1}(:[0-9a-fA-F]{1,4}){1,6}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,6}(:[0-9a-fA-F]{1,4}){1})(/([1]?[0-2][0-9]|[0-9]?[0-9]))?$'
                    fi
                    str_tmp=$(while read -r ip rest; do
                        [[ $ip = *([[:blank:]])\#* ]] && continue
                        ip="${ip//\#*/}"
                        [[ $ip =~ $str_regex ]] && printf "%s\n" "$ip"
                        done < "${_IPT_IPLIST_FILE}")
                    COMPREPLY+=( $( compgen -W "$str_tmp" -- "$cur" ) )
                fi
                if [[ $prev != --gateway ]]; then
                    # add networks
                    while read; do
                        [[ $REPLY = $cur* ]] && COMPREPLY+=("$REPLY")
                    done < <(_iptables_get_networks)

                    # add ip addresses of interfaces
                    if [[ $str_app = iptables ]]; then
                        str_tmp=-4
                    elif [[ $str_app = ip6tables ]]; then
                        str_tmp=-6
                    fi
                    local one two three rest
                    while read one two three str_var rest; do
                        [[ $str_var = $cur* ]] && COMPREPLY+=("$str_var")
                    done < <(PATH="$PATH:/sbin" command ip $str_tmp -o addr)
                    unset one two three rest
                fi
                ((got_bashcompl)) && __ltrim_colon_completions "$cur"
                if ((${#COMPREPLY[@]} == 1)) && [[ ${COMPREPLY[0]} != */* ]]
                then
                    compopt -o nospace
                fi
            ;;
            -p|--proto|--ctproto|--vproto)
                if [[ $prev = --proto ]]; then
                    if [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]
                    then COMPREPLY=( $( compgen -W 'ah esp ipcomp' -- $cur ) )
                        return 0 # policy match also has --proto
                    fi
                fi
                COMPREPLY=( $( compgen -W '$(_iptables_get_protocols)' -- $cur ) )
                return 0
            ;;
            @(--@(on-port|vport|vportctl)))
                COMPREPLY=( $( compgen -W '$(_iptables_get_services -p "$str_proto")' -- $cur ) )
                return 0
            ;;
            @(--@(dport|destination-port|sport|source-port|ctorigsrcport|ctorigdstport|ctreplsrcport|ctrepldstport)))
                if [[ $cur = *:* ]]; then
                    COMPREPLY=( $(_iptables_compl_port_range "$cur") )
                    ((got_bashcompl)) && __ltrim_colon_completions "$cur"
                else
                    compopt -o nospace
                    COMPREPLY=( $( compgen -W '$(_iptables_get_services -p "$str_proto")' -- $cur ) )
                fi
                return 0
            ;;
            @(--@(dports|destination-ports|sports|source-ports|ports)))
                if [[ $cur = *,* ]]; then
                    str_tmp="$cur" str_var="${cur##*,}"
                    str_tmp="${str_tmp%"$cur"}"
                    if [[ $cur = *:* ]]; then
                         _iptables_build_comma_list "$cur" \
                             $( compgen -P "$str_tmp" -W '$(_iptables_compl_port_range "$str_var")' \
                             -- "$str_var" )
                        ((got_bashcompl)) && __ltrim_colon_completions "$cur"
                    else
                        _iptables_build_comma_list "$cur" \
                            $( compgen -P "$str_tmp" -W '$(_iptables_get_services -p "$str_proto")' \
                            -- $str_var )
                    fi
                else
                    if [[ $cur = *:* ]]; then
                        COMPREPLY=( $(_iptables_compl_port_range "$cur") )
                        ((got_bashcompl)) && __ltrim_colon_completions "$cur"
                    else
                        COMPREPLY=( $( compgen -W '$(_iptables_get_services -p "$str_proto")' -- $cur ) )
                    fi
                fi
                (( $(IFS=,; set -- $cur;printf "%d\n" $#) > 15 )) || compopt -o nospace
                return 0
            ;;
            --icmp-type)
                COMPREPLY=( $( compgen -W '${arr_icmp_types[@]//,/ }' -- $cur ) )
                return 0
            ;;
            --icmpv6-type)
                COMPREPLY=( $( compgen -W '${arr_icmp6_types[@]//,/ }' -- $cur ) )
                return 0
            ;;
            --reject-with) # REJECT target
                case "$str_app" in
                    iptables)
                        COMPREPLY=( $( compgen -W 'icmp-net-unreachable icmp-host-unreachable\
                               icmp-port-unreachable icmp-proto-unreachable icmp-net-prohibited\
                               icmp-host-prohibited icmp-admin-prohibited tcp-reset' -- $cur ) )
                    ;;
                    ip6tables)
                        COMPREPLY=( $( compgen -W 'icmp6-no-route no-route icmp6-adm-prohibited\
                               adm-prohibited icmp6-addr-unreachable addr-unreach\
                               icmp6-port-unreachable port-unreach tcp-reset' -- $cur ) )
                    ;;
                esac
                return 0
            ;;
            --type) # AUDIT target
                COMPREPLY=( $( compgen -W 'accept drop reject' -- $cur ) )
                return 0
            ;;
            --set-class) # CLASSIFY target
                COMPREPLY=( $( compgen -W '$(_iptables_get_tc_classes)' -- $cur ) )
                ((got_bashcompl)) && __ltrim_colon_completions "$cur"
                return 0
            ;;
            --hashmode) # CLUSTERIP target
                COMPREPLY=( $( compgen -W \
                    'sourceip sourceip-sourceport sourceip-sourceport-destport' \
                    -- $cur ) )
                return 0
            ;;
            --expevents) # CT target
                COMPREPLY=( $( compgen -W 'new' -- $cur ) )
                return 0
            ;;
            --ctevents) # CT target
                _iptables_build_comma_list "$cur" new related destroy reply assured \
                    protoinfo helper mark natseqinfo secmark
                return 0
            ;;
            --hmark-tuple) # HMARK target
                _iptables_build_comma_list "$cur" src dst sport dport spi ct
                return 0
            ;;
            --log-level) # LOG target
                COMPREPLY=( $( compgen -W 'alert crit debug emerg err info notice warning' -- $cur ) )
                return 0
            ;;
            --nflog-group) # NFLOG target
                str_tmp=$(set +f;cd /proc/sys/net/netfilter/nf_log/ && printf "%s\n" *)
                COMPREPLY=( $( compgen -W '$str_tmp' -- $cur ) )
                return 0
            ;;
            --strip-options) # TCPOPTSTRIP target
                _iptables_build_comma_list "$cur" wscale mss sack-permitted sack timestamp md5
                return 0
            ;;
            @(--@(add-set|del-set|match-set))) # set match and SET target
                COMPREPLY=( $( compgen -W '$(_iptables_get_setnames)' -- $cur ) )
                ((got_bashcompl)) && __ltrim_colon_completions "$cur"
                return 0
            ;;
            --algo) # string match
                COMPREPLY=( $( compgen -W 'bm kmp' -- $cur ) )
                return 0
            ;;
            --chunk-types) # sctp match
                COMPREPLY=( $( compgen -W 'all any only' -- $cur ) )
                return 0
            ;;
            --ctstate) # conntrack match
                _iptables_build_comma_list "$cur" NEW ESTABLISHED RELATED INVALID UNTRACKED SNAT DNAT
                return 0
            ;;
            --ctstatus) # conntrack match
                _iptables_build_comma_list "$cur" NONE EXPECTED SEEN_REPLY ASSURED CONFIRMED
                return 0
            ;;
            --ctdir) # conntrack match
                COMPREPLY=( $( compgen -W 'ORIGINAL REPLY' -- $cur ) )
                return 0
            ;;
            --cpu) # cpu match
                str_tmp=$(while read -r str_name c num;do [[ $str_name = processor ]] && printf "%s\n" "$num";done</proc/cpuinfo)
                COMPREPLY=( $( compgen -W '$str_tmp' -- $cur ) )
                return 0
            ;;
            --connbytes-dir) # connbytes match
                COMPREPLY=( $( compgen -W 'original reply both' -- $cur ) )
                return 0
            ;;
            --connbytes-mode) # connbytes match
                COMPREPLY=( $( compgen -W 'packets bytes avgpkt' -- $cur ) )
                return 0
            ;;
            --dccp-types) # dccp match
                _iptables_build_comma_list "$cur" REQUEST RESPONSE DATA ACK \
                    DATAACK CLOSEREQ CLOSE RESET SYNC SYNCACK INVALID
                return 0
            ;;
            --log|--ttl) # osf match
                COMPREPLY=( $( compgen -W '0 1 2' -- $cur ) )
                return 0
            ;;
            --ecn-ip-ect) # ecn match
                COMPREPLY=( $( compgen -W '0 1 2 3' -- $cur ) )
                return 0
            ;;
            --header) # header match TODO: add protocols list?
                _iptables_build_comma_list "$cur" hop dst route frag auth esp none proto
                return 0
            ;;
            --mac-source)
                str_regex='^([[:xdigit:]]{2})(:[[:xdigit:]]{2}){5}$'
                x=0 y=0
                if [[ ${_IPT_MAC_COMPL_MODE:=both} = both ]]; then
                    x=1 y=1
                elif [[ $_IPT_MAC_COMPL_MODE = file ]]; then
                    x=1
                elif [[ $_IPT_MAC_COMPL_MODE = system ]]; then
                    y=1
                fi
                if ((x)); then
                    if [[ $_IPT_MACLIST_FILE && -r $_IPT_MACLIST_FILE ]]
                    then
                        # if a file with mac addresses is in env var, load em
                        str_tmp=$(while read -r mac rest; do
                            [[ $mac = *([[:blank:]])\#* ]] && continue
                            mac="${mac//\#*/}"
                            [[ $mac =~ $str_regex ]] && printf "%s\n" "$mac"
                            done < "${_IPT_MACLIST_FILE}")
                        COMPREPLY=( $( compgen -W "$str_tmp" -- "$cur" ) )
                    fi
                fi
                if ((y)); then
                    # read arp cache, addresses of local interfaces and /etc/ethers
                    str_tmp=$(while read a b addr rest; do
                        [[ $addr =~ $str_regex ]] && printf "%s\n" "$addr"
                        done < <(PATH=$PATH:/sbin command arp -n 2>/dev/null))
                    str_tmp+=" $(while read -r; do
                        [[ $REPLY = *link/loopback* ]] && continue
                        REPLY=${REPLY#*link/*+([[:blank:]])}
                        REPLY=${REPLY%+([[:blank:]])brd*}
                        [[ $REPLY =~ $str_regex ]] && printf "%s\n" "$REPLY"
                        done < <(PATH=$PATH:/sbin command ip -o link show 2>/dev/null))"
                    if [[ -r /etc/ethers ]]; then
                        str_tmp+=" $(while read -r addr rest; do
                            [[ $addr =~ $str_regex ]] && printf "%s\n" "$addr"
                            done < /etc/ethers)"
                    fi
                    COMPREPLY=+( $( compgen -W "$str_tmp" -- "$cur" ) )
                fi
                ((got_bashcompl)) && __ltrim_colon_completions "$cur"
            ;;
            --mode) # overlap in option names, policy and statistic match both have --mode
                if [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]; then
                    COMPREPLY=( $( compgen -W 'tunnel transport' -- $cur ) )
                elif [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = statistic ]]; then
                    COMPREPLY=( $( compgen -W 'random nth' -- $cur ) )
                fi
                return 0
            ;;
            --dir) # policy match
                COMPREPLY=( $( compgen -W 'in out' -- $cur ) )
                return 0
            ;;
            --pol) # policy match
                COMPREPLY=( $( compgen -W 'none ipsec' -- $cur ) )
                return 0
            ;;
            --nfacct-name) # nfacct match
                str_tmp=$( while read -r;do REPLY="${REPLY%;}";printf "%s\n" ${REPLY##*=};done < <(PATH=${PATH}:/sbin command nfacct list) )
                COMPREPLY=( $( compgen -W '$str_tmp' -- $cur ) )
                return 0
            ;;
            --uid-owner) # owner match
                COMPREPLY=( $( compgen -u -- $cur ) )
                return 0
            ;;
            --gid-owner) # owner match
                COMPREPLY=( $( compgen -g -- $cur ) )
                return 0
            ;;
            --pkt-type) # pkttype match
                COMPREPLY=( $( compgen -W 'unicast broadcast multicast' -- $cur ) )
                return 0
            ;;
            --realm) # realm match
                COMPREPLY=( $( compgen -W '$(_iptables_get_realms)' -- $cur ) )
                return 0
            ;;
            --state) # state match
                _iptables_build_comma_list "$cur" NEW ESTABLISHED RELATED INVALID UNTRACKED
                return 0
            ;;
            --src-type|--dst-type) # addrtype match
                COMPREPLY=( $( compgen -W 'UNSPEC UNICAST LOCAL BROADCAST \
                    ANYCAST MULTICAST BLACKHOLE UNREACHABLE PROHIBIT THROW NAT XRESOLVE' \
                    -- $cur ) )
                return 0
            ;;
            --dscp-class|--set-dscp-class) # dscp match and DSCP target
                COMPREPLY=( $( compgen -W \
                    'BE EF AF11 AF12 AF13 AF21 AF22 AF23 AF31 AF32 AF33 AF41 AF42 AF42 CS1 CS2 CS3 Cs4' \
                    -- $cur ) )
                return 0
            ;;
            --rateest-interval|--rateest-ewmalog) # RATEEST target
                if [[ $cur = +([[:digit:]])?(.*([[:digit:]]))*([[:alpha:]]) ]]; then # glob not perfect, requires more work
                    COMPREPLY=( $( compgen -W \
                        '${cur//[[:alpha:]]/}s ${cur//[[:alpha:]]/}ms ${cur//[[:alpha:]]/}us' \
                        -- $cur ) )
                    return 0
                fi
            ;;
            --rateest-@(bps|pps|bps1|bps2|pps1|pps2)) # rateest match
                if [[ $cur = +([[:digit:]])?(.*([[:digit:]]))*([[:alpha:]]) ]]; then # glob not perfect, requires more work
                    str_tmp="${cur%%[[:alpha:]]}"
                    COMPREPLY=( $( compgen -P "$str_tmp" -W \
                        'bit kbit mbit gbit tbit Kibit Mibit Gibit Tibit Bps \
                        KBps MBps GBps TBps KiBps MiBps GiBps TiBps' \
                        -- ${cur##+([[:digit:]])?(.*([[:digit:]]))} ) )
                    return 0
                fi
            ;;
            --limit|--hashlimit-above|--hashlimit-upto) # limit match
                if [[ $cur = +([[:digit:]])?(/*([[:alpha:]])) ]]; then
                    str_tmp="${cur//+(\/|+([[:alpha:]]))/}"
                    COMPREPLY=( $( compgen -W \
                        '${str_tmp}/second ${str_tmp}/minute ${str_tmp}/hour ${str_tmp}/day' \
                        -- $cur ) )
                    return 0
                fi
            ;;
            --hashlimit-mode) # hashlimit match
                _iptables_build_comma_list "$cur" srcip srcport dstip dstport
                return 0
            ;;
            --tos|--set-tos) # tos match and TOS target
                if [[ $str_app = iptables ]]; then
                    COMPREPLY=( $( compgen -W \
                        'Minimize-Delay Maximize-Throughput Maximize-Reliability \
                        Minimize-Cost Normal-Service' -- $cur ) )
                    return 0
                fi
            ;;
            --vdir) # ipvs match
                COMPREPLY=( $( compgen -W 'ORIGINAL REPLY' -- $cur ) )
                return 0
            ;;
            --vmethod) # ipvs match
                COMPREPLY=( $( compgen -W 'GATE IPIP MASQ' -- $cur ) )
                return 0
            ;;
            --weekdays) # time match
                _iptables_build_comma_list "$cur" Mon Tue Wed Thu Fri Sat Sun
                return 0
            ;;
            DATA) # sctp match
                COMPREPLY=( I U B E i u b e )
                return 0
            ;;
            ABORT|SHUTDOWN_COMPLETE) # sctp match
                COMPREPLY=( T t )
                return 0
            ;;
        esac
        i=$((cword -1))
        if ((i > 1)); then # depend on option before previous option
            case "${words[i-1]}" in
                --chunk-types) # sctp match
                    compopt -o nospace
                    COMPREPLY=( $( compgen -W 'DATA ABORT SHUTDOWN_COMPLETE' -- $cur ) )
                    return 0
                ;;
                -P|--policy) # chain policy
                    COMPREPLY=( $( compgen -W 'ACCEPT DROP' -- $cur ) )
                    return 0
                ;;
                --add-set|--del-set|--match-set) # set match and SET target
                    _iptables_build_ipset_flaglist "$cur" src dst
                    return 0
                ;;
            esac
        fi
    ;;
esac

if ! ((${#COMPREPLY[@]})); then
    [[ $cur ]] && _iptables_bash_default_compl "$cur"
else
    case "${COMPREPLY[0]}" in
        --modprobe=)
            compopt -o nospace
        ;;
    esac
fi

if [[ $_DEBUG_NF_COMPLETION ]]; then
    printf "COMPREPLY:\n"
    printf "<%s>\n" "${COMPREPLY[@]}"
fi
}
complete -F _iptables_complete iptables ip6tables

