#!/bin/bash

# -----------------------------------------------------------------
# Programmable completion specification for iptables (netfilter.org)
#
# https://github.com/AllKind/iptables-bash_completion
# https://sourceforge.net/projects/ipt-bashcompl
# -----------------------------------------------------------------

# Copyright (C) 2013 AllKind (AllKind@fastest.cc)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# -----------------------------------------------------------------
# Requirements:
#
# The bash completion package version 2.0 or greater is recommended.
# http://bash-completion.alioth.debian.org/
#
# If the package is not available, things might not be so reliable.
# Also the colon (if there) is removed from COMP_WORDBREAKS.
# This alteration is globally. Which might affect other completions
# if they don't take care of it themselves.
#
# -----------------------------------------------------------------
# Installation:
#
# Put it into ~/.bash_completion or /etc/bash_completion.d/
#
# -----------------------------------------------------------------
#
# Version 1.0-beta-2
#
# -----------------------------------------------------------------

shopt -s extglob

# -----------------------------------------------------------------
# FUNCTIONS
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# iptables functions
# -----------------------------------------------------------------
_iptables_select_on_inet_family() {
if [[ $1 != all ]]; then # select match according to current calling app
    if [[ $1 = v4 && $str_app = ip6tables ]]; then
        return 1
    elif [[ $1 = v6 && $str_app = iptables ]]; then
        return 1
    fi
fi
return 0
}

_iptables_get_rulenum() {
[[ ${words[${1}+2]} = +([[:digit:]]) ]] && printf "%d\n" ${words[${1}+2]}
}

_iptables_is_option() {
local -i opt_idx
local str_q="$1"
[[ $str_q = -?* ]] || return
# CLUSTERIP also has --new
if [[ $str_q = --new && $str_target = CLUSTERIP ]] && \
    ((cword == target_index+2)); then
    return 1
fi
if [[ $str_q = --proto && $str_last_is = match && \
    ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]
then # policy match also has --proto
    return 1
fi
for opt_idx in ${!arr_opts[@]}; do set -- ${arr_opts[opt_idx]}
    while (($#)); do
        [[ $1 = $str_q ]] && return
        shift
    done
done
return 1
}

_iptables_is_target() {
local -i idx
local str_x="$1"
[[ $str_x = @(""|-*|*/*|\!) ]] && return 1
for idx in ${!arr_targets[@]}; do
    [[ ${arr_targets[idx]%% *} = $str_x ]] && return
done
return 1
}

_iptables_is_match() {
local -i idx
local str_x="$1"
[[ $str_x = @(""|-*|*/*|\!) ]] && return 1
for idx in ${!arr_matches[@]}; do
    [[ ${arr_matches[idx]%% *} = $str_x ]] && return
done
return 1
}

_iptables_get_match_by_table() {
local -i idx
local str_x="$1" # table name
for idx in ${!arr_matches[@]}; do
    set -- ${arr_matches[idx]}
    _iptables_select_on_inet_family $2 || continue
    # valid in current table
    if [[ $3 = all ]] || [[ ${3//,/ } = *${str_x}* ]]; then
        if [[ $str_proto ]]; then
            case "$1" in
                connlimit|ecn|osf|tcp|tcpmss)
                    [[ $str_proto = tcp ]] || continue
                ;;
                multiport)
                    [[ $str_proto = @(tcp|udp|dccp|sctp) ]] || continue
                ;;
                icmp|udp|tcp|ah|esp|dccp|sctp)
                    [[ $str_proto = $1 ]] || continue
                ;;
            esac
        fi
        if ((proto_negated)); then
            if [[ $1 = @(connlimit|ecn|osf|tcp|tcpmss|multiport|icmp|udp|tcp|ah|esp|dccp|sctp) ]]
            then continue
            fi
        fi
        printf "%s\n" "$1"
    fi
done
}

_iptables_get_target_by_table() {
local -i idx
local str_x="$1" # table
for idx in ${!arr_targets[@]}; do set -- ${arr_targets[idx]}
    _iptables_select_on_inet_family $2 || continue
    if [[ $3 = all ]] || [[ ${3//,/ } = *${str_x}* ]]; then # allowed in table
        if [[ $1 = @(ECN|TCPMSS|TCPOPTSTRIP) ]]; then
            if [[ $str_proto ]]; then
                [[ $str_proto = tcp ]] || continue
            elif ((proto_negated)); then
                continue
            fi
        elif [[ $1 = TPROXY ]]; then
            if [[ $str_proto ]]; then
                [[ $str_proto = @(tcp|udp) ]] || continue
            fi
        fi
        printf "%s\n" "$1"
    fi
done
}

_iptables_get_builtin_chains_by_table() {
local str_cmd str_name str_rest
while read -r str_cmd str_name str_rest; do
    [[ $str_cmd = -P ]] && printf "%s\n" "$str_name" || return 0
done < <("$str_app" -S -t $1 2>/dev/null)
}

_iptables_get_user_chains() {
local str_cmd str_name str_rest
while read -r str_cmd str_name str_rest; do
    if [[ $str_cmd = -N ]]; then printf "%s\n" "$str_name"
    elif [[ $str_cmd = -A ]]; then return 0
    fi
done < <("$str_app" -S -t $1 2>/dev/null)
}

_iptables_get_target_opts() {
local -i idx oidx ridx=0
local str_x="$1" oIFS="$IFS" str_opt str_flags str_xflag
local -a arr_topts=() arr_reply=()
for idx in ${!arr_targets[@]}; do set -- ${arr_targets[idx]}
    [[ $1 = $str_x ]] || continue
    _iptables_select_on_inet_family $2 || continue
    shift 3
    arr_topts=( "$@" )
    # check targets option flags
    for oidx in ${!arr_topts[@]}; do
        if [[ ${arr_topts[oidx]} != *:* ]]; then
           arr_reply[ridx++]="${arr_topts[oidx]}"
           continue
        fi
        str_flags="${arr_topts[oidx]#*:}"
        str_opt="${arr_topts[oidx]%:"$str_flags"}"
        IFS=:
        set -- $str_flags
        IFS="$oIFS"
        while (($#)); do
            if [[ $1 = ex ]]; then # mutual exclusive options
                shift
                for str_xflag in ${1//,/ }; do
                    _iptables_is_in_compwords "$str_xflag" && continue 3
                done
            elif [[ $1 = table ]]; then # option is table depending
                shift
                for str_xflag in ${1//,/ }; do
                    [[ $str_table = $str_xflag ]] || continue 3
                done
            elif [[ $1 = proto ]]; then # option is protocol depending
                shift
                if [[ $str_proto ]]; then
                    str_xflag="${1//,/|}"
                    [[ $str_proto = @($str_xflag) ]] || continue 2
                fi
                if ((proto_negated)); then
                    continue 2
                fi
            fi
            shift
        done
        arr_reply[ridx++]="$str_opt"
    done
    printf "%s\n" "${arr_reply[*]}"
    return 0
done
}

_iptables_get_match_opts() {
local -i idx cix rix xix got_arg
local str_match="$1" oIFS="$IFS" str_opt str_tmp str_flags str_xflag
local arr_reply=()
for idx in ${!arr_matches[@]}; do set -- ${arr_matches[idx]}
    [[ $1 = $str_match ]] || continue
    _iptables_select_on_inet_family $2 || continue
    shift 3
    arr_reply=() arr_mopts=( "$@" )
    # check match option flags
    for rix in ${!arr_mopts[@]}; do
        str_flags="${arr_mopts[rix]#*:}"
        str_opt="${arr_mopts[rix]%:"$str_flags"}"
        IFS=:
        set -- $str_flags
        IFS="$oIFS"
        while (($#)); do
            if [[ $1 = ex ]]; then # mutual exclusive options
                shift
                for str_xflag in ${1//,/ }; do
                    _iptables_is_in_compwords "$str_xflag" && continue 3
                done
            elif [[ $1 = optis ]]; then
                # mutual exclusive options, value depending
                shift
                if _iptables_is_in_compwords "${1%=*}"; then
                    [[ ${words[$(_iptables_get_cw_idx "${1%=*}")+1]} = ${1#*=} ]] || continue 2
                fi
            elif [[ $1 = neg ]]; then
                # negation
                shift
                if [[ $prev = \! && $1 = no ]]; then
                    continue 2
                fi
            fi
            shift
        done
        if [[ $str_opt = *,* ]]; then # redundant option names
            for str_tmp in ${str_opt//,/ }; do # exclude the aliases from listing
                if _iptables_is_in_compwords $str_tmp; then
                    continue 2
                fi
            done
        fi
        arr_reply[${#arr_reply[@]}]="$str_opt"
    done
    for rix in ${!arr_reply[@]}; do str_opt="${arr_reply[rix]}"
        # find options which can be used globally (multiple use of match), but filter them out
        # if we already used them in the current active match
        for xix in ${!arr_global_matches[@]}; do # retrieve list of global options
            set -- ${arr_global_matches[xix]}
            [[ $str_match = $1 ]] || continue
            shift
            for str_tmp; do
                [[ $str_tmp = $str_opt ]] || continue
                got_arg=0
                for ((cix=$((cword == ${#words[@]}-1 ? cword-1 : cword)); \
                    $cix >= $last_match_index; cix--))
                do
                    [[ ${words[cix]} = @(""|\!) ]] && continue
                    if [[ ${words[cix]} != @($str_opt|$str_match) ]]
                    then
                        if (($cix == $last_option_index)); then
                            break # another option
                        elif (($cix == $target_index)); then
                            break # another target
                        fi
                    elif [[ ${words[cix]} = $str_opt ]]; then
                        got_arg=1 # got the option
                    elif [[ ${words[cix]} = $str_match ]] && \
                        (($cix == $last_match_index)); then # got the match
                        ((got_arg)) || break # but don't have arg
                        unset arr_reply[rix]
                        break
                    fi
                done
            done
        done
    done
    printf "%s\n" "${arr_reply[*]//,/ }"
    return 0
done
}

# -----------------------------------------------------------------
# retrieve arguments data
# -----------------------------------------------------------------
#_iptables_get_networks() {
#local foo str_net rest
#[[ -r /etc/networks ]] || return 0
#while read -r foo str_net rest; do
#    [[ $foo = @(""|*([[:blank:]])#*) ]] && continue
#    [[ $str_net = *([[:blank:]])#* ]] && continue
#    printf "%s\n" "$str_net"
#done < /etc/networks
#}

_iptables_get_ifnames() {
while read -r; do
    REPLY="${REPLY#*: }"
    printf "%s\n" ${REPLY%%:*}
done < <(PATH=${PATH}:/sbin command ip -o link show)
}

_iptables_get_protocols() {
local str_name rest
while read -r str_name rest; do
    [[ $str_name = *([[:blank:]])#* ]] && continue
    printf "%s\n" "$str_name"
done < /etc/protocols
}

_iptables_get_services() {
local str_offset="" str_name str_num str_p=all rest
while (($#)); do
    if [[ $1 = -p ]]; then
        str_p="${2:-all}"
        shift
    elif [[ $1 = -o && $2 ]]; then
        # second part of range will have offset = first_part_of_range
        str_offset="${2}"
        shift
    fi
    shift
done
# find service num to set offset
if [[ $str_offset && $str_offset != +([[:digit:]]) ]]; then
    while read str_name str_num rest; do
        if [[ $str_name = *([[:blank:]])#* ]]; then continue
        elif [[ $str_p != all && ${str_num#*/} != $str_p ]]; then
            continue
        fi
        [[ $str_name = $str_offset ]] && str_offset=${str_num%/*} && break
    done < /etc/services
    [[ $str_offset = +([[:digit:]]) ]] || return 0
fi
while read -r str_name str_num rest; do
    if [[ $str_name = *([[:blank:]])#* ]]; then continue
    elif [[ $str_p != all && ${str_num#*/} != $str_p ]]; then
        continue
    elif [[ $str_offset && $str_num && $str_num = +([[:digit:]])/* ]] && \
        ((${str_num%/*} <= $str_offset)); then
        continue
    fi
    printf "%s\n" "$str_name"
done < /etc/services
}

_iptables_compl_port_range() { # complete named port ranges
local str_prefix="$1" lcur="${1#*:}"
str_prefix=${str_prefix%"$lcur"}
compgen -P "$str_prefix" -W \
    '$(_iptables_get_services -p "$str_proto" -o "${str_prefix%:}")' \
    -- "$lcur"
}

# -----------------------------------------------------------------
# misc functions
# -----------------------------------------------------------------
_iptables_dedupe_opt_alias() {
for i in ${!arr_cmd_opts[@]}; do
    [[ ${arr_cmd_opts[i]} ]] || continue
    # if the user supplied the short form of an option previously, and now
    # requests the long form, remove the corresponding long option,
    # vice versa for short options
    for y in ${!arr_opts[@]}; do # cycle through main options
        set -- ${arr_opts[y]} # $1 = short , $2 = long option
        str_tmp=""
        if [[ ${arr_cmd_opts[i]} = $1 ]]; then
            # we got short version on the cmdline
            str_tmp=$2
        elif [[ ${arr_cmd_opts[i]} = $2 ]]; then
            # we got long version on the cmdline
            str_tmp=$1
        fi
        [[ $str_tmp ]] || continue
        for x in ${!arr_tmp_opts[@]}; do # compare with compreply
            [[ ${arr_tmp_opts[x]//[[:blank:]]/} = $str_tmp ]] || continue
            # options allowed multiple times
            if [[ ${arr_tmp_opts[x]} = @(-m|--match) ]]; then
                :
            elif [[ ${arr_tmp_opts[x]} = --proto && $str_last_is = match && \
                ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]; then
                : # always allow --proto if policy is the last match
            elif [[ ${arr_tmp_opts[x]} = --proto && $str_last_is = match && \
                ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy && -z $str_proto ]]
            then
                : # allow -p after first option of policy match was set, if not set before
            else # exceptions done
                if [[ $_DEBUG_NF_COMPLETION ]]; then
                    printf "removing option alias arr_tmp_opts[$x]: %s\n" "${arr_tmp_opts[x]}"
                fi
                unset arr_tmp_opts[x]
                continue 3
            fi
        done
    done
done
}

_iptables_dedupe_opts() {
local str_opt
# post process the reply - remove dupclicate options
for str_opt; do # list an option only once
    # options allowed multiple times
    if [[ $str_opt = @(-m|--match) ]]; then
        printf "%s\n" "$str_opt"
        continue
    elif [[ $str_last_is = match ]]; then
        # per match options allowed multiple times
        if [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]; then
            if [[ $str_opt = --@(proto|reqid|spi|mode|tunnel-src|tunnel-dst|next) ]]
            then
                printf "%s\n" "$str_opt"
                continue
            fi
        fi
        for x in ${!arr_global_matches[@]}; do
            set -- ${arr_global_matches[x]}
            [[ $1 = ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} ]] || continue
            shift
            for y; do
                if [[ $str_opt = $y ]]; then
                    printf "%s\n" "$str_opt"
                    continue 3
                fi
            done
        done
    fi
    for i in ${!arr_set_names[@]}; do # could be a weird set name
        if [[ $str_opt = ${arr_set_names[i]} ]]; then
            printf "%s\n" "$str_opt"
            continue
        fi
    done
    for ((i=1; i < ${#words[@]}-1; i++)); do
        [[ ${words[i]} != -?* ]] && continue
        if [[ ${words[i]} = $str_opt ]]; then
            if [[ $_DEBUG_NF_COMPLETION ]]; then
                printf "removing dupe option: %s\n" "$str_opt"
            fi
            continue 2
        fi
    done
    printf "%s\n" "$str_opt"
done
}

_iptables_get_cw_idx() {
local -i idx index=0
for idx in ${!words[@]}; do
    if [[ ${words[idx]} = $1 ]]; then index=$idx
        # we don't break, as args could be used double.
        # choosing the last one, is ugly but less worse i think
        # TODO: find a solution
#        printf "%d\n" "$idx"
#        return 0
    fi
done
printf "%d\n" $((index ? index : -1))
}

_iptables_is_in_compwords() {
local -i cix
for ((cix=1; cix < ${#words[@]}-1; cix++)); do
    [[ $1 = ${words[cix]} ]] && return
done
}

_iptables_build_comma_list() {
local lcur="$1" lmatch="" rlist="" prefix=""
shift
local arr_list=("${@}")
local str_pat=$(IFS=\|; printf "%s" "${arr_list[*]}")
compopt -o nospace
if [[ $lcur ]]; then
    if [[ ${lcur} = @($str_pat) ]]; then
        prefix="${lcur}," rlist="$lcur" lmatch=""
    elif [[ ${lcur:$((${#lcur}-1))} = , ]]; then
        prefix="${lcur}" rlist="$lcur" lmatch=""
    elif [[ ${lcur:$((${#lcur}-1))} != , ]]; then
        if [[ ${lcur##*,} != @($str_pat) ]]; then
            prefix="${lcur%${lcur##*,}}"
            rlist="${lcur%${lcur##*,}}"
            if [[ $lcur = *,* ]]; then
                lmatch="${lcur##*,}"
            else
                lmatch="${lcur}"
            fi
            [[ $prefix && ${prefix:$((${#prefix}-1))} != , ]] && prefix="${prefix},"
        else
            prefix="${lcur}," rlist="$lcur" lmatch=""
        fi
    fi
    for x in ${rlist//,/ }; do
        for i in ${!arr_list[@]}; do
            if [[ $x = ${arr_list[i]} ]]; then
                unset arr_list[i]
            fi
        done
    done
fi
((${#arr_list[@]} == 1)) && compopt +o nospace
COMPREPLY=( $( compgen -P "$prefix" -W '${arr_list[@]}' -- "$lmatch" ) )
}

# -----------------------------------------------------------------
# main function
# -----------------------------------------------------------------

_iptables_complete() {
local cur prev cword words
local str_target str_jump str_action str_proto str_help
local ipt_version str_last_is str_var str_tmp str_regex
local str_table="filter" str_proto_match=""
local arr_tmp_opts=() arr_cmd_matches=() arr_cmd_opts=() arr_all_matches=()
local arr_last_opts=() arr_set_names=() arr_tmp=()
local -i i=x=y=got_action=got_bashcompl=inline_help=list_only=got_rule_opt=0
local -i rulenum=line_numbers=set_counters=proto_negated=0
local -i last_index=last_match_index=last_option_index=target_index=0
local -r str_app="${COMP_WORDS[0]//*\//}"

# at least bash 3.2 is required
((${BASH_VERSINFO[0]} < 3)) && return 0
((${BASH_VERSINFO[0]} == 3 && ${BASH_VERSINFO[1]} < 2)) && return 0

# old iptables versions, which don't have the `-S' option are not supported
"$str_app" -S OUTPUT 1 &>/dev/null || return

# iptables version TODO: checks re version
#ipt_version="$("$str_app" --version)"
#ipt_version="${ipt_version#$str_app v}"

local arr_global_matches=(
"connmark --mark"
"mark --mark"
"nfacct --nfacct-name"
"sctp --chunk-types"
"set --match-set --return-nomatch"
)

local arr_proto_defs=(
"icmp 1"
"tcp 6"
"udp 17"
"dccp 33"
"esp 50"
"ah 51"
"sctp 132"
)

# target-name all|v4|v6 all|table1,table2,... option [...]
local arr_targets=(
"ACCEPT all all"
"AUDIT all all --type" # TODO: audit drop in nat table, really valid?
"CT all raw \
    --notrack:ex:--helper,--ctevents,--expevents,--zone,--timeout \
    --helper:ex:--notrack \
    --ctevents:ex:--notrack \
    --expevents:ex:--notrack \
    --zone:ex:--notrack \
    --timeout:ex:--notrack" # TODO: get zone-ids?, get timeout policy names
"DROP all filter,mangle,security,raw"
"DNPT v6 mangle --src-pfx --dst-pfx"
"CHECKSUM all mangle --checksum-fill"
"CLASSIFY all all --set-class"
"CLUSTERIP v4 mangle --new:need --hashmode:need --clustermac:need \
    --total-nodes:need --local-node:need --hash-init"
"CONNMARK all all \
    --save-mark:ex:--restore-mark,--set-xmark,--and-mark,--or-mark,--xor-mark,--set-mark:table:mangle \
    --restore-mark:ex:--save-mark,--set-xmark,--and-mark,--or-mark,--xor-mark,--set-mark:table:mangle \
    --mask:ex:--nfmask,--ctmask \
    --nfmask:ex:--mask,--ctmask \
    --ctmask:ex:--mask,--nfmask \
    --set-xmark:ex:--save-mark,--restore-mark,--and-mark,--or-mark,--xor-mark,--set-mark,--mask,--ctmask,--nfmask \
    --and-mark:ex:--save-mark,--restore-mark,--set-xmark,--or-mark,--xor-mark,--set-mark,--mask,--ctmask,--nfmask \
    --or-mark:ex:--save-mark,--restore-mark,--and-mark,--set-xmark,--xor-mark,--set-mark,--mask,--ctmask,--nfmask \
    --xor-mark:ex:--save-mark,--restore-mark,--and-mark,--or-mark,--set-xmark,--set-mark,--mask,--ctmask,--nfmask \
    --set-mark:ex:--save-mark,--restore-mark,--and-mark,--or-mark,--set-xmark,--xor-mark,--mask,--ctmask,--nfmask"
"CONNSECMARK all mangle,security --save:ex:--restore --restore:ex:--save"
"ECN all mangle --ecn-tcp-remove"
"DNAT v4 nat --to-destination:need --random:ex:--presistent --persistent:ex:--random"
"DSCP all mangle --set-dscp:ex:--set-dscp-class --set-dscp-class:ex:set-dscp"
"HL v6 mangle --hl-set:ex:--hl-dec,--hl-inc \
    --hl-dec:ex:--hl-set,--hl-inc \
    --hl-inc:ex:--hl-set,--hl-dec"
"HMARK all all \
    --hmark-tuple:ex:--hmark-src-prefix,--hmark-dst-prefix,--hmark-sport-mask,--hmark-dport-mask,--hmark-spi-mask,--hmark-proto-mask:need1 \
    --hmark-mod:need --hmark-offset \
    --hmark-src-prefix:ex:--hmark-tuple:need1 \
    --hmark-dst-prefix:ex:--hmark-tuple:need1 \
    --hmark-sport-mask:ex:--hmark-tuple,--hmark-spi-mask:need1 \
    --hmark-dport-mask:ex:--hmark-tuple,--hmark-spi-mask:need1 \
    --hmark-spi-mask:ex:--hmark-tuple,--hmark-sport-mask,--hmark-dport-mask:need1 \
    --hmark-proto-mask:ex:--hmark-tuple:need1 \
    --hmark-rnd:need" # TODO: check used options form -tuple completion
"IDLETIMER all all --timeout --label:need"
"LED all all --led-trigger-id:need --led-delay --led-always-blink"
"LOG all all --log-level --log-prefix --log-tcp-sequence --log-tcp-options --log-ip-options --log-uid"
"MASQUERADE v4 nat --to-ports:proto:tcp,udp --random:proto:tcp,udp" # TODO: only tcp,udp? what about dccp,sctp,udplite?
"MIRROR v4 mangle" # TODO: tables? don't have it
"NETMAP v4 nat --to"
"NFLOG all all --nflog-group --nflog-prefix --nflog-range --nflog-threshold"
"NFQUEUE all all --queue-num:ex:--queue-balance \
   --queue-balance:ex:--queue-num --queue-bypass"
"NOTRACK all raw"
"RATEEST all all --rateest-name:need --rateest-interval:need --rateest-ewmalog:need"
"REDIRECT v4 nat --to-ports:proto:tcp,udp --random:proto:tcp,udp" # TODO: only tcp,udp? what about dccp,sctp,udplite?
"REJECT all filter --reject-with"
"SECMARK all mangle,security --selctx"
"SET all all --add-set:ex:--del-set:need1 --del-set:ex:--add-set:need1 --timeout --exist"
"SNAT v4 nat --to-source:need --random:ex:--persistent --persistent:ex:--random"
"SNPT v6 mangle --src-pfx --dst-pfx"
"TEE all all --gateway" # TODO: really valid in all tables? cmdline does not forbid it
"TCPMSS all mangle --set-mss:ex:--clamp-mss-to-pmtu --clamp-mss-to-pmtu:ex:--set-mss"
"TCPOPTSTRIP all mangle --strip-options"
"TOS all mangle --set-tos:ex:--and-tos,--or-tos,--xor-tos \
    --and-tos:ex:--set-tos,--or-tos, --xor-tos \
    --or-tos:ex:--set-tos,--and-tos,--xor-tos \
       --xor-tos:ex:--set-tos,--and-tos,--or-tos"
"TPROXY all mangle --on-port:proto:tcp,udp:need --on-ip:proto:tcp,udp --tproxy-mark"
"TRACE all raw"
"TTL v4 mangle --ttl-set:ex:--ttl-dec,--ttl-inc \
   --ttl-dec:ex:--ttl-set,--ttl-inc \
   --ttl-inc:ex:--ttl-set,--ttl-dec"
"ULOG v4 all --ulog-nlgroup --ulog-prefix --ulog-cprange --ulog-qthreshold"
)

# match-name all|v4|v6 all|table1,table2,... option[,alias] [...]
local arr_matches=(
"tcp all all --source-port,--sport --destination-port,--dport --tcp-flags --syn --tcp-option"
"udp all all --source-port,--sport --destination-port,--dport"
"icmp v4 all --icmp-type"
"icmp6 v6 all --icmpv6-type"
"addrtype all all --src-type:need1 --dst-type:need1 --limit-iface-in:neg:no --limit-iface-out:neg:no"
"ah v4 all --ahspi"
"ah v6 all --ahspi --ahlen --ahres:neg:no"
"cluster all all --cluster-total-nodes:neg:no:need --cluster-local-node:need1 \
    --cluster-local-nodemask:need1 --cluster-hash-seed:neg:no:need"
"comment all all --comment:neg:no"
"connbytes all all --connbytes:need --connbytes-dir:neg:no:need --connbytes-mode:neg:no:need"
"connlimit all all --connlimit-upto:ex:--connlimit-above:neg:no:need1 \
    --connlimit-above:ex:--connlimit-upto:neg:no:need1 \
    --connlimit-mask:neg:no --connlimit-saddr:neg:no --connlimit-daddr:neg:no" # TODO: valid in all tables?
"connmark all all --mark"
"conntrack all all --ctstate --ctproto --ctorigsrc --ctorigdst --ctreplsrc \
    --ctrepldst --ctorigsrcport --ctorigdstport --ctreplsrcport \
    --ctrepldstport --ctstatus --ctexpire --ctdir:neg:no"
"cpu all all --cpu"
"dccp all all --source-port,--sport --destination-port,--dport --dccp-types --dccp-option"
"devgroup all all --src-group --dst-group" # TODO: retrieve names of device groups
"dscp all all --dscp:ex:--dscp-class --dscp-class:ex:--dscp"
"dst v6 all --dst-len --dst-opts:neg:no" # TODO: valid values, --dst-opts value only twice?
"ecn all all --ecn-tcp-cwr --ecn-tcp-ece --ecn-ip-ect"
"esp all all --espspi"
"eui64 v6 all"
"frag v6 all --fragid --fraglen --fragres:neg:no --fragfirst:neg:no \
    --fragmore:neg:no --fraglast:neg:no" # TODO: any option mandatory?
"hashlimit all all --hashlimit-upto:ex:--hashlimit-above:neg:no:need1 \
    --hashlimit-above:ex:--hashlimit-upto:neg:no:need1 \
    --hashlimit-burst:neg:no --hashlimit-mode:neg:no \
    --hashlimit-srcmask:neg:no --hashlimit-dstmask:neg:no \
    --hashlimit-name:neg:no:need --hashlimit-htable-size:neg:no \
    --hashlimit-htable-max:neg:no --hashlimit-htable-expire:neg:no \
    --hashlimit-htable-gcinterval:neg:no"
"hbh v6 all --hbh-len --hbh-opts:neg:no"
"helper all all --helper" # TODO: check if we can retrieve list of helpers
"hl v6 all --hl-eq:ex:--hl-gt,--hl-lt \
    --hl-gt:ex:--hl-eq,--hl-lt:neg:no \
    --hl-lt:ex:--hl-eq,--hl-gt:neg:no"
"iprange all all --src-range --dst-range"
"ipv6header v6 all --header:need --soft:neg:no"
"ipvs all all --ipvs --vproto --vaddr --vport --vdir:neg:no --vmethod --vportctl"
"length all all --length"
"mac all all --mac-source"
"mh v6 all --mh-type" # TODO: named mh-types, ip6tables -p ipv6-mh -h does not display any
"owner all all --uid-owner --gid-owner --socket-exists"
"limit all all --limit:neg:no --limit-burst:neg:no"
"mark all all --mark"
"multiport all all --source-ports,--sports:ex:--ports \
    --destination-ports,--dports:ex:--ports \
    --ports:ex:--source-ports,--sports,--destination-ports,--dports"
"nfacct all all --nfacct-name:neg:no"
"osf all all --genre:need --ttl:neg:no --log:neg:no" # TODO: retrieve valid genre strings?
"physdev all all --physdev-in --physdev-out --physdev-is-in --physdev-is-out --physdev-is-bridged"
"pkttype all all --pkt-type"
"policy all all --dir:neg:no:need --pol:neg:no:need --strict:neg:no --reqid --spi --proto --mode \
    --tunnel-src:optis:mode=tunnel --tunnel-dst:optis:mode=tunnel --next:neg:no" # TODO: reqid value?
"quota all all --quota"
"rateest all all --rateest-delta:neg:no \
    --rateest-lt:ex:--rateest-gt,--rateest-eq \
    --rateest-gt:ex:--rateest-lt,--rateest-eq \
    --rateest-eq:ex:--rateest-lt,--rateest-gt \
    --rateest:ex:--rateest1,--rateest2,--rateest-bps1,--rateest-bps2,--rateest-pps1,--rateest-pps2:neg:no:need1 \
    --rateest1:ex:--rateest,--rateest-bps,--rateest-pps:neg:no:need1 \
    --rateest2:ex:--rateest,--rateest-bps,--rateest-pps:neg:no:need1 \
    --rateest-bps:ex:--rateest1,--rateest2,--rateest-bps1,--rateest-bps2,--rateest-pps1,--rateest-pps2:neg:no \
    --rateest-pps:ex:--rateest1,--rateest2,--rateest-bps1,--rateest-bps2,--rateest-pps1,--rateest-pps2:neg:no \
    --rateest-bps1:ex:--rateest,--rateest-bps,--rateest-pps:neg:no \
    --rateest-bps2:ex:--rateest,--rateest-bps,--rateest-pps:neg:no \
    --rateest-pps1:ex:--rateest,--rateest-bps,--rateest-pps:neg:no \
    --rateest-pps2:ex:--rateest,--rateest-bps,--rateest-pps:neg:no"
"realm v4 all --realm"
"recent all all --name:neg:no --set:ex:--rcheck,--update,--remove:need1 \
    --rcheck:ex:--set,--update,--remove:need1 \
    --update:ex:--set,--rcheck,--remove:need1 \
    --remove:ex:--set,--rcheck,--update:need1 \
    --rttl:ex:--set,--remove:neg:no \
    --rsource:neg:no --rdest:neg:no --mask:neg:no --seconds:neg:no \
    --reap:neg:no --hitcount:neg:no"
"rpfilter all mangle,raw --loose:neg:no --validmark:neg:no \
    --accept-local:neg:no --invert:neg:no"
"rt v6 all --rt-type --rt-segsleft --rt-len --rt-0-res:neg:no \
    --rt-0-addrs:neg:no --rt-0-not-strict:neg:no"
"sctp all all --source-port,--sport --destination-port,--dport --chunk-types"
"set all all --match-set:need --return-nomatch:neg:no"
"socket all all --transparent:neg:no" # TODO: was --transparent option available from the beginning?
"state all all --state"
"statistic all all --mode:neg:no:need --probability:optis:--mode=random \
    --every:optis:--mode=nth --packet:optis:--mode=nth:neg:no"
"string all all --algo:neg:no:need --from:neg:no --to:neg:no \
    --string:ex:--hex-string --hex-string:ex:--string"
"tcpmss all all --mss"
"time all all --datestart:neg:no --timestart:neg:no --timestop:neg:no \
    --monthdays --weekdays --kerneltz:neg:no --contiguous:neg:no" # TODO: --date[start|stop] value verification
"tos all all --tos"
"ttl v4 all --ttl-eq:ex:--ttl-gt,--ttl-lt \
    --ttl-gt:ex:--ttl-eq,--ttl-lt:neg:no \
    --ttl-lt:ex:--ttl-eq,--ttl-gt:neg:no"
"u32 all all --u32"
"unclean v4 all" # don't have it
)

COMPREPLY=()
#COMP_WORDBREAKS=$' \t\n"\'><=;|&(:'

# expecting _get_comp_words_by_ref() to exist from bash_completion
if declare -f _get_comp_words_by_ref &>/dev/null; then
    got_bashcompl=1
    # at least bash version 4.+ is required with bash_completion package
    ((${BASH_VERSINFO[0]} < 4)) && return 0
    _get_comp_words_by_ref -n : cur prev cword words || return
else # not so neat, but a workaround
    COMP_WORDBREAKS="${COMP_WORDBREAKS//:/}"
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    cword=$COMP_CWORD
    for i in ${!COMP_WORDS[@]}; do words[i]="${COMP_WORDS[i]}"; done
fi

# show debug information if env var is set
#_DEBUG_NF_COMPLETION=Y
if [[ $_DEBUG_NF_COMPLETION ]]; then
    printf "\nCOMP_WORDBREAKS: <%s>\n" "$COMP_WORDBREAKS"
    printf "COMP_LINE: <%s>\n" "$COMP_LINE"
    printf "COMP_TYPE: <%s>\n" "$COMP_TYPE"
    printf "COMP_POINT: <%s>\n" "$COMP_POINT"
    printf "COMP_KEY: <%s>\n" "$COMP_KEY"
    printf "COMP_CWORD: <%s>\n" "$COMP_CWORD"
    printf "cword: <%s>\n" "$cword"
    printf "words:\n" "<%s>\n" "${words[@]}"
    printf "cur: <%s> prev: <%s>\n" "$cur" "$prev"
fi

local arr_opts=(
"-d --destination"
"-f --fragment"
"-g --goto"
"-h --help"
"-i --in-interface"
"-j --jump"
"-m --match"
"-n --numeric"
"-o --out-interface"
"-p --protocol"
"-s --source"
"-t --table"
"-v --verbose"
"-x --exact"
"-A --append"
"-C --check"
"-D --delete"
"-E --rename-chain"
"-F --flush"
"-I --insert"
"-L --list"
"-N --new"
"-P --policy"
"-R --replace"
"-S --list-rules"
"-V --version"
"-X --delete-chain"
"-Z --zero"
--line-numbers
--set-counters
--modprobe=
)

# gather information about the command line
for ((i=1; i < ${#words[@]}-1; i++)); do
    case ${words[i]} in
        -j|--jump|-g|--goto)
            ((cword > last_index && cword > i)) && str_last_is=target
            str_jump=${words[i]}
            str_target="${words[i+1]}" target_index=$((i+1)) last_index=$i
            arr_cmd_opts+=(${words[i]})
        ;;
        -t|--table)
            if ((cword > last_index && cword > i)); then
                str_last_is=option
                arr_last_opts+=(${words[i]})
            fi
            str_table="${words[i+1]}"
            arr_cmd_opts+=(${words[i]})
            last_option_index=$i
        ;;
        -m|--match)
            if ((cword > last_index && cword > i)); then
                str_last_is=match
                last_match_index=$((i+1))
                arr_cmd_matches+=("${words[i+1]}")
            fi
            last_index=$i
            arr_cmd_opts+=(${words[i]})
            got_rule_opt=1
            arr_all_matches+=("${words[i+1]}")
            if [[ ${words[i+1]} = @(icmp|tcp|udp|ah|esp|dccp|sctp) ]]; then
                str_proto_match="${words[i+1]}"
            fi
        ;;
        -p|--proto|--protocol)
            if [[ ${words[i]} = --proto ]]; then
                if ((${#arr_cmd_matches[@]})) && \
                    [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]
                then
                    continue # policy match also has --proto !!DAMN!!
                fi
            fi
            if [[ ${words[i-1]} != \! ]]; then
                str_proto="${words[i+1]}"
                if [[ $str_proto = +([[:digit:]]) ]]; then
                    # translate known numeric proto specs into names
                    for x in ${!arr_proto_defs[@]}; do
                        set -- ${arr_proto_defs[x]}
                        if ((str_proto == $2)); then
                            str_proto=$1
                            # if proto is a known match, add it to list of matches
                            if ((cword > last_index && cword > i)); then
                                str_last_is=match
                                last_match_index=$((i+1))
                                arr_cmd_matches+=("$str_proto")
                            else
                                str_last_is=option
                                arr_last_opts+=(${words[i]})
                            fi
                            break
                        fi
                    done
                else
                    # if proto is a known match, add it to list of matches
                    if ((cword > last_index && cword > i)); then
                        if _iptables_is_match "${words[i+1]}"; then
                            str_last_is=match
                            arr_cmd_matches+=("$str_proto")
                            last_match_index=$((i+1))
                        else
                            str_last_is=option
                            arr_last_opts+=(${words[i]})
                        fi
                    fi
                fi
            else
                proto_negated=1
                if ((cword > last_index && cword > i)); then
                    str_last_is=option
                    arr_last_opts+=(${words[i]})
                fi
            fi
            last_index=$i
            got_rule_opt=1
            arr_cmd_opts+=(${words[i]})
        ;;
        @(-@(A|-append|C|-check|E|-rename-chain|F|-flush|P|-policy|X|-delete-chain)))
            let got_action+=1
            ((cword > last_index && cword > i)) && str_last_is=action
            last_index=$i
#            str_chain="${words[i+1]}"
            str_action=${words[i]}
            arr_cmd_opts+=(${words[i]})
            last_option_index=$i
        ;;
        @(-@(D|-delete|I|-insert|R|-replace|L|-list|N|-new|S|-list-rules|Z|-zero)))
            if [[ ${words[i]} = --new && $str_target = CLUSTERIP ]] && \
                ((i == target_index+1)); then
                # CLUSTERIP also has --new
                continue
            fi
            let got_action+=1
            ((cword > last_index && cword > i)) && str_last_is=action
            last_index=$i
#            str_chain="${words[i+1]}"
            str_action=${words[i]} rulenum=$(_iptables_get_rulenum $i)
            arr_cmd_opts+=(${words[i]})
            last_option_index=$i
        ;;
        --line-numbers)
            list_only=1
            if ((cword > last_index && cword > i)); then
                str_last_is=option
                arr_last_opts+=(${words[i]})
            fi
            last_index=$i
            rulenum=$(_iptables_get_rulenum $i)
            arr_cmd_opts+=(${words[i]})
            last_option_index=$i
        ;;
        --set-counters)
            set_counters=1
            if ((cword > last_index && cword > i)); then
                str_last_is=option
                arr_last_opts+=(${words[i]})
            fi
            last_index=$i
            arr_cmd_opts+=(${words[i]})
            last_option_index=$i
        ;;
        --exact|-x|-n|--numeric)
            list_only=1
            if ((cword > last_index && cword > i)); then
                str_last_is=option
                arr_last_opts+=(${words[i]})
            fi
            last_index=$i
            arr_cmd_opts+=(${words[i]})
            last_option_index=$i
        ;;
        -d|--destination|-f|--fragment|-i|--in-interface|-o|--out-interface|\
            -s|--source|--modprobe=)
            if ((cword > last_index && cword > i)); then
                str_last_is=option
                arr_last_opts+=(${words[i]})
            fi
            last_index=$i
            arr_cmd_opts+=(${words[i]})
            last_option_index=$i
            got_rule_opt=1
        ;;
        -v|--verbose|--ipv4|-4|--ipv6|-6)
            if ((cword > last_index && cword > i)); then
                str_last_is=option
                arr_last_opts+=(${words[i]})
            fi
            last_index=$i
            arr_cmd_opts+=(${words[i]})
            last_option_index=$i
        ;;
        --match-set|--add-set|--del-set)
            if [[ ${words[i+1]} = -?* && ${words[i+1]} != $cur ]]; then
                # quit if we have a set name overlapping an option name
                for x in ${arr_opts[*]}; do
                    [[ $x = ${words[i+1]} ]] && return 0
                done
                # register weird set names
                arr_set_names+=("${words[i+1]}")
            fi
        ;;
    esac
done
if ((got_action > 1)); then # allow only one main command
    return 0
fi

# init with empty string so we don't run into bad subscript error
((${#arr_cmd_matches[@]})) || arr_cmd_matches[0]=""
((${#arr_cmd_opts[@]})) || arr_cmd_opts[0]=""
((${#arr_last_opts[@]})) || arr_last_opts[0]=""

# debug info about the gathered information
if [[ $_DEBUG_NF_COMPLETION ]]; then
    printf "arr_cmd_matches[*]: %s\n" "${arr_cmd_matches[*]}"
    printf "arr_cmd_opts[*]: %s\n" "${arr_cmd_opts[*]}"
    printf "arr_last_opts[*]: %s\n" "${arr_last_opts[*]}"
#    printf "str_chain: %s\n" "$str_chain"
    printf "str_jump: %s\n" "$str_jump"
    printf "str_target: %s\n" "$str_target"
    printf "str_proto: %s\n" "$str_proto"
    printf "target_index: %s\n" "$target_index"
    printf "last_match_index: %s\n" "$last_match_index"
    printf "last_option_index: %s\n" "$last_option_index"
    printf "proto_negated: %s\n" "$proto_negated"
fi


# time to match on current word request
if [[ $cur = -* ]]; then # any option is requested
    if [[ $str_target = CLUSTERIP ]]; then # CLUSTERIP rules must start with --new
        if [[ ${words[target_index+2]} && ${words[target_index+1]} != --new ]]
        then return 0
        fi
    fi
    case "$prev" in # depend on previous option - terminating choices first
        -h|--help)
            return 0
        ;;
        -@(A|-append|C|-check|D|-delete|E|-rename-chain|I|-insert|N|-new|P|-policy|R|-replace|V|-version))
            if ! [[ $prev = --new && $str_target = CLUSTERIP ]] && ((cword == target_index+2)); then
                return 0 # command option not valid at this context
            fi
        ;;
        --@(add-set|del-set|match-set)) # set match and SET target
            # if the set names start with a dash
            COMPREPLY=( $( compgen -W '$(PATH=${PATH}:/sbin command ipset -n list)' -- $cur ) )
            ((got_bashcompl)) && __ltrim_colon_completions "$cur"
            return 0
        ;;
        -@(j|jump|g|goto|i|-in-interface|o|-out-interface|m|-match|p|-proto|-protocol|s|-source|d|-destination|t|-table|-h|--help|-set-counters))
            return 0 # option not valid at this context
        ;;
        --@(dport|destination-port|sport|source-port|icmp-type|icmpv6-type|tcp-option|tcp-flags))
            return 0 # match option not valid at this context
        ;;
        --@(comment|chunk-types|cpu|connbytes|connbytes-dir|connbytes-mode|ecn-ip-ect|helper))
            return 0 # match option not valid at this context
        ;;
        --@(length|mac-source|mark|mss|pkt-type|quota|src-range|dst-range|src-type|dst-type|uid-owner|gid-owner|realm|tos))
            return 0 # match option not valid at this context
        ;;
        --@(algo|from|to|string|hex-string|mode|probability|every|packet|rt-type|rt-segsleft|rt-len|rt-0-addrs))
            return 0 # match option not valid at this context
        ;;
        --@(physdev-in|physdev-out|genre|ttl|log|limit|limit-burst|mh-type|nfacct-name|fragid|fraglen|ahspi|espspi))
            return 0 # match option not valid at this context
        ;;
        --@(connlimit-upto|connlimit-above|connlimit-mask|src-group|dst-group|name|mask|seconds|hitcount|state|header))
            return 0 # match option not valid at this context
        ;;
        --@(dccp-option|dccp-types|dst-len|dst-opts|hbh-len|hbh-opts|datestart|datestop|timestart|timestop|monthdays|weekdays))
            return 0 # match option not valid at this context
        ;;
        --@(cluster-total-nodes|cluster-local-node|cluster-local-nodemask|cluster-hash-seed))
            return 0 # cluster match option not valid at this context
        ;;
        --ct@(state|proto|origsrc|origdst|replsrc|repldst|origsrcport|origdstport|replsrcport|repldstport|status|expire|dir))
            return 0 # conntrack match option not valid at this context
        ;;
        --@(dports|destination-ports|sports|source-ports|ports))
            return 0 # multiport match option not valid at this context
        ;;
        --@(dir|pol|reqid|spi|tunnel-src|tunnel-dst))
            return 0 # policy match option not valid at this context
        ;;
        --hashlimit-@(upto|above|burst|mode|srcmask|dstmask|name|htable-size|htable-max|htable-expire|htable-gcinterval))
            return 0 # hashlimit match option not valid at this context
        ;;
        --@(vproto|vaddr|vport|vdir|vmethod|vportctl))
            return 0 # ipvs match option not valid at this context
        ;;
        --rateest?(1|2|-bps|-pps|-bps1|-bps2|-pps1|-pps2))
            return 0 # rateest match option not valid at this context
        ;;
        --@(set-xmark|and-mark|or-mark|xor-mark|set-mark|nfmask|ctmask))
            return 0 # CONNMARK target option not valid at this context
        ;;
        --hmark-@(tuple|mod|offset|src-prefix|dst-prefix|sport-mask|dport-mask|spi-mask|proto-mask|rnd))
            return 0 # HMARK target option not valid at this context
        ;;
        --@(ctevents|expevents|zone|timeout))
            return 0 # CT target option not valid at this context
        ;;
        --@(gateway|reject-with|to-destination|to-source|to-ports|to|selctx|set-class|set-mss|label|type))
            return 0 # target option not valid at this context
        ;;
        --@(queue-num|queue-balance|set-dscp|dscp|dscp-class|set-dscp-class|set-tos|and-tos|or-tos|xor-tos|strip-options))
            return 0 # target option not valid at this context
        ;;
        --@(led-trigger-id|led-delay|rateest-name|rateest-interval|rateest-ewmalog|on-port|on-ip|tproxy-mark|u32))
            return 0 # target option not valid at this context
        ;;
        --@(hl-set|hl-dec|hl-inc|hl-eq|hl-gt|hl-lt|ttl-set|ttl-dec|ttl-inc|ttl-eq|ttl-gt|ttl-lt))
            return 0 # target option not valid at this context
        ;;
        --@(hashmode|clustermac|total-nodes|local-node|hash-init))
            return 0 # CLUSTERIP target option not valid at this context
        ;;
        --@(src-pfx|dst-pfx))
            return 0 # DNPT/SNPT target option not valid at this context
        ;;
        --@(log-level|log-prefix|nflog-group|nflog-prefix|nflog-range|nflog-threshold|\
            ulog-nlgroup|ulog-prefix|ulog-cprange|ulog-qthreshold))
            return 0 # [U|NF]LOG target option not valid at this context
        ;;
    esac
    i=$((cword - 2))
    if ((i >= 1)); then # depend on option before previous option
        case "${words[i]}" in
            -E|--rename-chain|-P|--policy|-R|--replace|--set-counters|--chunk-types)
                return 0
            ;;
            --@(add-set|del-set|match-set)) # expecting set flag
                return 0
            ;;
        esac
        if [[ ${_IPT_VALIDATE_INPUT-1} ]]; then
            case "${words[i]}" in
                --@(hl-set|hl-dec|hl-inc|ttl-set|ttl-dec|ttl-inc|ttl-eq|ttl-gt|ttl-lt|dccp-option|\
                    nflog-group|nflog-range|nflog-threshold|total-nodes|local-node|led-delay|\
                    ulog-cprange|ulog-qthreshold|from|to|every|packet|rt-type|rt-len|ttl|log|\
                    limit-burst|hl-eq|hl-gt|hl-lt|fraglen|connlimit-upto|connlimit-above|ahlen|\
                    cluster-total-nodes|cluster-local-node|spi|seconds|hitcount|hbh-len|dst-len|\
                    hmark-offset))
                    [[ $prev = +([[:digit:]]) ]] || return 0 # digit value expected
                ;;
                --hashlimit-@(burst|buckets|entries|htable-expire|htable-gcinterval))
                    [[ $prev = +([[:digit:]]) ]] || return 0 # hashlimit match - digit value expected
                    return 0
                ;;
                --@(hashlimit-srcmask|hashlimit-dstmask))
                    [[ $prev = +([[:digit:]]) ]] || return 0
                    ((prev > 32)) && return 0
                ;;
                --zone) # CT target | 16bit digit|xdigit
                    [[ $prev = @(+([[:digit:]])|0x+([[:xdigit:]])) ]] || return 0
                    ((prev >= 0 && prev <= 0xFFFF)) || return 0
                ;;
                --timeout)
                    if [[ $str_target = @(IDLETIMER|SET) ]]; then
                        [[ $prev = +([[:digit:]]) ]] || return 0 # IDELTIMER,SET targets - digit value expected
                        # CT target also has --timeout
                    fi
                ;;
                --hmark-mod) # HMARK target - int >0
                    [[ $prev = +([[:digit:]]) ]] || return 0
                    ((prev > 0)) || return 0
                ;;
                --hmark-sport-mask|--hmark-dport-mask) # HMARK target - 16 bit xdigit
                    [[ $prev = 0x+([[:xdigit:]]) ]] || return 0
                    ((prev >= 0 && prev <= 0xFFFF)) || return 0
                ;;
                --mask) # CONNMARK target and recent match have --mask
                    if [[ $str_target = CONNMARK ]]; then
                        [[ $prev = @(0x+([[:xdigit:]])|+([[:digit:]])) ]] || return 0
                        ((prev <= 4294967295)) || return 0
                    elif [[ ${arr_matches[${#arr_matches[@]}-1]} = recent ]]; then
                        [[ $prev = +([[:digit:]]) ]] || return 0
                        ((prev > 32)) && return 0
                    fi
                ;;
                --hmark-proto-mask) # 8bit digit or xdigit value | HMARK target
                    [[ $prev = @(0x+([[:xdigit:]])|+([[:digit:]])) ]] || return 0
                    ((prev <= 0xFF)) || return 0
                ;;
                --@(cluster-local-nodemask|ct-mask|nf-mask|and-mark|or-mark|xor-mark|hmark-spi-mask|hmark-rnd|reqid))
                    # 32bit digit or xdigit value expected
                    [[ $prev = @(0x+([[:xdigit:]])|+([[:digit:]])) ]] || return 0
                    ((prev <= 4294967295)) || return 0
                ;;
                --@(mark|set-mark|set-xmark|tproxy-mark)) # [CONN]MARK/TPROXY target mark[/mask], [conn]mark match
                    [[ $prev = @(+([[:digit:]])|0x+([[:xdigit:]]))?(/@(+([[:digit:]])|0x+([[:xdigit:]]))) ]] || return 0
                    for str_tmp in ${prev//\// }; do
                        ((str_tmp <= 4294967295)) || return 0
                    done
                ;;
                # numeric range definition with `:' expected -> COMP_WORDBREAKS `:' problem
                --@(fragid|mss|rt-segsleft|ctexpire))
                    [[ $prev = +([[:digit:]])?(:+([[:digit:]])) ]] || return 0
                ;;
                --ahspi|--espspi) # 32 bit range values -> COMP_WORDBREAKS `:' problem
                    [[ $prev = +([[:digit:]])?(:+([[:digit:]])) ]] || return 0
                    for str_tmp in ${prev/:/ }; do
                        ((str_tmp <= 4294967295)) || return 0
                    done
                ;;
                --connlimit-mask) # connlimit match
                    [[ $prev = +([[:digit:]]) ]] || return 0
                    if [[ $str_app = iptables ]]; then
                        ((prev > 32)) && return 0
                    elif [[ $str_app = ip6tables ]]; then
                        ((prev > 128)) && return 0
                    fi
                ;;
                --label) # IDLETIMER target
                    ((${#prev} > 27)) && return 0
                ;;
                --log-prefix) # LOG target
                    ((${#prev} > 29)) && return 0
                ;;
                --nflog-prefix) # NFLOG target
                    ((${#prev} > 64)) && return 0
                ;;
                --ulog-prefix) # ULOG target
                    ((${#prev} > 32)) && return 0
                ;;
                --@(limit|hashlimit-upto|hashlimit-above)) # [hash]limit match
                    [[ $prev = +([[:digit:]])?(/@(second|minute|hour|day)) ]] || return 0
                ;;
                --probability) # statistic match
                    [[ $prev = @(0?(.[0-9])|1?(.0)) ]] || return 0
                ;;
                --queue-num) # NFQUEUE target
                    [[ $prev = +([[:digit:]]) ]] || return 0
                    ((prev > 65535)) && return 0
                ;;
                --ulog-nlgroup) # ULOG target
                    [[ $prev = +([[:digit:]]) ]] || return 0
                    ((prev < 1 || prev > 32)) && return 0
                ;;
                --@(dscp|set-dscp)) # dscp match and DSCP target - digit or 0xxdigit
                    [[ $prev = @(+([[:digit:]])|0x+([[:xdigit:]])) ]] || return 0
                    ((prev > 63)) && return 0
                ;;
                --hbh-opts|--dst-opts) # hbh and dst match -> COMP_WORDBREAKS `:' problem
                    [[ $prev = +([[:digit:]]):+([[:digit:]])*(,+([[:digit:]]):+([[:digit:]])) ]] || return 0
                ;;
                --to-ports) # MASQUERADE/REDIRECT target
                    [[ $prev = +([[:digit:]])-+([[:digit:]]) ]] || return 0
                ;;
                --src-pfx|--dst-pfx) # DNPT/SNPT target -> COMP_WORDBREAKS `:' problem
                    [[ $prev = */+([[:digit:]]) ]] || return 0
                ;;
                --timestart|--timestop) # time match -> COMP_WORDBREAKS `:' problem
                    [[ $prev = +([[:digit:]])+([[:digit:]]):+([[:digit:]])+([[:digit:]])?(:+([[:digit:]])+([[:digit:]])) ]] || return 0
                ;;
                --monthdays) # time match
                    [[ $prev = +([[:digit:]])*(,+([[:digit:]])) ]] || return 0
                    for str_tmp in ${prev//,/ }; do
                        ((str_tmp < 1 || str_tmp > 31)) && return 0
                    done
                ;;
                --weekdays) # time match
                    str_tmp="Mo|Mon|Tu|Tue|We|Wed|Th|Thu|Fr|Fri|Sa|Sat|Su|Sun"
                    if [[ $prev = @(@($str_tmp)|+([[:digit:]]))*(,@(@($str_tmp)|+([[:digit:]]))) ]]
                    then
                        for str_var in ${prev//,/ }; do
                            if [[ $str_var = +([[:digit:]]) ]]; then
                                ((str_var < 1 || str_var > 7)) && return 0
                            elif [[ $str_var = @($str_tmp)*(,@($str_tmp)) ]]; then :
                            else return 0
                            fi
                        done
                    else return 0
                    fi
                ;;
            esac
        fi
    fi

    # done with terminating conditions, set options
    if [[ $prev = \! ]]; then
        local arr_rule_action_opts=(
        "-d --destination"
        "-f --fragment"
        "-i --in-interface"
        "-o --out-interface"
        "-p --protocol"
        "-s --source"
        )
    else
        local arr_rule_action_opts=(
        "-d --destination"
        "-f --fragment"
        "-g --goto"
        "-i --in-interface"
        "-j --jump"
        "-m --match"
        "-o --out-interface"
        "-p --protocol"
        "-s --source"
        "-t --table"
        "-v --verbose"
        --modprobe=
        )
    fi

    if ((rulenum)) && \
        [[ $str_action != @(-@(L|-list|S|-list-rules|I|-insert|R|-replace)) ]]
    then
        # we have a rulenumber given, under certain commands,
        # this reduces amount of valid options
        arr_tmp_opts=(
            "-t --table"
            "-v --verbose"
            )
    elif ((list_only && ! got_action)); then
        # rule listing options
        if [[ $prev != \! ]]; then
            arr_tmp_opts=(
            "-t --table"
            "-v --verbose"
            "-L --list"
            "-n --numeric"
            "-x --exact"
            )
        fi
    elif ((set_counters && ! got_action)); then
        # set-counters reduces available options
        if [[ $prev != \! ]]; then
            if [[ ${_IPT_OPTS_ON_START:=actions} = actions ]]; then
                arr_tmp_opts=(
                "-j --jump"
                "-g --goto"
                "-m --match"
                "-t --table"
                "-v --verbose"
                "-A --append"
                "-I --insert"
                --modprobe=
                )
            else
                arr_tmp_opts=(
                "-d --destination"
                "-f --fragment"
                "-g --goto"
                "-i --in-interface"
                "-j --jump"
                "-m --match"
                "-o --out-interface"
                "-p --protocol"
                "-s --source"
                "-t --table"
                "-v --verbose"
                "-A --append"
                "-I --insert"
                --modprobe=
                )
            fi
        fi
    elif ((got_rule_opt && ! got_action)); then
        # we already got an option on the command line
        if [[ $prev = \! ]]; then
            arr_tmp_opts=("${arr_rule_action_opts[@]}") 
        else
            arr_tmp_opts=(
            "-d --destination"
            "-f --fragment"
            "-g --goto"
            "-i --in-interface"
            "-j --jump"
            "-m --match"
            "-o --out-interface"
            "-p --protocol"
            "-s --source"
            "-t --table"
            "-v --verbose"
            "-A --append"
            "-C --check"
            "-D --delete"
            "-I --insert"
            "-R --replace"
            --set-counters
            --modprobe=
            )
        fi
    elif ! ((got_action)); then
        # if we don't know the main command and haven't defined remaining options
        # while parsing existing cmdline, set option list to main command list
        if [[ $str_target ]]; then
            arr_tmp_opts=(
                "-m --match"
                "-t --table"
                "-v --verbose"
                "-A --append"
                "-C --check"
                "-D --delete"
                "-I --insert"
                "-R --replace"
                )
            if [[ $_IPT_OPTS_ON_START != actions ]]; then
                arr_tmp_opts+=(
                    "-d --destination"
                    "-f --fragment"
                    "-i --in-interface"
                    "-o --out-interface"
                    "-p --protocol"
                    "-s --source"
                    "-v --verbose"
                    --modprobe=
                    )
            fi
            if [[ $str_target = @(ACCEPT|DROP) ]]; then
                arr_tmp_opts+=("-P --policy")
            fi
        else
            # env var controls wether we show all or a subset of options
            if [[ ${_IPT_OPTS_ON_START:=actions} = actions ]]; then
                if [[ $prev = \! ]]; then
                    arr_tmp_opts=(
                        "-h --help"
                        "-V --version"
                        )
                else
                    arr_tmp_opts=(
                        "-h --help"
                        "-j --jump"
                        "-m --match"
                        "-t --table"
                        "-v --verbose"
                        "-A --append"
                        "-C --check"
                        "-D --delete"
                        "-E --rename-chain"
                        "-F --flush"
                        "-I --insert"
                        "-L --list"
                        "-N --new"
                        "-P --policy"
                        "-R --replace"
                        "-S --list-rules"
                        "-V --version"
                        "-X --delete-chain"
                        "-Z --zero"
                        )
                fi
            else
                if [[ $prev = \! ]]; then
                    arr_tmp_opts=(
                        "-d --destination"
                        "-f --fragment"
                        "-h --help"
                        "-i --in-interface"
                        "-o --out-interface"
                        "-p --protocol"
                        "-s --source"
                        "-V --version"
                        )
                else
                    arr_tmp_opts=("${arr_opts[@]}")
                fi
            fi
        fi
    else
        # depend on action
        case "$str_action" in
            -A|--append|-I|--insert)
                if [[ $prev != \! ]]; then
                    arr_rule_action_opts+=("--set-counters")
                fi
                arr_tmp_opts=("${arr_rule_action_opts[@]}") 
            ;;
            -C|--check|-D|--delete|-R|--replace)
                arr_tmp_opts=("${arr_rule_action_opts[@]}") 
            ;;
            -E|--rename-chain|-F|--flush|-N|--new|-X|--delete-chain|\
                -P|--policy|-S|--list-rules|-Z|--zero)
                arr_tmp_opts=(
                    "-t --table"
                    "-v --verbose"
                    )
            ;;
            -L|--list)
                if [[ $prev != \! ]]; then
                    arr_tmp_opts=(
                        "-n --numeric"
                        "-t --table"
                        "-v --verbose"
                        "-x --exact"
                        "--line-numbers"
                        )
                fi
            ;;
        esac
    fi

    # evaluate if help string should be shown
    if ((! got_action && cword < 7)); then
        if [[ -z ${arr_last_opts[0]} ]]; then
            if [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} && -z $str_target ]]
            then inline_help=1
            elif [[ $str_target && -z ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} ]]
            then
                for x in ${!arr_targets[@]}; do
                    [[ $str_target = ${arr_targets[x]%% *} ]] && inline_help=1 && break
                done
            fi
        fi
    fi

    case "$cur" in # show either short or long options (single or double dash)
        -?(+([[:word:]]))) # any short-option is requested
            arr_tmp_opts=( "${arr_tmp_opts[@]/% --*/}" )
            ((inline_help)) && str_help=-h
        ;;
        --?(+([[:word:]]))*) # any long-option is requested
            arr_tmp_opts=( "${arr_tmp_opts[@]/#-* }" )
            ((inline_help)) && str_help=--help
        ;;
    esac

    if [[ $str_jump ]]; then # remove mutual exclusive jump/goto
        case "$str_jump" in
            -j|--jump) str_tmp="-g|--goto" ;;
            -g|--goto) str_tmp="-j||--jump" ;;
        esac
        for x in ${!arr_tmp_opts[@]}; do
            if [[ ${arr_tmp_opts[x]} = @($str_tmp) ]]; then
                unset arr_tmp_opts[x]
                break
            fi
        done
    fi

    if ((${#words[@]} > 3)); then
        # we got one option, so remove options that are mutual exclusive to all others
        for i in ${!arr_tmp_opts[@]}; do
            if [[ ${arr_tmp_opts[i]} = @(-@(V|-version)) ]]; then
                unset arr_tmp_opts[i]
                break
            fi
        done
    fi

    # from here we start to set a compreply
    if [[ $str_last_is = action ]]
    then
        _iptables_dedupe_opt_alias
        COMPREPLY=( $( compgen -W \
            '$(_iptables_dedupe_opts ${arr_tmp_opts[@]})' -- $cur ) )
    elif _iptables_is_option "$prev"
    then
        _iptables_dedupe_opt_alias
        COMPREPLY=( $( compgen -W \
            '$(_iptables_dedupe_opts ${arr_tmp_opts[@]})' -- $cur ) )
    elif ((cword == target_index+1)) && _iptables_is_target "$prev"
    then
        # targets with no option
        if [[ $prev = @(ACCEPT|DROP|MIRROR|NOTRACK|TRACE) ]]; then
            _iptables_dedupe_opt_alias
            COMPREPLY=( $( compgen -W \
                '$(_iptables_dedupe_opts ${arr_tmp_opts[@]} $str_help)' -- $cur ) )
        # targets which don't demand an option
        elif [[ $prev = @(LOG|NFLOG|ULOG|MASQUERADE|REDIRECT) ]]; then
            _iptables_dedupe_opt_alias
            COMPREPLY=( $( compgen -W \
                '$(_iptables_dedupe_opts $(_iptables_get_target_opts "$prev") \
                ${arr_tmp_opts[@]} $str_help)' -- $cur ) )
        else
            COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts \
                $(_iptables_get_target_opts "$prev") $str_help)' -- $cur ) )
        fi
    elif ((cword == last_match_index+1)) && _iptables_is_match "$prev"
    then
        if [[ $prev = @(unclean|eui64) ]]; then # modules with no options
            _iptables_dedupe_opt_alias
            COMPREPLY=( $( compgen -W \
                '$(_iptables_dedupe_opts ${arr_tmp_opts[@]} $str_help)' -- $cur ) )
        # matches which don't demand an option
        elif [[ $prev = @(ah|frag|rpfilter) ]]; then
            _iptables_dedupe_opt_alias
            COMPREPLY=( $( compgen -W \
                '$(_iptables_dedupe_opts $(_iptables_get_match_opts "$prev") \
                ${arr_tmp_opts[@]} $str_help)' -- $cur ) )
        elif [[ ${words[cword-2]} = @(-p|--proto|--protocol) ]]; then
            _iptables_dedupe_opt_alias
            COMPREPLY=( $( compgen -W \
                '$(_iptables_dedupe_opts $(_iptables_get_match_opts "$prev") \
                ${arr_tmp_opts[@]} $str_help)' -- $cur ) )
        else
            COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts \
                $(_iptables_get_match_opts "$prev") $str_help)' -- $cur ) )
        fi
    elif ((cword == last_match_index+2)) && [[ $prev = \! && \
        ${words[last_match_index-1]} = @(-p|--proto|--protocol) ]]
    then # handle negation of proto-match
        _iptables_dedupe_opt_alias
        COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts \
            $(_iptables_get_match_opts "${words[cword-2]}") ${arr_tmp_opts[@]})' -- $cur ) )
    elif ((cword == last_match_index+2)) && [[ $prev = \! ]] && \
        _iptables_is_match "${words[cword-2]}"
    then # handle negation
        COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts \
            $(_iptables_get_match_opts "${words[cword-2]}"))' -- $cur ) )
    else
        case "$str_last_is" in
            target)
                _iptables_dedupe_opt_alias
                if [[ $str_target = @(ACCEPT|DROP|MIRROR|NOTRACK|TRACE) ]]; then
                    # targets with no option
                    COMPREPLY=( $( compgen -W \
                        '$(_iptables_dedupe_opts ${arr_tmp_opts[@]})' -- $cur ) )
                else
                    # check for mandatory target options
                    str_var="$IFS"
                    for x in ${!arr_targets[@]}; do
                        set -- ${arr_targets[x]}
                        [[ $1 = $str_target ]] || continue
                        _iptables_select_on_inet_family $2 || continue
                        shift 3
                        y=0
                        # check targets option flags
                        for str_tmp; do
                            [[ $str_tmp = *:* ]] || continue
                            local str_flags="${str_tmp#*:}"
                            local str_opt="${str_tmp%:"$str_flags"}"
                            IFS=:
                            set -- $str_flags
                            IFS="$str_var"
                            while (($#)); do
                                if [[ $1 = need ]]; then # mandatory options
                                    for ((i=target_index+1; i < ${#words[@]}-1; i++)); do
                                        if [[ ${words[i]} = $str_opt ]]; then
                                            continue 3
                                        fi
                                    done
                                    arr_tmp_opts=()
                                    break 3
                                elif [[ $1 = need1 ]]; then # mandatory options
                                    let y+=1
                                    for ((i=target_index+1; i < ${#words[@]}-1; i++)); do
                                        if [[ ${words[i]} = $str_opt ]]; then
                                            break 4
                                        fi
                                    done
                                fi
                                shift
                            done
                        done
                        ((y)) && arr_tmp_opts=()
                        break
                    done
                    COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts \
                        $(_iptables_get_target_opts "$str_target") ${arr_tmp_opts[@]})' \
                        -- $cur ) )
                fi
            ;;
            match)
                _iptables_dedupe_opt_alias
                # check for mandatory match options
                str_var="$IFS"
                for x in ${!arr_matches[@]}; do
                    set -- ${arr_matches[x]}
                    [[ $1 = ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} ]] || continue
                    _iptables_select_on_inet_family $2 || continue
                    shift 3
                    y=0
                    # check match option flags
                    for str_tmp; do
                        [[ $str_tmp = *:* ]] || continue
                        local str_flags="${str_tmp#*:}"
                        local str_opt="${str_tmp%:"$str_flags"}"
                        IFS=:
                        set -- $str_flags
                        IFS="$str_var"
                        while (($#)); do
                            if [[ $1 = need ]]; then # mandatory options
                                for ((i=last_match_index+1; i < ${#words[@]}-1; i++)); do
                                    if [[ ${words[i]} = $str_opt ]]; then
                                        continue 3
                                    fi
                                done
                                arr_tmp_opts=()
                                break 3
                            elif [[ $1 = need1 ]]; then # mandatory options
                                let y+=1
                                for ((i=last_match_index+1; i < ${#words[@]}-1; i++)); do
                                    if [[ ${words[i]} = $str_opt ]]; then
                                        break 4
                                    fi
                                done
                            fi
                            shift
                        done
                    done
                    ((y)) && arr_tmp_opts=()
                    break
                done
                COMPREPLY=( $( compgen -W '$(_iptables_dedupe_opts \
                    $(_iptables_get_match_opts "${arr_cmd_matches[${#arr_cmd_matches[@]}-1]}") \
                    ${arr_tmp_opts[@]})' -- $cur ) )
            ;;
            *)
                # by default display all options if no reply was previously found
                _iptables_dedupe_opt_alias
                COMPREPLY=( $( compgen -W \
                    '$(_iptables_dedupe_opts ${arr_tmp_opts[@]})' -- $cur ) )
        esac
    fi
elif [[ $cur != @(\!|\$*) ]]; then # not an option or negation and not a variable request
    # no option given, present hyphen to start option completion
    if ((${#words[@]} == 2)) && [[ -z $cur ]]; then
        compopt -o nospace
        COMPREPLY=( - )
        return 0
    elif ((${#words[@]} == 3)) && [[ -z $cur && $prev = \! ]]; then
        compopt -o nospace
        COMPREPLY=( - )
        return 0
    fi
    case "$prev" in # depend on previous option
        -h|--help|-V|--version) : ;;
        -@(A|-append|C|-check|D|-delete|F|-flush|I|-insert|L|-list|S|-list-rules|X|-delete-chain|Z|-zero))
            # chain name expected next
            COMPREPLY=( $( compgen -W \
                '$(_iptables_get_builtin_chains_by_table $str_table) $(_iptables_get_user_chains $str_table)' \
                -- $cur ) )
        ;;
        -E|--rename-chain|-R|--replace) # retrieve existing chains
            COMPREPLY=( $( compgen -W '$(_iptables_get_user_chains $str_table)' -- $cur ) )
        ;;
        -P|--policy)
            COMPREPLY=( $( compgen -W '$(_iptables_get_builtin_chains_by_table $str_table)' -- $cur ) )
        ;;
        -g|--goto)
            COMPREPLY=( $( compgen -W '$(_iptables_get_user_chains $str_table)' -- $cur ) )
        ;;
        -j|--jump)
            COMPREPLY=( $( compgen -W \
                '$(_iptables_get_target_by_table $str_table) $(_iptables_get_user_chains $str_table)' \
                -- $cur ) )
        ;;
        -t|--table)
            COMPREPLY=( $( compgen -W 'filter mangle nat raw security' -- $cur ) )
        ;;
        -m|--match) arr_tmp=()
            # do not show matches already used
            # except those explicitly defined for multiple usage
            for str_tmp in $(_iptables_get_match_by_table $str_table); do
                # matches already used on the command-line
                for ((i=0; i < ${#arr_all_matches[@]}-1; i++)); do
                    [[ $str_tmp = ${arr_all_matches[i]} ]] || continue
                    if [[ $str_tmp = $str_proto && \
                        $COMP_LINE != *@(-m|--match)+([[:blank:]])$str_tmp* ]]
                    then # proto used matches, allow if it hasnt been used
                        arr_tmp[${#arr_tmp[@]}]="$str_tmp"
                    else # those are always shown
                        for x in ${!arr_global_matches[@]}; do
                            if [[ $str_tmp = ${arr_global_matches[x]%% *} ]]; then
                                arr_tmp[${#arr_tmp[@]}]="$str_tmp"
                                break
                            fi
                        done
                    fi
                    continue 2
                done
                arr_tmp[${#arr_tmp[@]}]="$str_tmp"
            done
            COMPREPLY=( $( compgen -W '${arr_tmp[@]}' -- $cur ) )
        ;;
        -@(i|-in-interface|o|-out-interface|-physdev-in|-physdev-out))
            COMPREPLY=( $( compgen -W '$(_iptables_get_ifnames)' -- $cur ) )
        ;;
        --src-range|--dst-range)
            if [[ $_IPT_IPLIST_FILE && -r $_IPT_IPLIST_FILE ]]; then
                # if a file with ip addresses is in env var, load em
                if [[ $str_app = iptables ]]; then
                str_regex='^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(/([3][0-2]|[1-2]?[0-9]))?$'
                elif [[ $str_app = ip6tables ]]; then
                str_regex='^([0-9a-fA-F]{1,4}(:[0-9a-fA-F]{1,4}){7}|([0-9a-fA-F]{1,4}:){1}(:[0-9a-fA-F]{1,4}){1,6}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,6}(:[0-9a-fA-F]{1,4}){1})(/([1][0-2][0-9]|[1-9]?[0-9]))?$'
                fi
                str_tmp=$(while read -r ip rest; do
                    [[ $ip = *([[:blank:]])\#* ]] && continue
                    ip="${ip//\#*/}"
                    [[ $ip =~ $str_regex ]] && printf "%s\n" "${ip%/*}"
                    done < "${_IPT_IPLIST_FILE}")
            fi
            if [[ $cur = *-* ]]; then
                if [[ $str_tmp ]]; then
                    COMPREPLY+=( $( compgen -P "${cur%-*}-" -W "$str_tmp" -- "${cur#*-}" ) )
                    ((got_bashcompl)) && __ltrim_colon_completions "$str_prefix$cur"
                fi
            else
                if [[ $str_tmp ]]; then
                    compopt -o nospace
                    COMPREPLY+=( $( compgen -W "$str_tmp" -S '-' -- "$cur" ) )
                    ((got_bashcompl)) && __ltrim_colon_completions "$cur"
                fi
            fi
        ;;
        -@(s|-source|d|-destination|-ctorigsrc|-ctorigdst|-ctreplsrc|-ctrepldst|-vaddr|-tunnel-src|-tunnel-dst|-gateway|-on-ip))
            if ((got_bashcompl)); then
               _known_hosts_real -- "$cur"
            else
                if [[ ${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1} ]]; then
                    COMPREPLY=( $( compgen -A hostname "$cur" ) )
                fi
            fi
            if [[ $_IPT_IPLIST_FILE && -r $_IPT_IPLIST_FILE ]]; then
                # if a file with ip addresses is in env var, load em
                if [[ $str_app = iptables ]]; then
                str_regex='^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(/([3][0-2]|[1-2]?[0-9]))?$'
                elif [[ $str_app = ip6tables ]]; then
                str_regex='^([0-9a-fA-F]{1,4}(:[0-9a-fA-F]{1,4}){7}|([0-9a-fA-F]{1,4}:){1}(:[0-9a-fA-F]{1,4}){1,6}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,6}(:[0-9a-fA-F]{1,4}){1})(/([1][0-2][0-9]|[1-9]?[0-9]))?$'
                fi
                str_tmp=$(while read -r ip rest; do
                    [[ $ip = *([[:blank:]])\#* ]] && continue
                    ip="${ip//\#*/}"
                    [[ $ip =~ $str_regex ]] && printf "%s\n" "$ip"
                    done < "${_IPT_IPLIST_FILE}")
                COMPREPLY+=( $( compgen -W "$str_tmp" -- "$cur" ) )
            fi
            if [[ $prev != --gateway ]]; then
                # add networks
                if [[ ${_IPT_COMP_NETWORKS-1} ]]; then
                    if [[ -r /etc/networks ]]; then
                        COMPREPLY+=( $( compgen -W '$(while read -r foo str_net rest
                        do
                            [[ $foo = @(""|*([[:blank:]])#*) ]] && continue
                            [[ $str_net = *([[:blank:]])#* ]] && continue
                            printf "%s\n" "$str_net"
                        done < /etc/networks)' -- "$cur" ) )
                    fi
                fi

                # add ip addresses of interfaces
                if [[ ${_IPT_COMP_IP_LOCAL-1} ]]; then
                    if [[ $str_app = iptables ]]; then
                        str_tmp=-4
                    elif [[ $str_app = ip6tables ]]; then
                        str_tmp=-6
                    fi
                    local one two three rest
                    while read one two three str_var rest; do
                        [[ $str_var = $cur* ]] && COMPREPLY+=("$str_var")
                    done < <(PATH="$PATH:/sbin" command ip $str_tmp -o addr)
                    unset one two three rest
                fi
            fi
            ((got_bashcompl)) && __ltrim_colon_completions "$cur"
            if ((${#COMPREPLY[@]} == 1)) && [[ ${COMPREPLY[0]} != */* ]]
            then
                compopt -o nospace
            fi
        ;;
        -p|--proto|--protocol|--ctproto|--vproto)
            if [[ $prev = --proto ]]; then
                if [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]
                then
                    # policy match also has --proto
                    COMPREPLY=( $( compgen -W 'ah esp ipcomp' -- $cur ) )
                fi
            fi
            if [[ $prev = @(-p|--proto|--protocol) && $str_proto_match ]]; then
                COMPREPLY=( $( compgen -W "$str_proto_match" -- $cur ) )
            fi
            if ! ((${#COMPREPLY[@]})); then
                COMPREPLY=( $( compgen -W '$(_iptables_get_protocols)' -- $cur ) )
            fi
        ;;
        --@(on-port|vport|vportctl))
            COMPREPLY=( $( compgen -W '$(_iptables_get_services -p "$str_proto")' -- $cur ) )
        ;;
        --@(dport|destination-port|sport|source-port|ctorigsrcport|ctorigdstport|ctreplsrcport|ctrepldstport))
            if [[ $cur = *:* ]]; then
                COMPREPLY=( $(_iptables_compl_port_range "$cur") )
                ((got_bashcompl)) && __ltrim_colon_completions "$cur"
            else
                compopt -o nospace
                COMPREPLY=( $( compgen -W '$(_iptables_get_services -p "$str_proto")' -- $cur ) )
            fi
        ;;
        --@(dports|destination-ports|sports|source-ports|ports))
            if [[ $cur = *,* ]]; then
                str_tmp="$cur" str_var="${cur##*,}"
                str_tmp="${str_tmp%"$cur"}"
                if [[ $cur = *:* ]]; then
                     _iptables_build_comma_list "$cur" \
                         $( compgen -P "$str_tmp" -W '$(_iptables_compl_port_range "$str_var")' \
                         -- "$str_var" )
                    ((got_bashcompl)) && __ltrim_colon_completions "$cur"
                else
                    _iptables_build_comma_list "$cur" \
                        $( compgen -P "$str_tmp" -W '$(_iptables_get_services -p "$str_proto")' \
                        -- $str_var )
                fi
            else
                if [[ $cur = *:* ]]; then
                    COMPREPLY=( $(_iptables_compl_port_range "$cur") )
                    ((got_bashcompl)) && __ltrim_colon_completions "$cur"
                else
                    COMPREPLY=( $( compgen -W '$(_iptables_get_services -p "$str_proto")' -- $cur ) )
                fi
            fi
            # as long we dont reach the max dont append a space
            (( $(IFS=,; set -- $cur;printf "%d\n" $#) > 15 )) || compopt -o nospace
        ;;
        --icmp-type)
            COMPREPLY=( $( compgen -W 'any echo-reply pong destination-unreachable \
                network-unreachable host-unreachable protocol-unreachable \
                port-unreachable fragmentation-needed source-route-failed \
                network-unknown host-unknown network-prohibited host-prohibited \
                TOS-network-unreachable TOS-host-unreachable communication-prohibited \
                host-precedence-violation precedence-cutoff source-quench redirect \
                network-redirect host-redirect TOS-network-redirect TOS-host-redirect \
                echo-request ping router-advertisement router-solicitation \
                time-exceeded ttl-exceeded ttl-zero-during-transit ttl-zero-during-reassembly \
                parameter-problem ip-header-bad required-option-missing timestamp-request \
                timestamp-reply address-mask-request address-mask-reply' -- $cur ) )
        ;;
        --icmpv6-type)
            COMPREPLY=( $( compgen -W 'destination-unreachable no-route communication-prohibited \
                address-unreachable port-unreachable packet-too-big time-exceeded ttl-exceeded \
                ttl-zero-during-transit ttl-zero-during-reassembly parameter-problem bad-header \
                unknown-header-type unknown-option echo-request ping echo-reply pong \
                router-solicitation router-advertisement neighbour-solicitation neighbor-solicitation \
                neighbour-advertisement neighbor-advertisement redirect' -- $cur ) )
        ;;
        --reject-with) # REJECT target
            case "$str_app" in
                iptables)
                    COMPREPLY=( $( compgen -W 'icmp-net-unreachable icmp-host-unreachable\
                       icmp-port-unreachable icmp-proto-unreachable icmp-net-prohibited\
                       icmp-host-prohibited icmp-admin-prohibited tcp-reset' -- $cur ) )
                ;;
                ip6tables)
                    COMPREPLY=( $( compgen -W 'icmp6-no-route no-route icmp6-adm-prohibited\
                       adm-prohibited icmp6-addr-unreachable addr-unreach\
                       icmp6-port-unreachable port-unreach tcp-reset' -- $cur ) )
                ;;
            esac
        ;;
        --timeout) # CT target
            if [[ $str_target = CT ]]; then x=0
                while read -r; do
                    if [[ $REPLY = .*"= {" ]]; then
                        ((!x)) && REPLY=${REPLY#.} && printf "%s\n" "${REPLY%=*}" && x=1
                    elif [[ $REPLY = \}\; ]]; then
                        x=0
                    fi
                done < <(PATH=${PATH}:/sbin command nfct timeout list 2>/dev/null)
            fi
        ;;
        --type) # AUDIT target
            COMPREPLY=( $( compgen -W 'accept drop reject' -- $cur ) )
        ;;
        --set-class) # CLASSIFY target TODO: query by interface?
            COMPREPLY=( $( compgen -W '$(while read -r; do
                [[ $REPLY = lo ]] && continue
                for str_dev in $REPLY; do
                    while read c t str_class rest; do
                        [[ $str_class = +([[:digit:]]):+([[:digit:]]) ]] && printf "%s\n" "$str_class"
                    done < <(PATH=${PATH}:/sbin command tc class show dev $str_dev)
                done
                done < <(_iptables_get_ifnames))' -- $cur ) )
            ((got_bashcompl)) && __ltrim_colon_completions "$cur"
        ;;
        --hashmode) # CLUSTERIP target
            COMPREPLY=( $( compgen -W \
                'sourceip sourceip-sourceport sourceip-sourceport-destport' \
                -- $cur ) )
        ;;
        --expevents) # CT target
            COMPREPLY=( $( compgen -W 'new' -- $cur ) )
        ;;
        --ctevents) # CT target
            _iptables_build_comma_list "$cur" new related destroy reply assured \
                protoinfo helper mark natseqinfo secmark
        ;;
        --hmark-tuple) # HMARK target
            _iptables_build_comma_list "$cur" src dst sport dport spi ct
        ;;
        --log-level) # LOG target
            COMPREPLY=( $( compgen -W 'alert crit debug emerg err info notice warning' -- $cur ) )
        ;;
        --nflog-group) # NFLOG target
            str_tmp=$(set +f;cd /proc/sys/net/netfilter/nf_log/ && printf "%s\n" *)
            COMPREPLY=( $( compgen -W '$str_tmp' -- $cur ) )
        ;;
        --strip-options) # TCPOPTSTRIP target
            _iptables_build_comma_list "$cur" wscale mss sack-permitted sack timestamp md5
        ;;
        --@(add-set|del-set|match-set)) # set match and SET target
            COMPREPLY=( $( compgen -W '$(PATH=${PATH}:/sbin command ipset -n list)' -- $cur ) )
            ((got_bashcompl)) && __ltrim_colon_completions "$cur"
        ;;
        --algo) # string match
            COMPREPLY=( $( compgen -W 'bm kmp' -- $cur ) )
        ;;
        --chunk-types) # sctp match
            COMPREPLY=( $( compgen -W 'all any only' -- $cur ) )
        ;;
        --ctstate) # conntrack match
            _iptables_build_comma_list "$cur" NEW ESTABLISHED RELATED INVALID UNTRACKED SNAT DNAT
        ;;
        --ctstatus) # conntrack match
            _iptables_build_comma_list "$cur" NONE EXPECTED SEEN_REPLY ASSURED CONFIRMED
        ;;
        --ctdir) # conntrack match
            COMPREPLY=( $( compgen -W 'ORIGINAL REPLY' -- $cur ) )
        ;;
        --cpu) # cpu match
            str_tmp=$(while read -r str_name c num; do
                [[ $str_name = processor ]] && printf "%s\n" "$num"
                done</proc/cpuinfo)
            COMPREPLY=( $( compgen -W '$str_tmp' -- $cur ) )
        ;;
        --connbytes-dir) # connbytes match
            COMPREPLY=( $( compgen -W 'original reply both' -- $cur ) )
        ;;
        --connbytes-mode) # connbytes match
            COMPREPLY=( $( compgen -W 'packets bytes avgpkt' -- $cur ) )
        ;;
        --dccp-types) # dccp match
            _iptables_build_comma_list "$cur" REQUEST RESPONSE DATA ACK \
                DATAACK CLOSEREQ CLOSE RESET SYNC SYNCACK INVALID
        ;;
        --log|--ttl) # osf match
            COMPREPLY=( $( compgen -W '0 1 2' -- $cur ) )
        ;;
        --ecn-ip-ect) # ecn match
            COMPREPLY=( $( compgen -W '0 1 2 3' -- $cur ) )
        ;;
        --header) # header match TODO: add protocols list?
            _iptables_build_comma_list "$cur" hop dst route frag auth esp none
        ;;
        --mac-source)
            str_regex='^([[:xdigit:]]{2})(:[[:xdigit:]]{2}){5}$'
            x=0 y=0
            if [[ ${_IPT_MAC_COMPL_MODE:=both} = both ]]; then
                x=1 y=1
            elif [[ $_IPT_MAC_COMPL_MODE = file ]]; then
                x=1
            elif [[ $_IPT_MAC_COMPL_MODE = system ]]; then
                y=1
            fi
            if ((x)); then
                if [[ $_IPT_MACLIST_FILE && -r $_IPT_MACLIST_FILE ]]
                then
                    # if a file with mac addresses is in env var, load em
                    str_tmp=$(while read -r mac rest; do
                        [[ $mac = *([[:blank:]])\#* ]] && continue
                        mac="${mac//\#*/}"
                        [[ $mac =~ $str_regex ]] && printf "%s\n" "$mac"
                        done < "${_IPT_MACLIST_FILE}")
                    COMPREPLY=( $( compgen -W "$str_tmp" -- "$cur" ) )
                fi
            fi
            if ((y)); then
                # read arp cache, addresses of local interfaces and /etc/ethers
                str_tmp=$(while read a b addr rest; do
                    [[ $addr =~ $str_regex ]] && printf "%s\n" "$addr"
                    done < <(PATH=$PATH:/sbin command arp -n 2>/dev/null))
                str_tmp+=" $(while read -r; do
                    [[ $REPLY = *link/loopback* ]] && continue
                    REPLY=${REPLY#*link/*+([[:blank:]])}
                    REPLY=${REPLY%+([[:blank:]])brd*}
                    [[ $REPLY =~ $str_regex ]] && printf "%s\n" "$REPLY"
                    done < <(PATH=$PATH:/sbin command ip -o link show 2>/dev/null))"
                if [[ -r /etc/ethers ]]; then
                    str_tmp+=" $(while read -r addr rest; do
                        [[ $addr =~ $str_regex ]] && printf "%s\n" "$addr"
                        done < /etc/ethers)"
                fi
                COMPREPLY+=( $( compgen -W "$str_tmp" -- "$cur" ) )
            fi
            ((got_bashcompl)) && __ltrim_colon_completions "$cur"
        ;;
        --mode) # overlap in option names, policy and statistic match both have --mode
            if [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = policy ]]; then
                COMPREPLY=( $( compgen -W 'tunnel transport' -- $cur ) )
            elif [[ ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = statistic ]]; then
                COMPREPLY=( $( compgen -W 'random nth' -- $cur ) )
            fi
        ;;
        --dir) # policy match
            COMPREPLY=( $( compgen -W 'in out' -- $cur ) )
        ;;
        --pol) # policy match
            COMPREPLY=( $( compgen -W 'none ipsec' -- $cur ) )
        ;;
        --nfacct-name) # nfacct match
            str_tmp=$( while read -r; do
                REPLY="${REPLY%;}"
                printf "%s\n" ${REPLY##*=}
            done < <(PATH=${PATH}:/sbin command nfacct list) )
            COMPREPLY=( $( compgen -W '$str_tmp' -- $cur ) )
        ;;
        --uid-owner) # owner match
            COMPREPLY=( $( compgen -u -- $cur ) )
        ;;
        --gid-owner) # owner match
            COMPREPLY=( $( compgen -g -- $cur ) )
        ;;
        --pkt-type) # pkttype match
            COMPREPLY=( $( compgen -W 'unicast broadcast multicast' -- $cur ) )
        ;;
        --realm) # realm match
            COMPREPLY=( $( compgen -W '$(while read -r; do
                [[ $REPLY = *([[:space:]])#* ]] && continue
                if [[ $REPLY = *([[:space:]])+([[:digit:]])+([[:space:]])+([[:graph:]])* ]]
                then
                    str_tmp="${REPLY#*+([[:digit:]])+([[:space:]])}"
                    printf "%s\n" "${str_tmp%#*}"
                fi
                done </etc/iproute2/rt_realms)' -- $cur ) )
        ;;
        --state) # state match
            _iptables_build_comma_list "$cur" NEW ESTABLISHED RELATED INVALID UNTRACKED
        ;;
        --src-type|--dst-type) # addrtype match
            COMPREPLY=( $( compgen -W 'UNSPEC UNICAST LOCAL BROADCAST \
                ANYCAST MULTICAST BLACKHOLE UNREACHABLE PROHIBIT THROW NAT XRESOLVE' \
                -- $cur ) )
        ;;
        --dscp-class|--set-dscp-class) # dscp match and DSCP target
            COMPREPLY=( $( compgen -W \
                'BE EF AF11 AF12 AF13 AF21 AF22 AF23 AF31 AF32 AF33 AF41 AF42 AF42 CS1 CS2 CS3 Cs4' \
                -- $cur ) )
        ;;
        --rateest-interval|--rateest-ewmalog) # RATEEST target
            if [[ $cur = +([[:digit:]])?(.*([[:digit:]]))*([[:alpha:]]) ]]; then # glob not perfect, requires more work
                COMPREPLY=( $( compgen -W \
                    '${cur//[[:alpha:]]/}s ${cur//[[:alpha:]]/}ms ${cur//[[:alpha:]]/}us' \
                    -- $cur ) )
            fi
        ;;
        --rateest-@(bps|pps|bps1|bps2|pps1|pps2)) # rateest match
            if [[ $cur = +([[:digit:]])?(.*([[:digit:]]))*([[:alpha:]]) ]]; then # glob not perfect, requires more work
                str_tmp="${cur%%[[:alpha:]]}"
                COMPREPLY=( $( compgen -P "$str_tmp" -W \
                    'bit kbit mbit gbit tbit Kibit Mibit Gibit Tibit Bps \
                    KBps MBps GBps TBps KiBps MiBps GiBps TiBps' \
                    -- ${cur##+([[:digit:]])?(.*([[:digit:]]))} ) )
            fi
        ;;
        --limit|--hashlimit-above|--hashlimit-upto) # limit match
            if [[ $cur = +([[:digit:]])?(/*([[:alpha:]])) ]]; then
                str_tmp="${cur//+(\/|+([[:alpha:]]))/}"
                COMPREPLY=( $( compgen -W \
                    '${str_tmp}/second ${str_tmp}/minute ${str_tmp}/hour ${str_tmp}/day' \
                    -- $cur ) )
            fi
        ;;
        --hashlimit-mode) # hashlimit match
            _iptables_build_comma_list "$cur" srcip srcport dstip dstport
        ;;
        --tos|--set-tos) # tos match and TOS target
            if [[ $str_app = iptables ]]; then
                COMPREPLY=( $( compgen -W \
                    'Minimize-Delay Maximize-Throughput Maximize-Reliability \
                    Minimize-Cost Normal-Service' -- $cur ) )
            fi
        ;;
        --vdir) # ipvs match
            COMPREPLY=( $( compgen -W 'ORIGINAL REPLY' -- $cur ) )
        ;;
        --vmethod) # ipvs match
            COMPREPLY=( $( compgen -W 'GATE IPIP MASQ' -- $cur ) )
        ;;
        --weekdays) # time match
            _iptables_build_comma_list "$cur" Mon Tue Wed Thu Fri Sat Sun
        ;;
    *)
    i=$((cword - 2))
    if ((i >= 1)); then # depend on option before previous option
        case "${words[i]}" in
            -P|--policy) # chain policy
                COMPREPLY=( $( compgen -W 'ACCEPT DROP' -- $cur ) )
            ;;
            --add-set|--del-set|--match-set) # set match and SET target
                # build flag list
                prefix="" arr_tmp=(src dst)
                str_tmp=$(IFS=\|; printf "%s" "${arr_tmp[*]}")
                if [[ $cur ]]; then
                    if [[ ${cur} = @($str_tmp) ]]; then
                        prefix="${cur}," cur=""
                    elif [[ ${cur:$((${#cur}-1))} = , ]]; then
                        prefix="${cur}" cur=""
                    elif [[ ${cur:$((${#cur}-1))} != , ]]; then
                        if [[ ${cur##*,} != @($str_tmp) ]]; then
                            prefix="${cur%${cur##*,}}"
                            [[ $cur = *,* ]] && cur="${cur##*,}"
                            [[ $prefix && ${prefix:$((${#prefix}-1))} != , ]] && prefix="${prefix},"
                        else
                            prefix="${cur}," cur=""
                        fi
                    fi
                fi
                (($(IFS=,; set -- ${prefix}; printf "%d\n" $#) < 5)) && compopt -o nospace
                COMPREPLY=( $( compgen -P "${prefix}" -W '${arr_tmp[@]}' -- "$cur" ) )
            ;;
            *)
            if [[ $str_last_is = match && ${arr_cmd_matches[${#arr_cmd_matches[@]}-1]} = sctp ]]
            then # sctp match allows multiple option arguments
                for ((i=cword-1; i > last_match_index; i--)); do
                    if [[ ${words[i]} = -?* && ${words[i]} != --chunk-types ]]
                    then break
                    elif [[ ${words[i]} = --chunk-types ]]; then
                        if [[ $cur = *,* ]]; then
                            _iptables_build_comma_list "$cur" DATA INIT INIT_ACK SACK \
                                HEARTBEAT HEARTBEAT_ACK ABORT SHUTDOWN SHUTDOWN_ACK \
                                ERROR COOKIE_ECHO COOKIE_ACK ECN_ECNE ECN_CWR \
                                SHUTDOWN_COMPLETE ASCONF ASCONF_ACK FORWARD_TSN
                            break
                        elif [[ $cur = *:* ]]; then
                            str_tmp="${cur%%:*}" str_prefix="${cur%%:*}:" cur="${cur##*:}"
                            if [[ $str_tmp = DATA ]]; then
                                COMPREPLY=( $( compgen -P "$str_prefix" \
                                    -W 'I U B E i u b e' -- "$cur" ) )
                            elif [[ $str_tmp = @(ABORT|SHUTDOWN_COMPLETE) ]]; then
                                COMPREPLY=( $( compgen -P "$str_prefix" -W 'T t' -- "$cur" ) )
                            fi
                            ((got_bashcompl)) && __ltrim_colon_completions "$str_prefix$cur"
                            break
                        elif [[ $cur = @(DATA|ABORT|SHUTDOWN_COMPLETE) ]]; then
                            compopt -o nospace
                            COMPREPLY=( "${cur}:" "${cur}," )
                            break
                        elif [[ $cur = @(INIT|INIT_ACK|SACK|HEARTBEAT|HEARTBEAT_ACK|SHUTDOWN|\
                            SHUTDOWN_ACK|ERROR|COOKIE_ECHO|COOKIE_ACK|ECN_ECNE|ECN_CWR|\
                            ASCONF|ASCONF_ACK|FORWARD_TSN) ]]
                        then
                            compopt -o nospace
                            COMPREPLY=( "${cur}," )
                            break
                        else
                            compopt -o nospace
                            COMPREPLY=( $( compgen -W 'DATA INIT INIT_ACK SACK \
                                HEARTBEAT HEARTBEAT_ACK ABORT SHUTDOWN SHUTDOWN_ACK \
                                ERROR COOKIE_ECHO COOKIE_ACK ECN_ECNE ECN_CWR \
                                SHUTDOWN_COMPLETE ASCONF ASCONF_ACK FORWARD_TSN' \
                                -- $cur ) )
                            break
                        fi
                    fi
                done
            fi
            ;;
        esac
    fi
    esac
elif [[ $cur = \$\(* ]]; then # command substitution
    cur=${cur#??}
    COMPREPLY=( $(compgen -c -P '$(' $cur) )
elif [[ $cur = \$\{* ]]; then # variables with a leading `${'
    cur=${1#??}
    COMPREPLY=( $(compgen -v -P '${' -S '}' $cur) )
elif [[ $cur = \$* ]]; then # variables with a leading `$'
    cur=${cur#?}
    COMPREPLY=( $(compgen -v -P '$' $cur ) )
fi

case "${COMPREPLY[0]}" in
    --modprobe=)
        compopt -o nospace
    ;;
esac

if [[ $_DEBUG_NF_COMPLETION ]]; then
    printf "COMPREPLY:\n"
    printf "<%s>\n" "${COMPREPLY[@]}"
fi
}
complete -F _iptables_complete iptables ip6tables

